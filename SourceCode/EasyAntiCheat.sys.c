/* This file was generated by the Hex-Rays decompiler.
   Copyright (c) 2007-2020 Hex-Rays <info@hex-rays.com>

   Detected compiler: Visual C++
*/

#include <windows.h>
#include <defs.h>

#include <stdarg.h>


//-------------------------------------------------------------------------
// Function declarations

char sub_140001000();
bool sub_140001014();
bool sub_14000102C();
void __fastcall sub_140003B10(__int64 a1);
__int64 __fastcall sub_140003C4C(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 __fastcall sub_140003D70(__int64 a1);
__int64 __fastcall sub_140003DBC(_DWORD *a1, _DWORD *a2);
__int64 __fastcall sub_1400050FC(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14000512C(_BYTE *a1, unsigned int a2, unsigned int a3);
__int64 __fastcall sub_14000515C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
bool __fastcall sub_1400051F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_1400052F4(__int64 *a1);
bool __fastcall sub_140005810(__int64 a1);
void __fastcall sub_140005A18(__int64 a1);
char __fastcall sub_140005A68(PVOID Object);
void sub_140005B74();
void __fastcall sub_140005BC8(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140005EBC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_1400064FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
void __fastcall sub_140006604(__int64 a1);
__int64 __fastcall sub_140006740(__int64 a1, __int64 a2, unsigned __int64 a3);
__int64 sub_140006A18();
void __fastcall sub_140006B44(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
void __fastcall sub_140006C58(__int64 a1);
char __fastcall sub_140006E64(__int64 a1);
__int64 __fastcall sub_140006E78(_WORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
char __fastcall sub_140006EE4(__int64 a1);
LONG __fastcall sub_140006F00(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140006F2C(char **a1, char *a2);
char __fastcall sub_140006F6C(__int16 *a1, __int16 *a2);
char __fastcall sub_140007090(__int64 a1, unsigned __int16 a2);
char __fastcall sub_1400070E0(__int64 a1, __int64 a2);
char __fastcall sub_140007178(__int64 a1, unsigned __int16 *a2, unsigned __int16 a3);
char __fastcall sub_14000721C(__int64 a1, __int64 a2);
void __fastcall sub_14000724C(__int64 a1);
__int64 __fastcall sub_140007274(unsigned __int16 *a1, unsigned __int16 *a2, __int64 a3, __int64 a4, ULONG BytesInUnicodeString);
__int64 __fastcall sub_140007338(unsigned __int16 *a1, __int64 a2);
__int64 __fastcall sub_1400073D4(unsigned __int16 *a1, unsigned __int16 *a2);
unsigned __int64 __fastcall sub_14000746C(__int64 a1, __int64 a2, unsigned __int16 *a3);
unsigned __int64 __fastcall sub_1400074D4(__int64 a1, __int64 a2, unsigned __int16 *a3);
char __fastcall sub_140007538(__int64 a1, _BYTE *a2, unsigned __int64 a3);
char *__fastcall sub_140007598(char *a1, char *a2, unsigned __int64 a3);
_BYTE *__fastcall sub_14000761C(_BYTE *a1, unsigned __int8 *a2, unsigned __int64 a3);
__int64 __fastcall sub_140007688(__int64 a1, unsigned __int64 a2);
__int64 __fastcall sub_1400076B4(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1400076F8(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140007788(__int64 a1, __int16 *a2, unsigned __int16 a3);
unsigned __int8 *__fastcall sub_140007824(_DWORD *a1, unsigned __int8 *a2, int a3);
__int64 __fastcall sub_1400082A0(_QWORD, _QWORD); // weak
__int64 __fastcall sub_14000835C(_QWORD, _QWORD); // weak
void sub_1400084A4();
char __fastcall sub_1400086EC(PVOID ValueData, __int64 a2, __int64 a3, __int64 a4, int a5, int a6, int a7, __int64 a8);
NTSTATUS sub_140008BAC();
__int64 __fastcall sub_140008E4C(); // weak
char sub_14000A0C0();
__int64 __fastcall sub_14000A0E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ULONG SystemInformation);
__int64 __fastcall sub_14000A180(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14000A1B0(CHAR *a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14000A70C(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 a4);
char __fastcall sub_14000A7C4(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4);
NTSTATUS __fastcall sub_14000A818(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, union _LARGE_INTEGER Interval);
__int64 __fastcall sub_14000A840(__int64 a1);
__int64 __fastcall sub_14000A890(int a1, int a2);
void __fastcall sub_14000A8E8(_BYTE *a1, __int64 a2);
__int64 __fastcall sub_14000A930(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
void sub_14000A99C();
char __fastcall sub_14000AABC(__int64 a1, __int64 a2);
char sub_14000AC3C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...);
char __fastcall sub_14000ACA0(struct _FILE_OBJECT *a1, __int64 a2, __int64 a3, __int64 a4, POBJECT_NAME_INFORMATION ObjectNameInformation);
char __fastcall sub_14000AD14(PFILE_OBJECT FileObject, __int64 a2, __int64 a3, __int64 a4, PFLT_FILE_NAME_INFORMATION FileNameInformation);
char __fastcall sub_14000ADD4(__int64 a1, __int64 a2);
bool __fastcall sub_14000AF90(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, int *a6, char *a7);
char __fastcall sub_14000BB08(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, __int64 a7, unsigned __int64 a8);
char __fastcall sub_14000C0C8(__int64 a1);
bool __fastcall sub_14000C2F4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
char __fastcall sub_14000CD78(__int64 a1);
char __fastcall sub_14000D0A4(__int64 a1);
__int64 sub_14000D5A4();
_DWORD *__fastcall sub_14000D730(__int64 a1, _DWORD *a2);
char __fastcall sub_14000D7DC(__int64 a1, unsigned __int64 a2);
char __fastcall sub_14000DB00(__int64 a1, unsigned __int64 a2, _QWORD *a3, unsigned __int64 *a4);
char __fastcall sub_14000DC04(HANDLE FileHandle, __int64 a2);
PVOID __fastcall sub_14000DCA8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object);
char __fastcall sub_14000DE34(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, PVOID Object, int *a7, __int64 *a8);
void __fastcall sub_14000E6C4(__int64 a1);
__int64 sub_14000EC40();
__int64 sub_14000EC74();
__int64 __fastcall sub_14000ECA4(__int64 a1);
__int64 sub_14000ECDC();
__int64 (__fastcall *__fastcall sub_14000ED08(__int64 a1, __int64 a2))(__int64, __int64);
__int64 __fastcall sub_14000ED48(__int64 a1);
__int64 __fastcall sub_14000ED8C(__int64 a1, __int64 a2);
void __fastcall sub_14000F914(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
void __fastcall sub_14000FA44(__int64 a1, int a2, __int64 a3, __int64 a4);
void __fastcall sub_14000FD64(__int64 a1, unsigned int *a2);
bool __fastcall sub_140010198(_BYTE *a1);
__int64 __fastcall sub_140010244(__int16 *a1, __int64 a2, _QWORD *a3);
void __fastcall sub_14001055C(unsigned int a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
void sub_1400106BC();
__int64 __fastcall sub_1400115F4(__int64 a1, __int64 a2);
__int64 __fastcall sub_140011660(__int64 a1);
void sub_14001172C();
__int64 sub_140012654();
__int64 __fastcall sub_140012888(__int64 a1, __int64 a2);
__int64 __fastcall sub_14001298C(__int64 a1, __int64 (__fastcall *a2)(__int64), __int64 a3);
char __fastcall sub_140012A14(HANDLE a1, __int64 a2, __int64 a3, int a4, PVOID Object, __int64 a6, __int64 a7, __int64 a8, char a9);
void sub_140012C4C();
__int64 __fastcall sub_140012C8C(); // weak
__int64 __fastcall sub_14001354C(__int64 a1, unsigned __int64 a2);
char __fastcall sub_1400135E4(__int64 a1, int a2, int a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall sub_140013698(__int64 *a1, unsigned __int64 a2, __int64 a3, char a4, __int64 a5);
_QWORD *__fastcall sub_14001387C(_QWORD *a1, _QWORD *a2, unsigned __int64 a3);
__int64 __fastcall sub_140013B84(__int64 a1, __int64 a2, __int64 a3, __int64 *a4);
char __fastcall sub_140013C40(int a1);
char __fastcall sub_140013D4C(__int64 a1);
bool __fastcall sub_140013D94(__int64 a1, void *a2, __int64 a3, __int64 a4, __int16 a5, __int64 a6, PVOID Object);
bool __fastcall sub_140013E74(__int64 a1, __int64 *a2);
__int64 sub_140013ED8();
__int64 __fastcall sub_140013EF0(__int64 a1);
void sub_140014038();
__int64 __fastcall sub_140014260(__int64 a1);
__int64 __fastcall sub_140014298(__int64 a1);
__int64 __fastcall sub_1400142D0(__int64 a1);
__int64 __fastcall sub_140014308(_QWORD, _QWORD); // weak
__int64 __fastcall sub_140014384(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object);
__int64 __fastcall sub_14001449C(__int64 a1);
char __fastcall sub_1400144E4(__int64 a1, _BYTE *a2);
char __fastcall sub_140014544(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140014648(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140014760(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5);
char __fastcall sub_1400147FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object);
bool __fastcall sub_140014874(unsigned __int16 *a1, __int64 a2, __int64 a3, __int64 a4);
unsigned __int64 __fastcall sub_140014914(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, PVOID Object);
char __fastcall sub_1400149C0(__int64 a1, ULONG64 a2, __int64 a3, __int64 a4, PVOID Object);
char __fastcall sub_140014A78(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, PVOID Object);
char __fastcall sub_140014B2C(__int64 a1, ULONG64 a2, __int64 a3, __int64 a4, PVOID Object);
__int64 __fastcall sub_140014BD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
bool __fastcall sub_140014C20(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6);
bool __fastcall sub_140014C6C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_140014CAC(_QWORD, _QWORD); // weak
char __fastcall sub_140014E50(__int64 a1, char a2, __int64 *a3);
__int64 __fastcall sub_1400151F8(_QWORD, _QWORD); // weak
char __fastcall sub_140015378(__int64 a1, __int64 a2);
char __fastcall sub_1400157F4(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140015854(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140015A8C(ULONG64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
char __fastcall sub_140015C14(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4, __int64 a5, int a6, unsigned __int64 a7);
void sub_140015EE4();
void __fastcall sub_140016104(__int64 a1);
char __fastcall sub_1400167AC(ULONG64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
char __fastcall sub_140016B18(__int64 a1);
char __fastcall sub_140016F8C(__int64 a1);
char __fastcall sub_1400172C0(ULONG64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_140017608(__int64 a1, _DWORD *a2, _DWORD *a3, _DWORD *a4);
unsigned __int8 __fastcall sub_1400176F0(unsigned __int8 *a1, unsigned int a2, __int64 a3);
char __fastcall sub_14001786C(__int64 a1, unsigned int a2, __int64 a3);
__int64 __fastcall sub_140017A60(char *a1, unsigned int *a2, __int64 a3, char a4);
char **__fastcall sub_140017CBC(char **a1, char *a2, unsigned int *a3);
__int64 __fastcall sub_140017F34(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_140018084(__int64 a1);
char __fastcall sub_1400180C8(unsigned __int8 *a1, __int64 a2);
__int64 __fastcall sub_1400189F8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall sub_140018C5C(__int64 a1, __int64 a2);
void __fastcall sub_140018D00(__int64 a1, __int64 a2, ULONG64 a3, __int64 a4);
void **__fastcall sub_140018F4C(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, int *a5);
char __fastcall sub_14001916C(__int64 a1);
__int64 *__fastcall sub_140019684(__int64 **a1);
char sub_1400197A0();
__int64 __fastcall sub_140019E44(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_14001A0D8(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall sub_14001A338(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
void __fastcall sub_14001AE38(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14001B0F8(__int64 a1, __int64 a2, __int64 a3);
void sub_14001B640();
void sub_14001D168();
struct _KEVENT *__fastcall sub_14001F828(char a1);
char __fastcall sub_14001F904(PFAST_MUTEX FastMutex, __int64 a2, __int64 a3, unsigned int a4);
_QWORD *__fastcall sub_14001FA54(PFAST_MUTEX FastMutex, __int64 a2);
char __fastcall sub_14001FAD4(PFAST_MUTEX FastMutex, __int64 a2);
void __fastcall sub_14001FB50(PFAST_MUTEX FastMutex, __int64 a2);
void __fastcall sub_14001FBDC(PVOID P);
void __fastcall sub_140021868(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1400218E0(__int64 a1);
void __fastcall sub_140021988(__int64 a1);
__int64 sub_14002264C();
void sub_1400226A0();
char *__fastcall sub_140022938(int a1);
char __fastcall sub_1400229AC(ULONG64 a1, __int64 a2, __int64 a3);
void __fastcall sub_140022FD4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, int a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16);
void __fastcall sub_14002308C(__int64 a1, __int64 a2, __int64 a3);
char *__fastcall sub_140023194(__int64 a1, unsigned __int64 a2, __int64 a3);
char __fastcall sub_140023294(_DWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9, __int64 a10, unsigned __int64 a11, unsigned int a12);
void __fastcall sub_140023388(unsigned __int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, int a11);
void __fastcall sub_1400234DC(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9, unsigned int a10);
void __fastcall sub_140023680(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9, unsigned int a10);
void __fastcall sub_140023818(unsigned int *a1, __int64 a2, unsigned __int64 a3, __int64 a4);
void __fastcall sub_14002394C(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, int a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall sub_140023B20(_DWORD, _DWORD, _DWORD, _DWORD, char); // weak
__int64 __fastcall sub_140023BFC(__int64 a1, int a2, int a3, char a4, int a5);
void __fastcall sub_140023C8C(__int64 a1);
void __fastcall sub_140023CA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, int a11, int a12, int a13, __int64 a14, __int64 a15);
unsigned __int64 __fastcall sub_1400242A8(__int64 a1, __int64 a2, __int64 *a3);
char __fastcall sub_140024600(__int64 a1);
char __fastcall sub_140024F34(unsigned __int64 a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
char __fastcall sub_140025134(unsigned __int64 a1, __int64 *a2, __int64 *a3);
__int64 __fastcall sub_1400252E0(); // weak
__int64 __fastcall sub_140025404(_BYTE *a1, unsigned int a2);
char __fastcall sub_14002591C(__int64 a1, unsigned int a2, _QWORD *a3);
char __fastcall sub_140025A00(unsigned __int64 a1, __int64 a2, __int64 *a3, __int64 a4, _DWORD *a5);
bool __fastcall sub_140025BC0(unsigned __int8 *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_1400271FC(); // weak
__int64 __fastcall sub_1400273C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, ULONG *a6, char *a7, __int64 a8);
signed __int64 __fastcall sub_140028CF4(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, char a4);
unsigned __int64 **__fastcall sub_140028F54(unsigned __int64 **a1, unsigned __int64 *a2, unsigned __int64 *a3);
void __fastcall sub_14002916C(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_14002926C(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3);
_DWORD *__fastcall sub_140029560(unsigned __int64 a1, _DWORD *a2);
__int64 sub_1400295BC();
void sub_140029664();
bool __fastcall sub_1400296A0(unsigned __int64 a1, __int64 a2, unsigned __int64 *a3);
char __fastcall sub_1400296CC(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3);
char __fastcall sub_140029758(__int64 a1, unsigned __int64 a2, int a3, __int64 a4);
char __fastcall sub_1400297B8(__int64 a1, int a2, __int64 a3, __int64 a4);
char __fastcall sub_1400298B8(__int64 a1, int *a2, __int64 a3, __int64 *a4);
void __fastcall sub_140029998(__int64 a1);
char __fastcall sub_140029A00(unsigned __int64 *a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall sub_140029C7C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
char __fastcall sub_140029F7C(__int64 a1, __int64 a2, unsigned int a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int *a9);
char __fastcall sub_14002A06C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int *a9);
__int64 __fastcall sub_14002A350(__int64 a1);
char __fastcall sub_14002A548(unsigned __int16 *a1, __int64 a2);
char __fastcall sub_14002A624(__int64 a1, unsigned __int64 a2, __int64 a3);
char __fastcall sub_14002A768(__int64 a1, unsigned __int64 a2, __int64 a3);
char __fastcall sub_14002A8C8(__int64 a1, unsigned __int64 a2, void *a3);
void __fastcall sub_14002A94C(__int64 a1);
unsigned __int64 sub_14002A964();
__int64 __fastcall sub_14002AAC8(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14002AC18(__int64 a1, unsigned int a2, __int64 a3);
unsigned __int64 __fastcall sub_14002AF9C(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, char a4);
unsigned __int64 *__fastcall sub_14002B21C(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
void __fastcall sub_14002B4AC(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_14002BACC(unsigned int a1);
__int64 __fastcall sub_14002C0B8(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14002C31C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_14002C384(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_14002C3E0(volatile signed __int64 *a1);
char __fastcall sub_14002C40C(volatile void *a1, __int64 a2);
void sub_14002CB08();
__int64 __fastcall sub_14002D2D8(__int64 a1, unsigned int a2);
__int64 __fastcall sub_14002D658(); // weak
__int64 __fastcall sub_14002D72C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5);
__int64 __fastcall sub_14002D880(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, char a4);
__int64 __fastcall sub_14002DBA4(__int64 a1, __int64 a2);
unsigned __int64 *__fastcall sub_14002DDFC(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3);
void __fastcall sub_14002E8D4(__int64 a1, __int64 a2, __int64 a3);
unsigned __int64 __fastcall sub_14002EB78(__int64 a1, __int64 a2, __int64 a3);
void sub_14002F228();
__int64 sub_14002F378();
__int64 sub_14002F3D8(void); // weak
__int64 __fastcall sub_14002F51C(ULONG64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void sub_14002F5F8();
__int64 __fastcall sub_14002F770(); // weak
__int64 __fastcall sub_14002F828(__int64 a1, unsigned int a2, void *a3, _DWORD *a4, __int64 a5, __int64 a6, PVOID a7, _DWORD *a8);
char sub_14002FBD8();
char __fastcall sub_14002FC18(__int64 a1);
void __fastcall sub_14002FC44(void *a1);
LONG_PTR sub_14002FC9C();
__int64 __fastcall sub_14002FD08(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
char __fastcall sub_14002FDD8(__int64 a1, ULONG64 a2, __int64 a3, unsigned int a4, unsigned int a5);
__int64 __fastcall sub_14002FED0(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14002FF18(unsigned __int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_14003004C(__int64 a1);
__int64 __fastcall sub_14003019C(unsigned __int64 a1, unsigned __int64 a2, void *a3);
__int64 __fastcall sub_14003020C(__int64 a1, __int64 a2, __int64 a3);
bool __fastcall sub_140030250(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_14003026C(__int64 a1, __int64 a2);
char __fastcall sub_1400302C0(unsigned __int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 __fastcall sub_140030428(__int64 a1, __int64 a2, unsigned int a3);
void __fastcall sub_140030478(__int64 a1, int a2, __int64 a3);
char __fastcall sub_140030674(ULONG64 *a1);
void sub_1400306D0();
__int64 __fastcall sub_140030734(ULONG64 *a1, int a2, __int64 a3, int a4);
char __fastcall sub_1400307A8(__int64 a1);
bool __fastcall sub_14003097C(__int64 a1, int a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall sub_1400309AC(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
char __fastcall sub_1400317F8(ULONG64 a1, __int64 a2, __int64 a3);
void __fastcall sub_1400318E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6);
__int64 __fastcall sub_1400319C4(__int64 a1);
char __fastcall sub_140031BA0(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, unsigned int a8);
char __fastcall sub_140031DB4(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, unsigned int a8);
void __fastcall sub_140031FCC(__int64 a1, __int64 a2, int a3, __int64 a4);
bool __fastcall sub_140032104(__int64 a1, unsigned __int64 a2, __int64 *a3, _QWORD *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, _QWORD *a9, _DWORD *a10, _DWORD *a11);
void __fastcall sub_1400323DC(ULONG64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_140034AD0(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
void __fastcall sub_140034B38(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 sub_140034BDC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...);
char __fastcall sub_140034C4C(PVOID Object, __int64 a2, __int64 a3, __int64 a4, ULONG ResultLength, __int64 a6, __int64 a7, HANDLE KeyHandle);
char __fastcall sub_140034D98(__int64 a1);
__int64 __fastcall sub_1400352E8(__int64 a1, __int64 a2, __int64 a3, char ***a4);
__int64 __fastcall sub_140035BE4(_QWORD *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, ULONG64 a8);
__int64 __fastcall sub_140036B94(__int64 a1, __int64 a2);
__int64 __fastcall sub_140036DBC(__int64 a1, __int64 a2);
__int64 __fastcall sub_140036E28(__int64 a1, __int64 a2);
__int64 __fastcall sub_140036EA0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140036F0C(__int64 a1, __int64 a2);
__int64 __fastcall sub_140036FB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400371F8(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_140037538(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, PVOID Object);
void sub_140037BC0();
__int64 __fastcall sub_140037D0C(); // weak
char __fastcall sub_140037D6C(__int64 a1);
void sub_140037EE8();
__int64 __fastcall sub_1400383D8(__int64 a1, unsigned int a2, __int64 a3, char a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9);
__int64 __fastcall sub_140038450(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400384B8(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140038530(__int64 a1);
char __fastcall sub_140038568(__int64 a1, __int64 *a2);
bool __fastcall sub_140038678(_BYTE *a1, int a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
bool __fastcall sub_140038794(_BYTE *a1, _BYTE *a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9);
char __fastcall sub_1400388B0(unsigned __int64 a1, char a2, unsigned int *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9, _WORD *a10);
char __fastcall sub_140038FB8(unsigned __int16 *a1, __int64 a2);
void __fastcall sub_14003927C(__int64 a1);
void __fastcall sub_140039538(__int64 a1);
char __fastcall sub_14003981C(__int64 a1, __int64 a2, void *a3);
char __fastcall sub_14003B930(__int64 a1);
char __fastcall sub_14003C698(__int64 a1, __int64 a2);
char __fastcall sub_14003C714(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
char __fastcall sub_14003C84C(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14003D284(unsigned __int16 *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14003E9C4(); // weak
__int64 __fastcall sub_14003E9D0(); // weak
__int64 __fastcall sub_14003E9D8(__int64 a1);
__int64 __fastcall sub_14003EAA0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall __far sub_14003ED2C(_DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD); // weak
__int64 __fastcall sub_1400402AC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object);
struct _KPROCESS *__fastcall sub_140040474(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object);
char __fastcall sub_14004059C(__int64 a1);
void sub_14004082C();
char __fastcall sub_140040928(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
char __fastcall sub_140040A04(__int64 a1, _QWORD *a2);
char __fastcall sub_140040B44(__int64 a1, _QWORD *a2);
char __fastcall sub_140040C64(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
char __fastcall sub_140040D50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
void sub_140040E20();
void __fastcall sub_140040EE4(__int64 a1, __int64 a2, _DWORD *a3);
char __fastcall sub_140042030(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5);
void sub_1400421F0();
void sub_140042300();
void __fastcall sub_140042418(__int64 a1, __int64 a2, __int64 a3, int a4);
void sub_140042738();
__int64 __fastcall sub_140043058(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400430D8(__int64 *a1, __int64 a2, unsigned __int64 a3);
char __fastcall sub_1400435A0(__int64 a1, __int64 a2, _QWORD *a3, _DWORD *a4);
char __fastcall sub_140043638(__int64 a1, unsigned int a2);
__int64 sub_14004388C();
char __fastcall sub_1400438D4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7);
unsigned __int64 sub_140043A18();
__int64 __fastcall sub_140043ADC(unsigned int a1, unsigned int a2, unsigned int a3, int *a4, __int64 a5, int a6);
void __fastcall sub_140043E38(__int64 a1);
__int64 __fastcall sub_1400443D0(__int64 a1);
__int64 __fastcall sub_14004440C(__int64 a1);
__int64 __fastcall sub_140044444(__int64 a1);
__int64 __fastcall sub_14004447C(__int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_1400444D0(__int64 a1, __int64 a2, unsigned int a3);
__int64 (__fastcall *__fastcall sub_140044524(__int64 a1, __int64 a2))(__int64, __int64);
__int64 __fastcall sub_140044564(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1400445D4(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 (__fastcall *__fastcall sub_14004463C(__int64 a1))(__int64);
char __fastcall sub_140044F80(__int64 a1, __int64 a2, unsigned int *a3);
char __fastcall sub_140044FB4(__int64 a1, void *a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140044FF4(); // weak
char __fastcall sub_140045050(__int64 a1, unsigned int a2);
char __fastcall sub_1400451F0(__int64 a1, _DWORD *a2, _QWORD *a3);
__int64 __fastcall sub_140045418(_QWORD, _QWORD); // weak
char __fastcall sub_1400454C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6, __int64 a7);
void sub_140045970();
void __fastcall sub_140045C14(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object);
void sub_140045C48();
void sub_140045DCC();
__int64 __fastcall sub_140045FCC(__int64 a1);
char __fastcall sub_140046028(_QWORD *a1, __int64 a2);
char __fastcall sub_1400460D8(char a1, char **a2, int *a3, unsigned int *a4);
void __fastcall sub_140046248(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
char __fastcall sub_140046390(_BYTE *a1);
__int64 __fastcall sub_140046480(__int64 a1);
char __fastcall sub_1400465DC(__int64 a1, void *a2, unsigned int *a3, __int64 a4, __int64 a5, PVOID P);
NTSTATUS __fastcall sub_1400468A0(unsigned int a1, struct _DEVICE_OBJECT *a2, __int64 a3, unsigned int a4);
char __fastcall sub_14004771C(__int64 a1);
__int64 __fastcall sub_140047850(__int64 a1, __int64 a2);
void sub_1400479D0();
__int64 sub_140048808();
__int64 sub_14004882C();
__int64 __fastcall sub_140048850(__int64 a1);
__int64 __fastcall sub_14004888C(__int64 a1);
__int64 __fastcall sub_1400488C4(__int64 a1);
__int64 __fastcall sub_1400488FC(__int64 a1, __int64 a2);
__int64 __fastcall sub_140048944(__int64 a1);
__int64 (__fastcall *__fastcall sub_14004897C(__int64 a1))(__int64);
__int64 __fastcall sub_1400489AC(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400489F4(__int64 a1);
__int64 __fastcall sub_140048A2C(__int64 a1);
__int64 __fastcall sub_140048A64(__int64 a1);
__int64 __fastcall sub_140048A9C(__int64 a1);
void sub_140049EEC();
void __fastcall sub_140049F48(__int64 a1, char a2);
bool __fastcall sub_14004AF64(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
// __int64 __usercall sub_14004B014@<rax>(_DWORD *a1@<rdx>, __int64 a2@<rcx>, int a3@<ebx>, __int16 a4@<r8w>, unsigned int a5@<r9d>);
__int64 __fastcall sub_14004B770(__int64 a1, __int64 **a2);
__int64 __fastcall sub_14004CB24(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14004CC04(__int64 a1);
char __fastcall sub_14004CD14(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, __int64 a7);
void __fastcall sub_14004D158(_QWORD *a1);
__int64 __fastcall sub_14004D3F4(__int64 a1, __int64 a2);
__int64 __fastcall sub_14004D7B0(__int64 a1);
void __fastcall sub_14004DA3C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object);
void **__fastcall sub_14004DACC(__int64 a1);
char __fastcall sub_14004EAEC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5);
void sub_14004EC50();
__int64 __fastcall sub_14004F004(__int64 a1);
__int64 __fastcall sub_14004FA88(__int64 a1);
__int64 sub_140050F30();
__int64 __fastcall sub_140051030(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140051084(unsigned __int64 a1);
void *__fastcall sub_1400510B4(__int64 a1, __int64 a2);
__int64 __fastcall sub_140051108(unsigned __int64 a1, unsigned int a2);
void __fastcall sub_140051220(__int64 a1);
char sub_1400521EC();
ULONG64 __fastcall sub_14005221C(ULONG64 a1, __int64 a2, int a3);
char __fastcall sub_140052288(unsigned __int64 a1, __int64 a2);
__int64 __fastcall sub_1400522E4(__int64 a1, unsigned __int64 a2);
char __fastcall sub_1400523E4(__int64 a1);
char __fastcall sub_14005240C(__int64 a1, unsigned __int64 a2, __int64 *a3, __int64 *a4);
_DWORD *__fastcall sub_140052460(unsigned __int64 a1, __int64 a2);
_DWORD *__fastcall sub_1400524BC(unsigned __int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400524F0(unsigned __int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140052544(__int64 a1);
__int64 __fastcall sub_140052648(__int64 a1);
__int64 __fastcall sub_140052728(__int64 a1);
unsigned int *__fastcall sub_14005275C(__int64 a1);
_QWORD *__fastcall sub_1400527FC(__int64 a1);
__int64 __fastcall sub_140052894(ULONG64 a1);
__int64 __fastcall sub_1400528EC(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5);
ULONG64 __fastcall sub_140052944(ULONG64 a1);
ULONG64 __fastcall sub_1400529A0(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400529D4(ULONG64 a1, __int64 a2);
unsigned __int64 __fastcall sub_140052B44(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5);
char __fastcall sub_140052BF8(__int64 a1, unsigned __int64 a2, void *a3, unsigned int *a4);
unsigned __int64 __fastcall sub_14005316C(__int64 a1, unsigned __int16 *a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9);
char *__fastcall sub_1400533D4(unsigned __int64 a1, unsigned __int64 a2, _BYTE *a3, __int64 a4, _DWORD *a5, __int64 a6, __int64 a7, _DWORD *a8);
char __fastcall sub_140053568(ULONG64 a1, __int64 a2);
__int64 __fastcall sub_140053698(__int64 a1);
char __fastcall sub_1400536EC(ULONG64 a1);
char __fastcall sub_140053740(ULONG64 a1, __int64 a2);
char __fastcall sub_140053848(__int64 a1, unsigned int a2, __int64 a3);
void sub_140053978();
__int64 __fastcall sub_140053BB4(ULONG64 a1);
__int64 __fastcall sub_140053C40(unsigned __int64 a1, unsigned int a2);
__int64 __fastcall sub_140053DD0(ULONG64 a1);
__int64 __fastcall sub_140053E18(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140053F00(ULONG64 a1);
bool __fastcall sub_140053F48(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
__int16 *sub_140053F78();
void sub_1400541D0();
char __fastcall sub_1400548A8(__int64 a1, __int64 a2);
bool __fastcall sub_1400549F8(__int64 a1, int a2, int a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, int a11, __int64 a12);
__int64 __fastcall sub_140054A84(); // weak
__int64 __fastcall sub_140054B4C(__int64 a1, int a2, int a3, _BYTE *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int a9, int a10);
__int64 __fastcall sub_140054BAC(__int64 a1, int a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140054C98(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5);
void sub_140055068();
void sub_1400551EC();
char __fastcall sub_140055DB4(unsigned __int64 a1, unsigned __int64 a2, __int64 a3);
__int64 __fastcall sub_140055ECC(__int64 a1, int a2, unsigned __int64 a3, int a4);
__int64 __fastcall sub_1400562C4(_WORD *a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8);
char sub_140056D30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...);
__int64 __fastcall sub_1400574EC(_QWORD *a1, _QWORD *a2);
__int64 __fastcall sub_1400575DC(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int a9);
__int64 __fastcall sub_1400579F8(__int64 a1, int a2, unsigned __int64 a3, unsigned int a4);
__int64 sub_140059014();
__int64 __fastcall sub_140059080(PEPROCESS a1);
char __fastcall sub_1400590E8(__int64 a1);
char __fastcall sub_140059160(__int64 a1);
char __fastcall sub_1400591E8(unsigned __int16 *a1, __int64 a2);
char __fastcall sub_1400592B8(HANDLE FileHandle, __int64 *a2, ULONG *a3);
char __fastcall sub_1400593BC(__int64 a1, _QWORD *a2, _DWORD *a3);
char __fastcall sub_1400594F4(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4);
char __fastcall sub_140059578(__int64 a1, __int64 a2, __int64 a3);
char __fastcall sub_1400596B8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned int a7, __int64 a8);
LONG_PTR sub_1400599C8();
void sub_14005BC14();
__int64 sub_14005BDBC();
__int64 sub_14005BDE4();
void __fastcall sub_14005CF68(__int64 a1);
bool __fastcall sub_14005D1A0(__int64 a1, __int64 a2, unsigned int *a3);
void sub_14005D2B8();
__int64 __fastcall sub_14005D5B8(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_14005D720(__int64 a1);
__int64 __fastcall sub_14005D804(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5);
__int64 __fastcall sub_14005D8D0(__int64 a1);
__int64 __fastcall sub_14005D9E8(__int64 a1);
__int64 __fastcall sub_14005DB58(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7);
void __fastcall sub_14005DC24(__int64 a1);
__int64 __fastcall sub_14005DD60(__int64 a1, __int64 a2, unsigned __int64 a3);
char __fastcall sub_14005E728(__int64 a1, __int64 a2, _DWORD *a3, _DWORD *a4);
__int64 __fastcall sub_14005E86C(); // weak
char __fastcall sub_14005EF44(__int64 a1, _QWORD *a2);
char __fastcall sub_14005F240(__int64 a1);
void __fastcall sub_14005F3A0(PCUNICODE_STRING String2);
void sub_14005F4A8();
char __fastcall sub_14005F9CC(unsigned __int64 a1, __int64 a2, unsigned __int8 *a3);
void sub_14005FAF8();
__int64 __fastcall sub_140061030(__int64 a1);
__int64 __fastcall sub_140061108(__int64 a1, unsigned int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400611F8(__int64 a1);
__int64 __fastcall sub_1400612D4(unsigned __int64 a1);
__int64 __fastcall sub_140061370(__int64 a1, __int64 a2);
__int64 __fastcall sub_140061430(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400614EC(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_1400615A4(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140061650(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1400616FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_1400617C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140061870(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140061928(__int64 a1, __int64 a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_1400619E8(__int64 a1, unsigned int a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140061AA4(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140061B64(unsigned int a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_140061C1C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4);
__int64 __fastcall sub_140061CE8(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4);
__int64 __fastcall sub_140061DA4(__int64 a1, unsigned int a2);
__int64 __fastcall sub_140061E5C(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140061F14(__int64 a1, __int64 a2, __int64 a3, __int64 a4);
__int64 __fastcall sub_140061FD4(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_140062084(__int64 a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14006215C(__int64 a1, __int64 a2);
__int64 __fastcall sub_1400621F4(__int64 a1);
char __fastcall sub_1400624B4(__int64 a1, _DWORD *a2);
void __fastcall sub_14006281C(__int64 a1);
__int64 *sub_140062920();
__int64 *__fastcall sub_140062BF4(__int64 a1);
__int64 *__fastcall sub_140062C84(__int64 a1);
__int64 *__fastcall sub_140062C9C(__int64 a1);
void __fastcall sub_140062D30(__int64 a1);
void sub_140062DC8();
void __fastcall sub_140062E54(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, __int64 a11);
void sub_140062E9C();
void sub_1400630C8();
__int64 __fastcall sub_14006320C(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, _DWORD *a9);
char __fastcall sub_140064F8C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object, __int64 a6);
__int64 sub_140065008();
__int64 sub_1400650C0();
__int64 sub_14006512C();
__int64 sub_140065198();
__int64 sub_140065320();
__int64 sub_1400653D4();
__int64 sub_140065488();
__int64 sub_14006553C(void); // weak
__int64 sub_140065644();
__int64 sub_140065738();
char __fastcall sub_140065814(__int64 a1);
__int64 __fastcall sub_140065848(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_1400658E0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, PVOID Object, __int64 a6, unsigned __int64 a7);
__int64 __fastcall sub_140065A68(__int64 a1);
__int64 __fastcall sub_140065A90(__int64 a1);
char __fastcall sub_140065AB8(__int64 a1, char a2);
void __fastcall sub_140065AF0(__int64 a1, __int64 a2);
__int64 __fastcall sub_140065BA8(PETHREAD Thread, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
void **__fastcall sub_1400672C0(ULONG64 a1);
void **__fastcall sub_1400674E4(ULONG64 a1);
__int64 __fastcall sub_1400674EC(); // weak
char __fastcall sub_140067520(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, PVOID Object);
char __fastcall sub_1400685D4(PETHREAD Thread, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, __int64 a6, __int64 a7, __int64 a8);
__int64 sub_140069460();
__int64 sub_140069584();
char sub_140069674();
char __fastcall sub_140069C08(__int64 a1);
unsigned __int64 __fastcall sub_140069C74(unsigned __int64 a1, __int64 a2, unsigned int a3);
__int64 __fastcall sub_140069DC8(__int64 a1, char a2);
__int64 __fastcall sub_14006A7E4(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6);
__int64 **__fastcall sub_14006A9EC(__int64 **a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7);
__int64 __fastcall sub_14006AD08(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6);
__int64 __fastcall sub_14006AE0C(__int64 *a1, __int64 *a2, __int64 *a3);
__int64 __fastcall sub_14006B2D8(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4);
__int64 __fastcall sub_14006B3B0(__int64 a1, int a2, _DWORD *a3);
__int64 __fastcall sub_14006B3F4(__int64 a1, int *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7);
__int64 __fastcall sub_14006B4A4(unsigned int a1, unsigned __int8 a2);
__int64 __fastcall sub_14006B4DC(int a1, int a2);
__int16 __fastcall sub_14006B588(int a1, int a2);
__int64 __fastcall sub_14006B864(int **a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_14006BBB0(__int64 a1, __int64 a2);
__int64 __fastcall sub_14006BDD4(__int64 a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_14006BF98(int **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int8 a7, unsigned __int8 a8);
__int64 __fastcall sub_14006C7A8(_BYTE *a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_14006C8F4(_DWORD **a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14006CB7C(__int64 a1, __int64 a2, unsigned int a3, unsigned __int8 a4);
__int64 __fastcall sub_14006CBCC(unsigned __int8 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int8 *a6);
__int64 __fastcall sub_14006D2DC(); // weak
__int64 __fastcall sub_14006D514(_BYTE *a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_14006D64C(_BYTE *a1, __int64 a2, __int64 a3);
__int64 __fastcall sub_14006D73C(_DWORD *a1, __int64 a2, __int64 a3, _BYTE *a4);
__int64 __fastcall sub_14006D844(__int64 a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_14006D87C(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4);
__int64 __fastcall sub_14006D8EC(__int64 a1, __int64 a2, _WORD *a3, __int64 a4, __int64 a5, unsigned __int8 a6);
__int64 __fastcall sub_14006D958(__int64 a1, __int64 a2, _WORD *a3, __int64 a4, __int64 a5, int a6);
__int64 __fastcall sub_14006DC70(__int64 a1, __int64 a2, char a3, __int64 a4, __int64 a5, __int64 a6, int a7);
__int64 __fastcall sub_14006DD10(__int64 a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int a9, char a10);
unsigned __int64 __fastcall sub_14006DE10(__int64 a1, __int64 a2, unsigned __int8 *a3);
char __fastcall sub_14006E4A8(_BYTE *a1, __int64 a2, _BYTE *a3);
__int64 __fastcall sub_14006E81C(unsigned int **a1, __int64 a2, __int64 a3, __int64 a4);
char *__fastcall sub_14006EABC(unsigned __int8 *a1, unsigned __int16 a2);
bool __fastcall sub_14006EDE4(__int64 a1, _QWORD *a2);
__int64 __fastcall sub_14006EE04(int a1, _DWORD *a2, _WORD *a3);
char *__fastcall sub_14006EE20(int a1, unsigned __int16 a2, _QWORD *a3);
char __fastcall sub_14006EE94(__int64 a1, _QWORD *a2);
// EXCEPTION_DISPOSITION __cdecl _C_specific_handler(struct _EXCEPTION_RECORD *ExceptionRecord, void *EstablisherFrame, struct _CONTEXT *ContextRecord, struct _DISPATCHER_CONTEXT *DispatcherContext);
__int64 __fastcall sub_14006EEE0(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3);
void guard_check_icall_nop();
// __int64 __usercall guard_dispatch_icall_nop@<rax>(__int64 (*a1)(void)@<rax>);
char __fastcall sub_1400E0000(__int64 a1, __int64 a2, _DWORD *a3);
void __fastcall sub_1400E0904(__int64 a1, __int64 a2, unsigned int *a3);
// void __cdecl _security_init_cookie();

//-------------------------------------------------------------------------
// Data declarations

_UNKNOWN loc_1400061CC; // weak
__int64 qword_1400068A0[47] =
{
  227362897i64,
  5188319312112353608i64,
  7277794290609441929i64,
  -734898729715627996i64,
  -691623888162643578i64,
  -1957435317i64,
  -823075536884538160i64,
  -130483417379857107i64,
  -674239930735680091i64,
  -800005145849307622i64,
  7622284857696606263i64,
  -339859166387346497i64,
  -1124971519517692900i64,
  -3348060316875405210i64,
  7406505264724149064i64,
  5536763755409313608i64,
  3552498938852986377i64,
  9083558580399982841i64,
  5607545919651793390i64,
  1144334384433125257i64,
  -8986112820743519355i64,
  92587165329588391i64,
  -4070330452210923033i64,
  2599812045914982520i64,
  5190564080485502280i64,
  -8554069616710335357i64,
  -8554349408044974142i64,
  5253485562098698462i64,
  5248955573918099155i64,
  5544286349185579907i64,
  -1690738898528308855i64,
  -8554325218788630200i64,
  -130242900334261053i64,
  4438895120188422728i64,
  -8554584328891723014i64,
  3598045461753711816i64,
  4832160369076292041i64,
  5251066636542232817i64,
  -7456536060797337207i64,
  44108046745468927i64,
  -1897731995546028983i64,
  7896495025593632795i64,
  -1279762160171720928i64,
  8003489370810961489i64,
  4897131494426418572i64,
  -5426913527089319184i64,
  -3678493625479074095i64
}; // weak
_UNKNOWN loc_140007050; // weak
_UNKNOWN loc_14000A544; // weak
_UNKNOWN loc_14000C638; // weak
_UNKNOWN loc_14000C954; // weak
_UNKNOWN loc_14000E260; // weak
_UNKNOWN loc_14000E728; // weak
_UNKNOWN loc_14000F7F8; // weak
_UNKNOWN loc_1400103E4; // weak
_UNKNOWN loc_1400127F4; // weak
__int64 qword_1400128D8[22] =
{
  227362897i64,
  5188319695522070856i64,
  7277794290609441929i64,
  -3667606891699894236i64,
  -5328420627190634176i64,
  3688751430016649724i64,
  -3011771576588777179i64,
  -4818901495292457669i64,
  -9149881954342753227i64,
  4853964919524542143i64,
  -2962248499559563763i64,
  1098141606289082457i64,
  3538770565367391226i64,
  8796632914248248090i64,
  -3456121079218433770i64,
  -8194337947358859920i64,
  8155333542168982636i64,
  -6449539957814816953i64,
  -840728728302302189i64,
  988032474191722283i64,
  -524018208851997359i64,
  -6959835848509861531i64
}; // weak
int dword_1400129CC = 227362897; // weak
_UNKNOWN loc_140012CDC; // weak
_UNKNOWN loc_140014D18; // weak
_UNKNOWN loc_140015528; // weak
_UNKNOWN loc_14001561C; // weak
_UNKNOWN loc_140015908; // weak
_UNKNOWN loc_140015A08; // weak
int dword_14001F534 = 227362897; // weak
_UNKNOWN loc_14001FCD0; // weak
_UNKNOWN loc_140027B08; // weak
_UNKNOWN loc_14002B5B0; // weak
_UNKNOWN loc_14002CCB0; // weak
_UNKNOWN loc_14002D32C; // weak
int dword_140030644 = 138447681; // weak
int dword_140036C0C = 868243215; // weak
_UNKNOWN loc_140036CA4; // weak
_UNKNOWN loc_140036D28; // weak
__int64 qword_140037020[4] =
{
  148917580856317711i64,
  3694446614395467841i64,
  2324571060597493705i64,
  6091479170801240392i64
}; // weak
int dword_140037074 = 868243215; // weak
int dword_14003710C = 868243215; // weak
_UNKNOWN loc_140037164; // weak
_UNKNOWN loc_140037FB0; // weak
_UNKNOWN loc_1400404E8; // weak
_UNKNOWN loc_140043754; // weak
_UNKNOWN loc_140043F0C; // weak
_UNKNOWN loc_14004466C; // weak
_UNKNOWN loc_1400447C0; // weak
_UNKNOWN loc_1400455A0; // weak
_UNKNOWN loc_140047C28; // weak
_UNKNOWN loc_14004D360; // weak
_UNKNOWN loc_14004D9E4; // weak
_UNKNOWN loc_14004EC1C; // weak
_UNKNOWN loc_140052148; // weak
_UNKNOWN loc_140056E38; // weak
_UNKNOWN loc_14005CFA8; // weak
_UNKNOWN loc_14005D4D0; // weak
_UNKNOWN loc_14005E218; // weak
_UNKNOWN loc_14005FFEC; // weak
_UNKNOWN loc_140067764; // weak
_UNKNOWN loc_140069850; // weak
_UNKNOWN loc_140069B20; // weak
_UNKNOWN loc_14006B180; // weak
_UNKNOWN loc_14006B1F0; // weak
_UNKNOWN loc_14006B654; // weak
_UNKNOWN loc_14006F000; // weak
_UNKNOWN loc_14006F2C0; // weak
__int64 qword_14006F930[10] =
{
  -3689348814741962706i64,
  -3689348814741910324i64,
  -3689348814741962657i64,
  -3689348814741910324i64,
  26740346129350751i64,
  -3689348814741962752i64,
  -3689348814741962689i64,
  -3689348814741910324i64,
  -3689348818177884114i64,
  -3689348814741910324i64
}; // weak
char byte_14006F980[4] = { '\\', '\0', '\0', '\0' }; // weak
// extern NTSTATUS (__stdcall *FltGetFileNameInformationUnsafe)(PFILE_OBJECT FileObject, PFLT_INSTANCE Instance, FLT_FILE_NAME_OPTIONS NameOptions, PFLT_FILE_NAME_INFORMATION *FileNameInformation);
// extern void (__stdcall *FltReleaseFileNameInformation)(PFLT_FILE_NAME_INFORMATION FileNameInformation);
// extern void (__stdcall *FltUnregisterFilter)(PFLT_FILTER Filter);
// extern LONG_PTR (__stdcall *ObfDereferenceObject)(PVOID Object);
// extern void (__stdcall *ExAcquireFastMutex)(PFAST_MUTEX FastMutex);
// extern void (__stdcall *ExReleaseFastMutex)(PFAST_MUTEX FastMutex);
// extern LONG_PTR (__stdcall *ObfReferenceObject)(PVOID Object);
// extern ULONG (*KeQueryTimeIncrement)(void);
// extern LONG (__stdcall *KeSetEvent)(PRKEVENT Event, KPRIORITY Increment, BOOLEAN Wait);
// extern LONG (__stdcall *RtlCompareString)(const STRING *String1, const STRING *String2, BOOLEAN CaseInSensitive);
// extern LONG (__stdcall *RtlCompareUnicodeString)(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
// extern NTSTATUS (__stdcall *RtlMultiByteToUnicodeN)(PWCH UnicodeString, ULONG MaxBytesInUnicodeString, PULONG BytesInUnicodeString, const CHAR *MultiByteString, ULONG BytesInMultiByteString);
// extern void (__stdcall *RtlInitUnicodeString)(PUNICODE_STRING DestinationString, PCWSTR SourceString);
// extern NTSTATUS (__stdcall *ZwClose)(HANDLE Handle);
// extern NTSTATUS (__stdcall *RtlWriteRegistryValue)(ULONG RelativeTo, PCWSTR Path, PCWSTR ValueName, ULONG ValueType, PVOID ValueData, ULONG ValueLength);
// extern NTSTATUS (__stdcall *RtlDeleteRegistryValue)(ULONG RelativeTo, PCWSTR Path, PCWSTR ValueName);
// extern LONGLONG (__stdcall *PsGetProcessCreateTimeQuadPart)(PEPROCESS Process);
// extern PEPROCESS (*IoGetCurrentProcess)(void);
// extern PVOID (__stdcall *ExAllocatePoolWithTag)(POOL_TYPE PoolType, SIZE_T NumberOfBytes, ULONG Tag);
// extern BOOLEAN (*KeAreApcsDisabled)(void);
// extern NTSTATUS (__stdcall *ZwQuerySystemInformation)(SYSTEM_INFORMATION_CLASS SystemInformationClass, PVOID SystemInformation, ULONG SystemInformationLength, PULONG ReturnLength);
// extern void (__stdcall *ExFreePoolWithTag)(PVOID P, ULONG Tag);
// extern const PVOID MmSystemRangeStart;
// extern NTSTATUS (__stdcall *KeDelayExecutionThread)(KPROCESSOR_MODE WaitMode, BOOLEAN Alertable, PLARGE_INTEGER Interval);
// extern NTSTATUS (__stdcall *ZwQueryInformationFile)(HANDLE FileHandle, PIO_STATUS_BLOCK IoStatusBlock, PVOID FileInformation, ULONG Length, FILE_INFORMATION_CLASS FileInformationClass);
// extern NTSTATUS (__stdcall *IoQueryFileDosDeviceName)(PFILE_OBJECT FileObject, POBJECT_NAME_INFORMATION *ObjectNameInformation);
// extern PIRP (*IoGetTopLevelIrp)(void);
// extern const PVOID MmHighestUserAddress;
// extern PEPROCESS PsInitialSystemProcess;
// extern HANDLE (*PsGetCurrentThreadId)(void);
// extern NTSTATUS (__stdcall *ObCloseHandle)(HANDLE Handle, KPROCESSOR_MODE PreviousMode);
// extern void (__stdcall *KeInitializeEvent)(PRKEVENT Event, EVENT_TYPE Type, BOOLEAN State);
// extern NTSTATUS (__stdcall *ZwQueryValueKey)(HANDLE KeyHandle, PUNICODE_STRING ValueName, KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass, PVOID KeyValueInformation, ULONG Length, PULONG ResultLength);
// extern void (__stdcall *ProbeForRead)(volatile void *Address, SIZE_T Length, ULONG Alignment);
// extern NTSTATUS (__stdcall *ObReferenceObjectByHandle)(HANDLE Handle, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PVOID *Object, POBJECT_HANDLE_INFORMATION HandleInformation);
// extern POBJECT_TYPE *ExEventObjectType;
// extern NTSTATUS (__stdcall *ObOpenObjectByPointer)(PVOID Object, ULONG HandleAttributes, PACCESS_STATE PassedAccessState, ACCESS_MASK DesiredAccess, POBJECT_TYPE ObjectType, KPROCESSOR_MODE AccessMode, PHANDLE Handle);
// extern KPROCESSOR_MODE (*ExGetPreviousMode)(void);
// extern void (*KeEnterCriticalRegion)(void);
// extern void (__stdcall *ExAcquireFastMutexUnsafe)(PFAST_MUTEX FastMutex);
// extern void (__stdcall *ExReleaseFastMutexUnsafe)(PFAST_MUTEX FastMutex);
// extern void (*KeLeaveCriticalRegion)(void);
// extern int (__cdecl *tolower)(int C);
// extern NTSTATUS (__stdcall *RtlGetVersion)(PRTL_OSVERSIONINFOW lpVersionInformation);
// extern NTSTATUS (__stdcall *IofCallDriver)(PDEVICE_OBJECT DeviceObject, PIRP Irp);
// extern void (__noreturn *ExRaiseDatatypeMisalignment)(void);
// extern const ULONG64 MmUserProbeAddress;
// extern void (__noreturn *ExRaiseAccessViolation)(void);
// extern NTSTATUS (__stdcall *ZwReadFile)(HANDLE FileHandle, HANDLE Event, PIO_APC_ROUTINE ApcRoutine, PVOID ApcContext, PIO_STATUS_BLOCK IoStatusBlock, PVOID Buffer, ULONG Length, PLARGE_INTEGER ByteOffset, PULONG Key);
// extern BOOLEAN (__stdcall *RtlEqualUnicodeString)(PCUNICODE_STRING String1, PCUNICODE_STRING String2, BOOLEAN CaseInSensitive);
// extern void (__stdcall *KeAcquireSpinLockAtDpcLevel)(PKSPIN_LOCK SpinLock);
// extern void (__stdcall *KeReleaseSpinLockFromDpcLevel)(PKSPIN_LOCK SpinLock);
// extern BOOLEAN (__stdcall *PsIsThreadTerminating)(PETHREAD Thread);
// extern PHYSICAL_ADDRESS (__stdcall *MmGetPhysicalAddress)(PVOID BaseAddress);
int dword_1400703B0[] = { 0 }; // weak
char byte_1400703B4[] = { '\0' }; // weak
_UNKNOWN unk_1400703B8; // weak
_BYTE byte_1400704E0[24] = { 0, 1, 2, 3, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0 }; // idb
int dword_140070508[8] = { 24, 24, 26, 26, 27, 28, 26, 24 }; // idb
int dword_140070528[8] = { 27, 28, 27, 28, 0, 0, 0, 0 }; // idb
_UNKNOWN dword_140070548; // weak
_UNKNOWN dword_140070558; // weak
__int64 qword_140070568[4] = { 0i64, 137438953472i64, 274877906944i64, 412316860416i64 }; // idb
__int64 qword_140070588[4] = { 0i64, 549755813888i64, 1099511627776i64, 1649267441664i64 }; // idb
__int64 qword_1400705A8[4] = { 0i64, 2199023255552i64, 4398046511104i64, 6597069766656i64 }; // idb
__int16 word_1400705C8[2] = { 128, 256 }; // idb
__int16 word_1400705CC[306] =
{
  128,
  256,
  128,
  256,
  512,
  0,
  2048,
  8208,
  -32704,
  0,
  8208,
  4160,
  16416,
  1028,
  2052,
  2056,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  2,
  0,
  3,
  0,
  4,
  0,
  1,
  0,
  2,
  0,
  3,
  0,
  4104,
  1056,
  1028,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  2,
  0,
  3,
  0,
  8208,
  64,
  256,
  1026,
  4104,
  0,
  4104,
  32,
  2052,
  16,
  1026,
  8,
  8200,
  64,
  0,
  0,
  0,
  0,
  1,
  0,
  2,
  0,
  3,
  0,
  4,
  0,
  5,
  0,
  6,
  0,
  7,
  0,
  8,
  0,
  9,
  0,
  10,
  0,
  11,
  0,
  12,
  0,
  0,
  0,
  1088,
  8208,
  4112,
  8224,
  4,
  512,
  257,
  514,
  16,
  2048,
  1028,
  2056,
  1088,
  16,
  4112,
  8224,
  4,
  0,
  257,
  514,
  16,
  0,
  1028,
  2056,
  2112,
  2080,
  0,
  32,
  0,
  0,
  0,
  0,
  64,
  8192,
  4112,
  8224,
  4,
  512,
  257,
  514,
  2112,
  0,
  0,
  0,
  8208,
  4128,
  4128,
  16448,
  8208,
  4128,
  4128,
  16448,
  4112,
  8224,
  8224,
  16448,
  8208,
  4128,
  4128,
  8224,
  8208,
  4128,
  4160,
  16448,
  8208,
  4128,
  16448,
  16448,
  8224,
  8224,
  8224,
  16448,
  8224,
  8224,
  16448,
  16448,
  8208,
  4128,
  8256,
  0,
  4112,
  8224,
  16448,
  0,
  8224,
  8224,
  16448,
  0,
  0,
  0,
  0,
  0,
  257,
  257,
  257,
  257,
  1,
  0,
  0,
  0,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  257,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  257,
  1,
  0,
  0,
  257,
  1,
  257,
  257,
  257,
  1,
  0,
  0,
  1,
  1,
  0,
  0,
  257,
  1,
  0,
  0,
  1,
  256,
  257,
  257,
  1,
  0,
  0,
  0,
  1,
  0,
  257,
  257,
  1,
  0,
  0,
  0,
  1,
  256,
  257,
  257,
  1,
  0,
  0,
  0,
  1,
  0,
  257,
  257,
  1,
  0,
  0,
  0,
  1,
  257,
  1,
  0,
  1,
  0,
  0,
  0
}; // idb
_BYTE byte_140070698[408] =
{
  64,
  4,
  16,
  32,
  16,
  16,
  32,
  32,
  4,
  0,
  0,
  2,
  1,
  1,
  2,
  2,
  16,
  0,
  0,
  8,
  4,
  4,
  8,
  8,
  64,
  4,
  16,
  0,
  16,
  16,
  32,
  32,
  4,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  16,
  0,
  0,
  0,
  4,
  4,
  8,
  8,
  64,
  8,
  32,
  8,
  0,
  0,
  32,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  64,
  0,
  0,
  32,
  16,
  16,
  32,
  32,
  4,
  0,
  0,
  2,
  1,
  1,
  2,
  2,
  64,
  8,
  0,
  0,
  0,
  0,
  0,
  0,
  16,
  32,
  32,
  16,
  32,
  16,
  64,
  64,
  16,
  32,
  32,
  16,
  32,
  16,
  64,
  64,
  16,
  16,
  32,
  32,
  32,
  32,
  64,
  64,
  16,
  32,
  32,
  16,
  32,
  16,
  32,
  32,
  16,
  32,
  32,
  16,
  64,
  16,
  64,
  64,
  16,
  32,
  32,
  16,
  64,
  64,
  64,
  64,
  32,
  32,
  32,
  32,
  32,
  32,
  64,
  64,
  32,
  32,
  32,
  32,
  64,
  64,
  64,
  64,
  16,
  32,
  32,
  16,
  64,
  32,
  0,
  0,
  16,
  16,
  32,
  32,
  64,
  64,
  0,
  0,
  32,
  32,
  32,
  32,
  64,
  64,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  0,
  1,
  1,
  1,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
_BYTE byte_140070830[4] = { 16, 32, 64, 0 }; // idb
_UNKNOWN unk_140070834; // weak
_UNKNOWN unk_140070958; // weak
_UNKNOWN unk_140070980; // weak
_UNKNOWN unk_1400709F0; // weak
_UNKNOWN unk_140070A60; // weak
_UNKNOWN unk_140077660; // weak
_UNKNOWN unk_140077670; // weak
_UNKNOWN unk_140077CE8; // weak
_UNKNOWN unk_140077D00; // weak
_UNKNOWN unk_140077D10; // weak
_UNKNOWN unk_14007A5F0; // weak
_UNKNOWN unk_14007B100; // weak
_UNKNOWN unk_14007B760; // weak
_UNKNOWN unk_14007D0B0; // weak
_UNKNOWN unk_14007D230; // weak
_UNKNOWN unk_14007D450; // weak
_UNKNOWN unk_1400806C0; // weak
_UNKNOWN unk_1400829D8; // weak
_UNKNOWN unk_1400829E0; // weak
_UNKNOWN unk_140083FF0; // weak
_UNKNOWN unk_1400842C0; // weak
_UNKNOWN unk_140084330; // weak
_UNKNOWN unk_140084360; // weak
_UNKNOWN unk_140084370; // weak
_UNKNOWN unk_140084388; // weak
_UNKNOWN unk_140084398; // weak
_UNKNOWN unk_1400843A4; // weak
_UNKNOWN unk_1400843AC; // weak
_UNKNOWN unk_1400843C0; // weak
_UNKNOWN unk_14008B410; // weak
_UNKNOWN unk_14008B680; // weak
_UNKNOWN unk_14008C140; // weak
_UNKNOWN unk_140091940; // weak
_UNKNOWN unk_14009E3F0; // weak
_UNKNOWN unk_14009FD60; // weak
_UNKNOWN unk_1400B3E40; // weak
_UNKNOWN unk_1400B55E0; // weak
_DWORD dword_1400B56A0[256] =
{
  0,
  -227835133,
  -516198153,
  324072436,
  -946170081,
  904991772,
  648144872,
  -724933397,
  -1965467441,
  2024987596,
  1809983544,
  -1719030981,
  1296289744,
  -1087877933,
  -1401372889,
  1578318884,
  274646895,
  -499825556,
  -244992104,
  51262619,
  -675000208,
  632279923,
  922689671,
  -996891772,
  -1702387808,
  1760304291,
  2075979607,
  -1982370732,
  1562183871,
  -1351185476,
  -1138329528,
  1313733451,
  549293790,
  -757723683,
  -1048117719,
  871202090,
  -416867903,
  357341890,
  102525238,
  -193467851,
  -1436232175,
  1477399826,
  1264559846,
  -1187764763,
  1845379342,
  -1617575411,
  -1933233671,
  2125378298,
  820201905,
  -1031222606,
  -774358714,
  598981189,
  -143008082,
  85089709,
  373468761,
  -467063462,
  -1170599554,
  1213305469,
  1526817161,
  -1452612982,
  2107672161,
  -1882520222,
  -1667500394,
  1861252501,
  1098587580,
  -1290756417,
  -1606390453,
  1378610760,
  -2032039261,
  1955203488,
  1742404180,
  -1783531177,
  -878557837,
  969524848,
  714683780,
  -655182201,
  205050476,
  -28094097,
  -318528869,
  526918040,
  1361435347,
  -1555146288,
  -1340167644,
  1114974503,
  -1765847604,
  1691668175,
  2005155131,
  -2047885768,
  -604208612,
  697762079,
  986182379,
  -928222744,
  476452099,
  -301099520,
  -44210700,
  255256311,
  1640403810,
  -1817374623,
  -2130844779,
  1922457750,
  -1503918979,
  1412925310,
  1197962378,
  -1257441399,
  -350237779,
  427051182,
  170179418,
  -129025959,
  746937522,
  -554770511,
  -843174843,
  1070968646,
  1905808397,
  -2081171698,
  -1868356358,
  1657317369,
  -1241332974,
  1147748369,
  1463399397,
  -1521340186,
  -79622974,
  153784257,
  444234805,
  -401473738,
  1021025245,
  -827320098,
  -572462294,
  797665321,
  -2097792136,
  1889384571,
  1674398607,
  -1851340660,
  1164749927,
  -1224265884,
  -1537745776,
  1446797203,
  137323447,
  -96149324,
  -384560320,
  461344835,
  -810158936,
  1037989803,
  781091935,
  -588970148,
  -1834419177,
  1623424788,
  1939049696,
  -2114449437,
  1429367560,
  -1487280117,
  -1274471425,
  1180866812,
  410100952,
  -367384613,
  -112536529,
  186734380,
  -538233913,
  763408580,
  1053836080,
  -860110797,
  -1572096602,
  1344288421,
  1131464017,
  -1323612590,
  1708204729,
  -1749376582,
  -2065018290,
  1988219213,
  680717673,
  -621187478,
  -911630946,
  1002577565,
  -284657034,
  493091189,
  238226049,
  -61306494,
  -1307217207,
  1082061258,
  1395524158,
  -1589280451,
  1972364758,
  -2015074603,
  -1800104671,
  1725896226,
  952904198,
  -894981883,
  -638100751,
  731699698,
  -11092711,
  222117402,
  510512622,
  -335130899,
  -1014159676,
  837199303,
  582374963,
  -790768336,
  68661723,
  -159632680,
  -450051796,
  390545967,
  1230274059,
  -1153434360,
  -1469116676,
  1510247935,
  -1899042540,
  2091215383,
  1878366691,
  -1650582816,
  -741088853,
  565732008,
  854102364,
  -1065151905,
  340358836,
  -433916489,
  -177076669,
  119113024,
  1493875044,
  -1419691417,
  -1204696685,
  1247431312,
  -1634718085,
  1828433272,
  2141937292,
  -1916740209,
  -483350502,
  291187481,
  34330861,
  -262120466,
  615137029,
  -691946490,
  -980332558,
  939183345,
  1776939221,
  -1685949482,
  -1999470558,
  2058945313,
  -1368168502,
  1545135305,
  1330124605,
  -1121741762,
  -210866315,
  17165430,
  307568514,
  -532767615,
  888469610,
  -962626711,
  -707819363,
  665062302,
  2042050490,
  -1948470087,
  -1735637171,
  1793573966,
  -1104306011,
  1279665062,
  1595330642,
  -1384295599
}; // idb
_UNKNOWN unk_1400B5AE0; // weak
wchar_t *off_1400BC4B0[256] =
{
  L"00",
  L"01",
  L"02",
  L"03",
  L"04",
  L"05",
  L"06",
  L"07",
  L"08",
  L"09",
  L"0A",
  L"0B",
  L"0C",
  L"0D",
  L"0E",
  L"0F",
  L"10",
  L"11",
  L"12",
  L"13",
  L"14",
  L"15",
  L"16",
  L"17",
  L"18",
  L"19",
  L"1A",
  L"1B",
  L"1C",
  L"1D",
  L"1E",
  L"1F",
  L"20",
  L"21",
  L"22",
  L"23",
  L"24",
  L"25",
  L"26",
  L"27",
  L"28",
  L"29",
  L"2A",
  L"2B",
  L"2C",
  L"2D",
  L"2E",
  L"2F",
  L"30",
  L"31",
  L"32",
  L"33",
  L"34",
  L"35",
  L"36",
  L"37",
  L"38",
  L"39",
  L"3A",
  L"3B",
  L"3C",
  L"3D",
  L"3E",
  L"3F",
  L"40",
  L"41",
  L"42",
  L"43",
  L"44",
  L"45",
  L"46",
  L"47",
  L"48",
  L"49",
  L"4A",
  L"4B",
  L"4C",
  L"4D",
  L"4E",
  L"4F",
  L"50",
  L"51",
  L"52",
  L"53",
  L"54",
  L"55",
  L"56",
  L"57",
  L"58",
  L"59",
  L"5A",
  L"5B",
  L"5C",
  L"5D",
  L"5E",
  L"5F",
  L"60",
  L"61",
  L"62",
  L"63",
  L"64",
  L"65",
  L"66",
  L"67",
  L"68",
  L"69",
  L"6A",
  L"6B",
  L"6C",
  L"6D",
  L"6E",
  L"6F",
  L"70",
  L"71",
  L"72",
  L"73",
  L"74",
  L"75",
  L"76",
  L"77",
  L"78",
  L"79",
  L"7A",
  L"7B",
  L"7C",
  L"7D",
  L"7E",
  L"7F",
  L"80",
  L"81",
  L"82",
  L"83",
  L"84",
  L"85",
  L"86",
  L"87",
  L"88",
  L"89",
  L"8A",
  L"8B",
  L"8C",
  L"8D",
  L"8E",
  L"8F",
  L"90",
  L"91",
  L"92",
  L"93",
  L"94",
  L"95",
  L"96",
  L"97",
  L"98",
  L"99",
  L"9A",
  L"9B",
  L"9C",
  L"9D",
  L"9E",
  L"9F",
  L"A0",
  L"A1",
  L"A2",
  L"A3",
  L"A4",
  L"A5",
  L"A6",
  L"A7",
  L"A8",
  L"A9",
  L"AA",
  L"AB",
  L"AC",
  L"AD",
  L"AE",
  L"AF",
  L"B0",
  L"B1",
  L"B2",
  L"B3",
  L"B4",
  L"B5",
  L"B6",
  L"B7",
  L"B8",
  L"B9",
  L"BA",
  L"BB",
  L"BC",
  L"BD",
  L"BE",
  L"BF",
  L"C0",
  L"C1",
  L"C2",
  L"C3",
  L"C4",
  L"C5",
  L"C6",
  L"C7",
  L"C8",
  L"C9",
  L"CA",
  L"CB",
  L"CC",
  L"CD",
  L"CE",
  L"CF",
  L"D0",
  L"D1",
  L"D2",
  L"D3",
  L"D4",
  L"D5",
  L"D6",
  L"D7",
  L"D8",
  L"D9",
  L"DA",
  L"DB",
  L"DC",
  L"DD",
  L"DE",
  L"DF",
  L"E0",
  L"E1",
  L"E2",
  L"E3",
  L"E4",
  L"E5",
  L"E6",
  L"E7",
  L"E8",
  L"E9",
  L"EA",
  L"EB",
  L"EC",
  L"ED",
  L"EE",
  L"EF",
  L"F0",
  L"F1",
  L"F2",
  L"F3",
  L"F4",
  L"F5",
  L"F6",
  L"F7",
  L"F8",
  L"F9",
  L"FA",
  L"FB",
  L"FC",
  L"FD",
  L"FE",
  L"FF"
}; // weak
_BYTE byte_1400BCCB0[256] =
{
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  1,
  1,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0
}; // idb
unsigned __int8 byte_1400BCE40[944] =
{
  237u,
  48u,
  81u,
  117u,
  89u,
  244u,
  246u,
  6u,
  97u,
  137u,
  36u,
  26u,
  194u,
  184u,
  116u,
  50u,
  118u,
  33u,
  209u,
  186u,
  100u,
  236u,
  149u,
  234u,
  240u,
  198u,
  94u,
  138u,
  129u,
  7u,
  75u,
  29u,
  141u,
  78u,
  105u,
  182u,
  203u,
  41u,
  82u,
  197u,
  156u,
  10u,
  167u,
  172u,
  226u,
  227u,
  210u,
  176u,
  19u,
  204u,
  155u,
  96u,
  83u,
  183u,
  251u,
  52u,
  80u,
  31u,
  8u,
  252u,
  243u,
  185u,
  98u,
  24u,
  40u,
  46u,
  216u,
  199u,
  3u,
  219u,
  23u,
  55u,
  169u,
  206u,
  68u,
  66u,
  166u,
  250u,
  195u,
  202u,
  213u,
  57u,
  62u,
  2u,
  115u,
  14u,
  181u,
  145u,
  112u,
  124u,
  107u,
  205u,
  163u,
  113u,
  224u,
  71u,
  127u,
  162u,
  92u,
  136u,
  241u,
  17u,
  228u,
  53u,
  73u,
  177u,
  133u,
  58u,
  114u,
  231u,
  249u,
  67u,
  122u,
  106u,
  143u,
  174u,
  158u,
  86u,
  101u,
  119u,
  168u,
  44u,
  134u,
  200u,
  22u,
  111u,
  157u,
  171u,
  238u,
  39u,
  142u,
  201u,
  179u,
  187u,
  34u,
  72u,
  13u,
  193u,
  207u,
  91u,
  25u,
  245u,
  56u,
  208u,
  255u,
  229u,
  135u,
  65u,
  99u,
  150u,
  225u,
  223u,
  190u,
  160u,
  104u,
  140u,
  38u,
  120u,
  144u,
  173u,
  70u,
  16u,
  88u,
  63u,
  154u,
  12u,
  152u,
  18u,
  49u,
  51u,
  103u,
  45u,
  254u,
  192u,
  247u,
  76u,
  128u,
  217u,
  87u,
  189u,
  85u,
  132u,
  191u,
  165u,
  90u,
  125u,
  211u,
  214u,
  188u,
  64u,
  0u,
  61u,
  15u,
  212u,
  43u,
  27u,
  30u,
  110u,
  84u,
  221u,
  215u,
  77u,
  233u,
  32u,
  220u,
  74u,
  178u,
  35u,
  161u,
  148u,
  59u,
  60u,
  9u,
  126u,
  232u,
  1u,
  130u,
  121u,
  4u,
  109u,
  235u,
  69u,
  230u,
  5u,
  153u,
  28u,
  239u,
  54u,
  196u,
  146u,
  108u,
  102u,
  248u,
  20u,
  175u,
  37u,
  79u,
  147u,
  151u,
  95u,
  253u,
  131u,
  170u,
  93u,
  139u,
  159u,
  218u,
  222u,
  47u,
  11u,
  123u,
  242u,
  42u,
  164u,
  21u,
  180u,
  1u,
  0u,
  0u,
  0u,
  2u,
  0u,
  0u,
  0u,
  3u,
  0u,
  0u,
  0u,
  5u,
  0u,
  0u,
  0u,
  7u,
  0u,
  0u,
  0u,
  11u,
  0u,
  0u,
  0u,
  17u,
  0u,
  0u,
  0u,
  25u,
  0u,
  0u,
  0u,
  38u,
  0u,
  0u,
  0u,
  57u,
  0u,
  0u,
  0u,
  86u,
  0u,
  0u,
  0u,
  129u,
  0u,
  0u,
  0u,
  194u,
  0u,
  0u,
  0u,
  35u,
  1u,
  0u,
  0u,
  181u,
  1u,
  0u,
  0u,
  144u,
  2u,
  0u,
  0u,
  86u,
  3u,
  0u,
  0u,
  86u,
  4u,
  0u,
  0u,
  163u,
  5u,
  0u,
  0u,
  84u,
  7u,
  0u,
  0u,
  135u,
  9u,
  0u,
  0u,
  99u,
  12u,
  0u,
  0u,
  147u,
  13u,
  0u,
  0u,
  239u,
  14u,
  0u,
  0u,
  109u,
  16u,
  0u,
  0u,
  18u,
  18u,
  0u,
  0u,
  224u,
  19u,
  0u,
  0u,
  221u,
  21u,
  0u,
  0u,
  13u,
  24u,
  0u,
  0u,
  116u,
  26u,
  0u,
  0u,
  26u,
  29u,
  0u,
  0u,
  3u,
  32u,
  0u,
  0u,
  54u,
  35u,
  0u,
  0u,
  188u,
  38u,
  0u,
  0u,
  155u,
  42u,
  0u,
  0u,
  222u,
  46u,
  0u,
  0u,
  142u,
  51u,
  0u,
  0u,
  182u,
  56u,
  0u,
  0u,
  98u,
  62u,
  0u,
  0u,
  159u,
  68u,
  0u,
  0u,
  123u,
  75u,
  0u,
  0u,
  8u,
  83u,
  0u,
  0u,
  86u,
  91u,
  0u,
  0u,
  120u,
  100u,
  0u,
  0u,
  132u,
  110u,
  0u,
  0u,
  145u,
  121u,
  0u,
  0u,
  185u,
  133u,
  0u,
  0u,
  24u,
  147u,
  0u,
  0u,
  206u,
  161u,
  0u,
  0u,
  252u,
  177u,
  0u,
  0u,
  201u,
  195u,
  0u,
  0u,
  93u,
  215u,
  0u,
  0u,
  230u,
  236u,
  0u,
  0u,
  151u,
  4u,
  1u,
  0u,
  166u,
  30u,
  1u,
  0u,
  81u,
  59u,
  1u,
  0u,
  217u,
  90u,
  1u,
  0u,
  136u,
  125u,
  1u,
  0u,
  175u,
  163u,
  1u,
  0u,
  167u,
  205u,
  1u,
  0u,
  210u,
  251u,
  1u,
  0u,
  154u,
  46u,
  2u,
  0u,
  118u,
  102u,
  2u,
  0u,
  232u,
  163u,
  2u,
  0u,
  127u,
  231u,
  2u,
  0u,
  217u,
  49u,
  3u,
  0u,
  162u,
  131u,
  3u,
  0u,
  153u,
  221u,
  3u,
  0u,
  142u,
  64u,
  4u,
  0u,
  106u,
  173u,
  4u,
  0u,
  39u,
  37u,
  5u,
  0u,
  223u,
  168u,
  5u,
  0u,
  194u,
  57u,
  6u,
  0u,
  34u,
  217u,
  6u,
  0u,
  114u,
  136u,
  7u,
  0u,
  74u,
  73u,
  8u,
  0u,
  108u,
  29u,
  9u,
  0u,
  195u,
  6u,
  10u,
  0u,
  112u,
  7u,
  11u,
  0u,
  201u,
  33u,
  12u,
  0u,
  93u,
  88u,
  13u,
  0u,
  0u,
  174u,
  14u,
  0u,
  204u,
  37u,
  16u,
  0u,
  46u,
  195u,
  17u,
  0u,
  230u,
  137u,
  19u,
  0u,
  22u,
  126u,
  21u,
  0u,
  76u,
  164u,
  23u,
  0u,
  135u,
  1u,
  26u,
  0u,
  71u,
  155u,
  28u,
  0u,
  156u,
  119u,
  31u,
  0u,
  43u,
  157u,
  34u,
  0u,
  73u,
  19u,
  38u,
  0u,
  4u,
  226u,
  41u,
  0u,
  56u,
  18u,
  46u,
  0u,
  164u,
  173u,
  50u,
  0u,
  254u,
  190u,
  55u,
  0u,
  23u,
  82u,
  61u,
  0u,
  230u,
  115u,
  67u,
  0u,
  177u,
  50u,
  74u,
  0u,
  41u,
  158u,
  81u,
  0u,
  148u,
  199u,
  89u,
  0u,
  240u,
  193u,
  98u,
  0u,
  34u,
  162u,
  108u,
  0u,
  37u,
  127u,
  119u,
  0u,
  67u,
  114u,
  131u,
  0u,
  69u,
  151u,
  144u,
  0u,
  205u,
  12u,
  159u,
  0u,
  123u,
  244u,
  174u,
  0u,
  85u,
  115u,
  192u,
  0u,
  17u,
  178u,
  211u,
  0u,
  122u,
  221u,
  232u,
  0u,
  210u,
  38u,
  0u,
  1u,
  78u,
  196u,
  25u,
  1u,
  138u,
  241u,
  53u,
  1u,
  26u,
  240u,
  84u,
  1u,
  29u,
  8u,
  119u,
  1u,
  238u,
  136u,
  156u,
  1u,
  210u,
  201u,
  197u,
  1u,
  209u,
  42u,
  243u,
  1u,
  130u,
  21u,
  37u,
  2u,
  13u,
  254u,
  91u,
  2u,
  69u,
  100u,
  152u,
  2u,
  178u,
  212u,
  218u,
  2u,
  250u,
  233u,
  35u,
  3u,
  45u,
  78u,
  116u,
  3u,
  101u,
  188u,
  204u,
  3u,
  116u,
  2u,
  46u,
  4u,
  180u,
  2u,
  153u,
  4u,
  52u,
  182u,
  14u,
  5u,
  212u,
  46u,
  144u,
  5u,
  235u,
  153u,
  30u,
  6u,
  235u,
  66u,
  187u,
  6u,
  107u,
  150u,
  103u,
  7u,
  119u,
  37u,
  37u,
  8u,
  72u,
  169u,
  245u,
  8u,
  8u,
  7u,
  219u,
  9u,
  136u,
  84u,
  215u,
  10u,
  8u,
  221u,
  236u,
  11u,
  87u,
  38u,
  30u,
  13u,
  247u,
  246u,
  109u,
  14u,
  136u,
  92u,
  223u,
  15u,
  144u,
  178u,
  117u,
  17u,
  239u,
  170u,
  52u,
  19u,
  175u,
  85u,
  32u,
  21u,
  16u,
  43u,
  61u,
  23u,
  208u,
  21u,
  144u,
  25u,
  111u,
  126u,
  30u,
  28u,
  239u,
  87u,
  238u,
  30u,
  160u,
  45u,
  6u,
  34u,
  95u,
  50u,
  109u,
  37u,
  223u,
  80u,
  43u,
  41u,
  160u,
  63u,
  73u,
  45u,
  223u,
  146u,
  208u,
  49u,
  223u,
  212u,
  203u,
  54u,
  95u,
  157u,
  70u,
  60u,
  64u,
  173u,
  77u,
  66u,
  64u,
  2u,
  239u,
  72u,
  191u,
  28u,
  58u,
  80u,
  64u,
  236u,
  63u,
  88u,
  191u,
  29u,
  19u,
  97u,
  191u,
  58u,
  200u,
  106u,
  64u,
  218u,
  117u,
  117u,
  128u,
  214u,
  52u,
  129u,
  128u,
  134u,
  32u,
  142u,
  128u,
  250u,
  86u,
  156u,
  128u,
  70u,
  249u,
  171u,
  128u,
  206u,
  43u,
  189u,
  128u,
  150u,
  22u,
  208u,
  128u,
  166u,
  229u,
  228u,
  128u,
  106u,
  201u,
  251u,
  28u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u,
  0u
}; // idb
_UNKNOWN unk_1400BD4A8; // weak
_DWORD dword_1400BDD30[296] =
{
  0,
  1996959894,
  -301047508,
  -1727442502,
  124634137,
  1886057615,
  -379345611,
  -1637575261,
  249268274,
  2044508324,
  -522852066,
  -1747789432,
  162941995,
  2125561021,
  -407360249,
  -1866523247,
  498536548,
  1789927666,
  -205950648,
  -2067906082,
  450548861,
  1843258603,
  -187386543,
  -2083289657,
  325883990,
  1684777152,
  -43845254,
  -1973040660,
  335633487,
  1661365465,
  -99664541,
  -1928851979,
  997073096,
  1281953886,
  -715111964,
  -1570279054,
  1006888145,
  1258607687,
  -770865667,
  -1526024853,
  901097722,
  1119000684,
  -608450090,
  -1396901568,
  853044451,
  1172266101,
  -589951537,
  -1412350631,
  651767980,
  1373503546,
  -925412992,
  -1076862698,
  565507253,
  1454621731,
  -809855591,
  -1195530993,
  671266974,
  1594198024,
  -972236366,
  -1324619484,
  795835527,
  1483230225,
  -1050600021,
  -1234817731,
  1994146192,
  31158534,
  -1731059524,
  -271249366,
  1907459465,
  112637215,
  -1614814043,
  -390540237,
  2013776290,
  251722036,
  -1777751922,
  -519137256,
  2137656763,
  141376813,
  -1855689577,
  -429695999,
  1802195444,
  476864866,
  -2056965928,
  -228458418,
  1812370925,
  453092731,
  -2113342271,
  -183516073,
  1706088902,
  314042704,
  -1950435094,
  -54949764,
  1658658271,
  366619977,
  -1932296973,
  -69972891,
  1303535960,
  984961486,
  -1547960204,
  -725929758,
  1256170817,
  1037604311,
  -1529756563,
  -740887301,
  1131014506,
  879679996,
  -1385723834,
  -631195440,
  1141124467,
  855842277,
  -1442165665,
  -586318647,
  1342533948,
  654459306,
  -1106571248,
  -921952122,
  1466479909,
  544179635,
  -1184443383,
  -832445281,
  1591671054,
  702138776,
  -1328506846,
  -942167884,
  1504918807,
  783551873,
  -1212326853,
  -1061524307,
  -306674912,
  -1698712650,
  62317068,
  1957810842,
  -355121351,
  -1647151185,
  81470997,
  1943803523,
  -480048366,
  -1805370492,
  225274430,
  2053790376,
  -468791541,
  -1828061283,
  167816743,
  2097651377,
  -267414716,
  -2029476910,
  503444072,
  1762050814,
  -144550051,
  -2140837941,
  426522225,
  1852507879,
  -19653770,
  -1982649376,
  282753626,
  1742555852,
  -105259153,
  -1900089351,
  397917763,
  1622183637,
  -690576408,
  -1580100738,
  953729732,
  1340076626,
  -776247311,
  -1497606297,
  1068828381,
  1219638859,
  -670225446,
  -1358292148,
  906185462,
  1090812512,
  -547295293,
  -1469587627,
  829329135,
  1181335161,
  -882789492,
  -1134132454,
  628085408,
  1382605366,
  -871598187,
  -1156888829,
  570562233,
  1426400815,
  -977650754,
  -1296233688,
  733239954,
  1555261956,
  -1026031705,
  -1244606671,
  752459403,
  1541320221,
  -1687895376,
  -328994266,
  1969922972,
  40735498,
  -1677130071,
  -351390145,
  1913087877,
  83908371,
  -1782625662,
  -491226604,
  2075208622,
  213261112,
  -1831694693,
  -438977011,
  2094854071,
  198958881,
  -2032938284,
  -237706686,
  1759359992,
  534414190,
  -2118248755,
  -155638181,
  1873836001,
  414664567,
  -2012718362,
  -15766928,
  1711684554,
  285281116,
  -1889165569,
  -127750551,
  1634467795,
  376229701,
  -1609899400,
  -686959890,
  1308918612,
  956543938,
  -1486412191,
  -799009033,
  1231636301,
  1047427035,
  -1362007478,
  -640263460,
  1088359270,
  936918000,
  -1447252397,
  -558129467,
  1202900863,
  817233897,
  -1111625188,
  -893730166,
  1404277552,
  615818150,
  -1160759803,
  -841546093,
  1423857449,
  601450431,
  -1285129682,
  -1000256840,
  1567103746,
  711928724,
  -1274298825,
  -1022587231,
  1510334235,
  755167117,
  876552802,
  1493807909,
  -1250825213,
  -1968128575,
  -1737333312,
  1355029185,
  -1015514821,
  707791674,
  1549468968,
  1983585458,
  -472798206,
  907104351,
  -819889988,
  -1205346279,
  1955429786,
  1897013204,
  -2000622017,
  -1765974420,
  -1634428760,
  -950452975,
  631180913,
  806385448,
  2133203590,
  753145771,
  -864990665,
  455966598,
  -1084142184,
  1591635381,
  -303531489,
  -822087194,
  734498401,
  669472264,
  1087020661,
  -128845062,
  -483828733,
  831403042,
  1097652781,
  -1412074699,
  1964476649,
  -1757874462
}; // idb
_DWORD dword_1400C4460[716] =
{
  1,
  8,
  2,
  4,
  16,
  128,
  32,
  64,
  1296886298,
  -581150493,
  0,
  -954289658,
  936562452,
  0,
  -1315887765,
  -67657254,
  0,
  -716897657,
  1087025941,
  0,
  7424826,
  -541778261,
  0,
  -688007190,
  -340396854,
  0,
  -1965688206,
  2063304014,
  0,
  -1697457551,
  740840624,
  0,
  2051709159,
  581329564,
  0,
  1374873178,
  1585514454,
  0,
  -1476790155,
  -1735591905,
  0,
  1499137329,
  -1422794777,
  0,
  498061586,
  -363260910,
  0,
  -1267998384,
  -752287148,
  0,
  328146973,
  1415924369,
  0,
  1821089888,
  474754264,
  0,
  -1534028104,
  -1901053350,
  0,
  1430968715,
  584196960,
  0,
  290603647,
  -1289620366,
  0,
  1303845420,
  -202852090,
  0,
  -2058021893,
  -764818535,
  0,
  0,
  827540293,
  32,
  1475475917,
  -1101949461,
  2021501684,
  -896110313,
  -1532062852,
  -1537165634,
  -531726387,
  1212715777,
  804465119,
  940418621,
  832380782,
  1639626679,
  -1756961294,
  -1395009702,
  1811730329,
  1804365976,
  1184016,
  101254920,
  67831050,
  34407180,
  983310,
  0,
  1,
  2,
  0,
  3,
  4,
  0,
  3,
  5,
  0,
  3,
  6,
  0,
  3,
  8,
  0,
  9,
  10,
  2,
  9,
  11,
  3,
  12,
  13,
  0,
  0,
  0,
  11,
  16,
  17,
  1,
  16,
  18,
  0,
  19,
  20,
  0,
  21,
  22,
  0,
  0,
  0,
  4,
  0,
  0,
  5,
  0,
  0,
  6,
  0,
  0,
  7,
  0,
  0,
  8,
  0,
  0,
  9,
  0,
  0,
  10,
  0,
  0,
  12,
  0,
  0,
  1,
  3,
  7,
  15,
  31,
  63,
  127,
  255,
  511,
  1023,
  2047,
  4095,
  8191,
  16383,
  32767,
  65535,
  1073741825,
  608996168,
  -1047836648,
  1221364556,
  1208154561,
  136598667,
  0,
  0,
  16843009,
  33686018,
  33686018,
  50529027,
  50529027,
  50529027,
  50529027,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  101058054,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  117901063,
  50462976,
  84214788,
  101058054,
  117901063,
  134744072,
  134744072,
  151587081,
  151587081,
  168430090,
  168430090,
  168430090,
  168430090,
  185273099,
  185273099,
  185273099,
  185273099,
  202116108,
  202116108,
  202116108,
  202116108,
  202116108,
  202116108,
  202116108,
  202116108,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  235802126,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  252645135,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  269488144,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  286331153,
  134742016,
  151587081,
  168430090,
  168430090,
  185273099,
  185273099,
  185273099,
  185273099,
  202116108,
  202116108,
  202116108,
  202116108,
  202116108,
  202116108,
  202116108,
  202116108,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  218959117,
  319946752,
  353702932,
  370546198,
  387389207,
  404232216,
  404232216,
  421075225,
  421075225,
  437918234,
  437918234,
  437918234,
  437918234,
  454761243,
  454761243,
  454761243,
  454761243,
  471604252,
  471604252,
  471604252,
  471604252,
  471604252,
  471604252,
  471604252,
  471604252,
  488447261,
  488447261,
  488447261,
  488447261,
  488447261,
  488447261,
  488447261,
  488447261,
  0,
  0,
  16843009,
  16843009,
  33686018,
  33686018,
  33686018,
  33686018,
  50529027,
  50529027,
  50529027,
  50529027,
  50529027,
  50529027,
  50529027,
  50529027,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  67372036,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  84215045,
  328965,
  16908545,
  17039619,
  17170693,
  17301767,
  17367305,
  17432842,
  17498379,
  17563916,
  17629453,
  17629453,
  17694990,
  17694990,
  17760527,
  17760527,
  17826064,
  17826064,
  17891601,
  17891601,
  17891601,
  17891601,
  17957138,
  17957138,
  17957138,
  17957138,
  18022675,
  18022675,
  18022675,
  18022675,
  18088212,
  18088212,
  18088212,
  18088212,
  18153749,
  18153749,
  18153749,
  18153749,
  18153749,
  18153749,
  18153749,
  18153749,
  18219286,
  18219286,
  18219286,
  18219286,
  18219286,
  18219286,
  18219286,
  18219286,
  18284823,
  18284823,
  18284823,
  18284823,
  18284823,
  18284823,
  18284823,
  18284823,
  18350360,
  18350360,
  18350360,
  18350360,
  18350360,
  18350360,
  18350360,
  18350360,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18415897,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18481434,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18546971,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18612508,
  18678044,
  921274,
  0,
  1,
  1212200333,
  10,
  1473057813,
  686588744,
  1220555085,
  -12004815,
  12077250,
  0,
  -16777216,
  -998029104,
  49960,
  23724138,
  216298751,
  184,
  -1026490624,
  4,
  0
}; // idb
char aClfcclficlfocl[181] = "ClfCClfIClfOClfsCM11CM13CM16CM17CM20CM25CM26CM27CM28CM29CM31CM32CMAlCMCaCMSbCMScContDcddDeviEtwBUdMIUrefUsbCWDIsWdogWfpCWfpSViMmNhfsNtf0NtFBNtFfNtFLObtbPcSiUswdPlclScCBSmBfSmMmSmMs"; // weak
_UNKNOWN unk_1400D2D90; // weak
int dword_1400D8008[8] = { 0, 1, 2, 3, 4, 5, 7, 0 }; // idb
int dword_1400D803C = -1; // weak
int dword_1400D8064 = -1; // weak
int dword_1400D8068 = -1; // weak
int dword_1400D806C = -1; // weak
int dword_1400D8070 = -1; // weak
int dword_1400D8074 = -1; // weak
int dword_1400D8078 = -1; // weak
wchar_t *off_1400D8090[30] =
{
  L"00AAC56B-CD44-11D0-8CC2-00C04FC295EE",
  L"CertCheck",
  L"SoftpubCheckCert",
  L"Certificate",
  L"WintrustCertificateTrust",
  L"Cleanup",
  L"SoftpubCleanup",
  L"FinalPolicy",
  L"SoftpubAuthenticode",
  L"Initialization",
  L"SoftpubInitialize",
  L"Message",
  L"SoftpubLoadMessage",
  L"Signature",
  L"SoftpubLoadSignature",
  L"F750E6C3-38EE-11D1-85E5-00C04FC295EE",
  L"CertCheck",
  L"SoftpubCheckCert",
  L"Certificate",
  L"WintrustCertificateTrust",
  L"Cleanup",
  L"DriverCleanupPolicy",
  L"FinalPolicy",
  L"DriverFinalPolicy",
  L"Initialization",
  L"DriverInitializePolicy",
  L"Message",
  L"SoftpubLoadMessage",
  L"Signature",
  L"SoftpubLoadSignature"
}; // weak
__int64 qword_1400D81A0 = 0i64; // weak
int dword_1400D81A8 = 0; // weak
int dword_1400D81B8 = 0; // weak
__int64 qword_1400D81C0 = 0i64; // weak
char byte_1400D81F2 = '\0'; // weak
__int64 qword_1400D8208; // weak
__int64 qword_1400D8210; // weak
__int64 qword_1400D8240; // weak
__int64 qword_1400D8248; // weak
__int64 qword_1400D8250; // weak
__int64 qword_1400D8260; // weak
__int64 qword_1400D8268; // weak
struct _FAST_MUTEX stru_1400D8270; // idb
__int64 qword_1400D82B0; // weak
__int64 qword_1400D82B8; // weak
_UNKNOWN unk_1400D82C8; // weak
__int16 word_1400D82CC; // weak
__int64 qword_1400D82D0; // weak
int dword_1400D82EC; // weak
int dword_1400D82F0; // weak
__int64 qword_1400D82F8; // weak
PVOID qword_1400D8300; // idb
__int64 qword_1400D8308; // weak
__int64 qword_1400D8310; // weak
__int64 qword_1400D8318; // weak
PFAST_MUTEX qword_1400D8370; // idb
char byte_1400D83A0; // weak
char byte_1400D83A1; // weak
char byte_1400D83A2; // weak
char byte_1400D83A3; // weak
int dword_1400D83A4; // weak
struct _FAST_MUTEX FastMutex; // idb
_UNKNOWN unk_1400D83E0; // weak
__int64 qword_1400D85E0; // weak
__int64 qword_1400D85E8; // weak
__int64 (__fastcall *qword_1400D85F0)(_QWORD, _QWORD); // weak
__int64 qword_1400D8610; // weak
__int64 qword_1400D8618; // weak
__int64 qword_1400D8620; // weak
__int64 qword_1400D8628; // weak
__int64 qword_1400D8630; // weak
__int64 qword_1400D8638; // weak
__int64 qword_1400D8640; // weak
struct _FAST_MUTEX stru_1400D8648; // idb
int dword_1400D8684; // weak
struct _FAST_MUTEX stru_1400D8688; // idb
__int64 qword_1400D86C8; // weak
__int64 qword_1400D86D0; // weak
__int64 qword_1400D86E8; // weak
__int64 qword_1400D86F0; // weak
__int64 qword_1400D86F8; // weak
__int64 qword_1400D8710; // weak
__int64 qword_1400D8718; // weak
__int64 qword_1400D8720; // weak
__int64 qword_1400D8728; // weak
__int64 qword_1400D8730; // weak
__int64 qword_1400D8740; // weak
int dword_1400D8750; // weak
__int64 qword_1400D8758; // weak
__int64 qword_1400D8760; // weak
__int64 qword_1400D8768; // weak
int dword_1400D8770; // weak
char byte_1400D877C; // weak
char byte_1400D877D; // weak
__int64 qword_1400D87C8; // weak
__int64 qword_1400D87D0; // weak
int dword_1400D8818; // weak
int dword_1400D881C; // weak
_UNKNOWN unk_1400D8820; // weak
_UNKNOWN unk_1400DA820; // weak
_UNKNOWN unk_1400DA828; // weak
__int64 qword_1400DA920; // weak
struct _FAST_MUTEX stru_1400DA928; // idb
__int64 qword_1400DA9C0; // weak
int dword_1400DA9C8; // weak
__int64 qword_1400DA9D0; // weak
__int64 qword_1400DA9D8; // weak
__int64 qword_1400DA9E0; // weak
int dword_1400DA9E8; // weak
int dword_1400DAB40; // weak
__int64 qword_1400DAB48; // weak
__int64 qword_1400DAB50; // weak
__int64 qword_1400DAB58; // weak
__int64 qword_1400DAB60; // weak
__int64 qword_1400DAB68; // weak
__int64 qword_1400DAB70; // weak
__int64 qword_1400DAB78; // weak
int dword_1400DAB80; // weak
struct _FAST_MUTEX stru_1400DAB88; // idb
PVOID P; // idb
int dword_1400DABC8; // weak
PRKEVENT Object; // idb
__int64 qword_1400DABD8; // weak
__int64 qword_1400DABE0; // weak
char byte_1400DABE8; // weak
char byte_1400DABE9; // weak
char byte_1400DABEA; // weak
struct _FAST_MUTEX stru_1400DAC10; // idb
__int64 qword_1400DAC48; // weak
int dword_1400DAC84; // weak
__int64 qword_1400DAC90; // weak
struct _FAST_MUTEX stru_1400DACA0; // idb
__int64 qword_1400DACE8; // weak
__int64 qword_1400DACF0; // weak
__int64 qword_1400DACF8; // weak
__int64 qword_1400DAD00; // weak
__int64 qword_1400DAD10; // weak
__int64 qword_1400DAD18; // weak
__int64 qword_1400DAD20; // weak
__int64 qword_1400DAD28; // weak
__int64 qword_1400DAD30; // weak
__int64 qword_1400DAD68; // weak
__int64 qword_1400DAD70; // weak
__int64 qword_1400DAD78; // weak
__int64 qword_1400DAD80; // weak
__int64 qword_1400DAD88; // weak
__int64 qword_1400DAD98; // weak
__int64 qword_1400DADA0; // weak
__int64 qword_1400DADA8; // weak
__int64 qword_1400DADD0; // weak
__int64 qword_1400DADD8; // weak
__int64 qword_1400DADE8; // weak
__int64 qword_1400DADF0; // weak
PVOID qword_1400DADF8; // idb
__int64 qword_1400DAE30; // weak
__int64 qword_1400DAE38; // weak
__int64 qword_1400DAE40; // weak
__int64 qword_1400DAE50; // weak
__int64 qword_1400DAE60; // weak
__int64 qword_1400DAE68; // weak
__int64 qword_1400DAE70; // weak
__int64 qword_1400DAE78; // weak
__int64 qword_1400DAE80; // weak
__int64 qword_1400DAE88; // weak
__int64 qword_1400DAE90; // weak
__int64 qword_1400DAE98; // weak
__int64 qword_1400DAEB8; // weak
__int64 qword_1400DAEC0; // weak
__int64 qword_1400DAEC8; // weak
__int64 qword_1400DAED0; // weak
__int64 qword_1400DAEF8; // weak
__int64 qword_1400DAF00; // weak
__int64 qword_1400DAF08; // weak
__int64 qword_1400DAF10; // weak
__int64 qword_1400DAF20; // weak
PVOID qword_1400DAF40; // idb
signed __int32 dword_1400DAF64[13]; // idb
PFAST_MUTEX qword_1400DAF98; // idb
struct _FAST_MUTEX stru_1400DB0A0; // idb
__int64 qword_1400DB1B8; // weak
__int64 qword_1400DB1C0; // weak
signed __int32 dword_1400DB1C8[4]; // idb
int dword_1400DB244; // weak
PFLT_FILTER Filter; // idb
__int64 qword_1400DB288; // weak
struct _FAST_MUTEX stru_1400DB290; // idb
struct _FAST_MUTEX stru_1400DB2C8; // idb
__int64 qword_1400DB308; // weak
__int64 qword_1400DB310; // weak
__int64 qword_1400DB318; // weak
__int64 qword_1400DB320; // weak
__int64 qword_1400DB330; // weak
__int64 qword_1400DB338; // weak
__int64 qword_1400DB348; // weak
__int64 qword_1400DB350; // weak
__int64 qword_1400DB358; // weak
__int64 qword_1400DB370; // weak
__int64 qword_1400DB378; // weak
__int64 qword_1400DB380; // weak
__int64 qword_1400DB388; // weak
__int64 qword_1400DB390; // weak
__int64 qword_1400DB398; // weak
__int64 qword_1400DB3A0; // weak
__int64 qword_1400DB3A8; // weak
__int64 qword_1400DB3B0; // weak
__int64 qword_1400DB3B8; // weak
__int64 qword_1400DB3C0; // weak
__int64 qword_1400DB3C8; // weak
__int64 qword_1400DB3E8; // weak
__int64 qword_1400DB3F0; // weak
__int64 qword_1400DB3F8; // weak
__int64 qword_1400DB400; // weak
__int64 qword_1400DB418; // weak
__int64 qword_1400DB420; // weak
int dword_1400DB428; // weak
int dword_1400DB42C; // weak
__int64 qword_1400DB430; // weak
char byte_1400DB438; // weak
char byte_1400DB439; // weak
char byte_1400DB43A; // weak
__int64 (__fastcall *qword_1400DB440)(_QWORD, _QWORD, _QWORD); // weak
__int64 (__fastcall *qword_1400DB448)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
__int64 qword_1400DB458; // weak
struct _FAST_MUTEX stru_1400DB468; // idb
__int64 qword_1400DB4A0; // weak
__int64 qword_1400DB4A8; // weak
__int64 (__fastcall *qword_1400DB4E0)(_QWORD, _QWORD, _QWORD, _QWORD); // weak
int dword_1400DB4E8; // weak
__int16 word_1400DB510; // weak
__int64 qword_1400DB560; // weak
int dword_1400DB56C; // weak
__int64 qword_1400DB570; // weak
__int64 qword_1400DB578; // weak
int dword_1400DB588; // weak
__int64 qword_1400DB590; // weak
int dword_1400DB598; // weak
int dword_1400DB59C; // weak
__int64 qword_1400DB5A0; // weak
int dword_1400DB5A8; // weak
__int64 qword_1400DB5B0; // weak
__int64 qword_1400DB5B8; // weak
__int64 qword_1400DB5C0; // weak
__int64 qword_1400DB5C8; // weak
__int64 qword_1400DB5D0; // weak


//----- (0000000140001000) ----------------------------------------------------
char sub_140001000()
{
  ((void (*)(void))loc_14006B1F0)();
  return 1;
}

//----- (0000000140001014) ----------------------------------------------------
bool sub_140001014()
{
  unsigned __int64 v0; // rax

  v0 = __readmsr(0x122u);
  return (v0 & 1) == 0;
}

//----- (000000014000102C) ----------------------------------------------------
bool sub_14000102C()
{
  unsigned __int64 v0; // r9
  unsigned __int64 v1; // rax

  v0 = __readmsr(0x122u);
  _disable();
  __writemsr(0x122u, v0 & 0xFFFFFFFFFFFFFFFEui64);
  v1 = __readmsr(0x122u);
  __writemsr(0x122u, v0);
  _enable();
  return (v1 & 1) == 0;
}

//----- (0000000140003B10) ----------------------------------------------------
void __fastcall sub_140003B10(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 i; // r9
  char v5; // cl
  char v6; // [rsp+20h] [rbp-19h] BYREF
  char v7[111]; // [rsp+21h] [rbp-18h] BYREF

  v6 = 0x80;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v7, 0i64, 0x47i64);
  v2 = *(_QWORD *)(a1 + 0x18);
  v3 = (-((_DWORD)v2 + 9) & 0x3F) + 1i64;
  for ( i = 0i64; i < 0x40; i += 8i64 )
  {
    v5 = 0x38 - i;
    *(&v6 + v3++) = (unsigned __int64)(8 * v2) >> v5;
  }
  sub_140003C4C(a1, (__int64)&v6, v3);
  JUMPOUT(0x140003B8Bi64);
}
// 140003B89: control flows out of bounds to 140003B8B

//----- (0000000140003C4C) ----------------------------------------------------
__int64 __fastcall sub_140003C4C(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v5; // rdi
  _BYTE *v8; // rdx
  __int64 v9; // rcx
  char v10; // al
  __int64 v11; // r14
  __int64 v12; // r9
  unsigned __int8 *v13; // rdx
  int v14; // eax
  int v15; // ecx
  _BYTE *v16; // rcx
  char v17; // al
  _DWORD v19[16]; // [rsp+20h] [rbp-58h] BYREF

  v3 = 0i64;
  v5 = *(_QWORD *)(a1 + 0x18) & 0x3Fi64;
  *(_QWORD *)(a1 + 0x18) += a3;
  if ( v5 + a3 >= 0x40 )
  {
    do
    {
      if ( v5 )
      {
        v8 = (_BYTE *)(v5 + a1 + 0x20);
        v9 = 0x40 - v5;
        do
        {
          v10 = *(_BYTE *)(v3 + a2);
          ++v3;
          *v8++ = v10;
          --v9;
        }
        while ( v9 );
        v11 = a1 + 0x20;
        v5 = 0i64;
      }
      else
      {
        v11 = v3 + a2;
        v3 += 0x40i64;
      }
      ((void (__fastcall *)(_DWORD *, _QWORD, __int64))loc_14006F2C0)(v19, 0i64, 0x40i64);
      v12 = 0x10i64;
      v13 = (unsigned __int8 *)(v11 + 2);
      do
      {
        v14 = *v13;
        v15 = v13[1];
        v13 += 4;
        *(_DWORD *)&v13[(_QWORD)v19 - v11 - 6] = v13[0xFFFFFFFA] | ((v13[0xFFFFFFFB] | ((v14 | (v15 << 8)) << 8)) << 8);
        --v12;
      }
      while ( v12 );
      sub_140003DBC((_DWORD *)a1, v19);
    }
    while ( a3 >= v3 + 0x40 );
  }
  if ( v3 < a3 )
  {
    v16 = (_BYTE *)(v5 + a1 + 0x20);
    do
    {
      v17 = *(_BYTE *)(v3 + a2);
      ++v3;
      *v16++ = v17;
    }
    while ( v3 < a3 );
  }
  return a1;
}
// 140003C97: conditional instruction was optimized away because of 'rdi.8 in (1..3F)'

//----- (0000000140003D70) ----------------------------------------------------
__int64 __fastcall sub_140003D70(__int64 a1)
{
  *(_QWORD *)(a1 + 0x18) = 0i64;
  *(_DWORD *)a1 = 0x67452301;
  *(_DWORD *)(a1 + 4) = 0xEFCDAB89;
  *(_DWORD *)(a1 + 8) = 0x98BADCFE;
  *(_DWORD *)(a1 + 0xC) = 0x10325476;
  *(_DWORD *)(a1 + 0x10) = 0xC3D2E1F0;
  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a1 + 0x20, 0i64, 0x40i64);
  *(_DWORD *)(a1 + 0x60) = 0;
  return a1;
}

//----- (0000000140003DBC) ----------------------------------------------------
__int64 __fastcall sub_140003DBC(_DWORD *a1, _DWORD *a2)
{
  _DWORD *v2; // rdi
  int v3; // edx
  int v4; // er9
  int v5; // er8
  int v6; // er10
  int v7; // ecx
  int v8; // er9
  int v9; // er11
  int v10; // ecx
  int v11; // er10
  int v12; // edx
  int v13; // ecx
  int v14; // er11
  int v15; // er8
  int v16; // ecx
  int v17; // edx
  int v18; // er9
  int v19; // ecx
  int v20; // er8
  int v21; // er10
  int v22; // ecx
  int v23; // er9
  int v24; // er11
  int v25; // ecx
  int v26; // er10
  int v27; // edx
  int v28; // ecx
  int v29; // er11
  int v30; // er8
  int v31; // ecx
  int v32; // edx
  int v33; // ebx
  int v34; // er9
  int v35; // er8
  int v36; // er10
  int v37; // ebx
  int v38; // er10
  int v39; // er11
  int v40; // er9
  int v41; // er11
  int v42; // edx
  int v43; // er10
  int v44; // edx
  int v45; // er8
  int v46; // er11
  int v47; // er8
  int v48; // er12
  int v49; // ecx
  int v50; // edx
  int v51; // er9
  int v52; // ecx
  int v53; // er8
  int v54; // er10
  int v55; // er13
  int v56; // ecx
  int v57; // er9
  int v58; // er11
  int v59; // ecx
  int v60; // er10
  int v61; // edx
  int v62; // ecx
  int v63; // er11
  int v64; // er8
  int v65; // ebp
  int v66; // er15
  int v67; // er9
  int v68; // ecx
  int v69; // er8
  int v70; // edx
  int v71; // er14
  int v72; // er10
  int v73; // esi
  int v74; // ecx
  int v75; // er9
  int v76; // er11
  int v77; // er12
  int v78; // ecx
  int v79; // er10
  int v80; // edx
  int v81; // ebx
  int v82; // er11
  int v83; // ebx
  int v84; // edx
  int v85; // ecx
  int v86; // ebx
  int v87; // er8
  unsigned int v88; // ecx
  int v89; // er9
  unsigned int v90; // ecx
  int v91; // er8
  int v92; // er10
  unsigned int v93; // er11
  int v94; // er9
  int v95; // er11
  int v96; // edx
  int v97; // er10
  int v98; // edx
  int v99; // ecx
  int v100; // er11
  int v101; // er8
  int v102; // ecx
  int v103; // edx
  int v104; // er9
  int v105; // ecx
  int v106; // er8
  int v107; // er10
  int v108; // ecx
  int v109; // er9
  int v110; // er11
  int v111; // er13
  int v112; // ebx
  int v113; // er10
  int v114; // ecx
  int v115; // er11
  int v116; // ebx
  int v117; // edx
  int v118; // ebp
  int v119; // er8
  int v120; // ecx
  int v121; // ebx
  int v122; // er9
  int v123; // ecx
  int v124; // er8
  int v125; // er10
  int v126; // ecx
  int v127; // er9
  int v128; // er11
  int v129; // er14
  int v130; // ecx
  int v131; // er10
  int v132; // ebx
  int v133; // ecx
  int v134; // er11
  int v135; // er8
  int v136; // eax
  int v137; // ecx
  int v138; // ebx
  int v139; // er9
  int v140; // ecx
  int v141; // er8
  int v142; // er10
  int v143; // er14
  int v144; // er13
  int v145; // ecx
  int v146; // er9
  int v147; // er11
  int v148; // ecx
  int v149; // er10
  int v150; // ebx
  int v151; // eax
  int v152; // ecx
  int v153; // er11
  int v154; // ecx
  int v155; // eax
  int v156; // er8
  int v157; // ecx
  int v158; // ebx
  int v159; // er9
  int v160; // ecx
  int v161; // er8
  int v162; // er10
  int v163; // eax
  int v164; // ecx
  int v165; // er9
  int v166; // er11
  int v167; // ecx
  int v168; // er10
  int v169; // eax
  int v170; // ebx
  int v171; // ecx
  int v172; // er11
  int v173; // er8
  int v174; // er12
  int v175; // ebx
  int v176; // ecx
  int v177; // er8
  int v178; // esi
  unsigned int v179; // ecx
  int v180; // er9
  int v181; // er15
  unsigned int v182; // ecx
  int v183; // esi
  int v184; // eax
  int v185; // er10
  unsigned int v186; // ecx
  int v187; // er9
  int v188; // er11
  int v189; // edx
  int v190; // ecx
  int v191; // er10
  int v192; // eax
  int v193; // ebx
  int v194; // ecx
  int v195; // er11
  int v196; // er8
  int v197; // esi
  int v198; // eax
  int v199; // ebx
  int v200; // er9
  int v201; // eax
  int v202; // er8
  int v203; // er10
  int v204; // eax
  int v205; // er9
  int v206; // er11
  int v207; // eax
  int v208; // er10
  int v209; // ebx
  int v210; // eax
  int v211; // er11
  int v212; // edx
  int v213; // er8
  int v214; // eax
  int v215; // ebx
  int v216; // er9
  int v217; // er8
  int v218; // eax
  int v219; // edx
  int v220; // er9
  int v221; // er14
  int v222; // eax
  int v223; // er8
  int v224; // er15
  int v225; // er10
  int v226; // er12
  int v227; // eax
  int v228; // er9
  int v229; // er11
  int v230; // er13
  int v231; // eax
  int v232; // er10
  int v233; // ebx
  int v234; // eax
  int v235; // er11
  int v236; // er8
  int v237; // eax
  int v238; // ebx
  int v239; // er9
  int v240; // edx
  int v241; // esi
  int v242; // ebp
  int v243; // eax
  int v244; // er8
  int v245; // edx
  int v246; // esi
  int v247; // eax
  int v248; // er9
  int v249; // er11
  int v250; // ebp
  unsigned int v251; // eax
  int v252; // ebx
  unsigned int v253; // eax
  int v254; // er11
  int v255; // er10
  unsigned int v256; // eax
  int v257; // ebx
  int v258; // er9
  int v259; // edx
  int v260; // eax
  int v261; // er10
  int v262; // er8
  int v263; // esi
  int v264; // ebp
  int v265; // eax
  int v266; // er9
  int v267; // edx
  __int64 result; // rax
  unsigned int v269; // [rsp+0h] [rbp-A8h]
  int v270; // [rsp+0h] [rbp-A8h]
  int v271; // [rsp+0h] [rbp-A8h]
  int v272; // [rsp+0h] [rbp-A8h]
  int v273; // [rsp+0h] [rbp-A8h]
  unsigned int v274; // [rsp+4h] [rbp-A4h]
  int v275; // [rsp+4h] [rbp-A4h]
  int v276; // [rsp+4h] [rbp-A4h]
  unsigned int v277; // [rsp+8h] [rbp-A0h]
  int v278; // [rsp+8h] [rbp-A0h]
  int v279; // [rsp+8h] [rbp-A0h]
  int v280; // [rsp+8h] [rbp-A0h]
  unsigned int v281; // [rsp+Ch] [rbp-9Ch]
  int v282; // [rsp+Ch] [rbp-9Ch]
  int v283; // [rsp+Ch] [rbp-9Ch]
  int v284; // [rsp+Ch] [rbp-9Ch]
  unsigned int v285; // [rsp+10h] [rbp-98h]
  int v286; // [rsp+10h] [rbp-98h]
  int v287; // [rsp+10h] [rbp-98h]
  int v288; // [rsp+10h] [rbp-98h]
  int v289; // [rsp+14h] [rbp-94h]
  int v290; // [rsp+14h] [rbp-94h]
  int v291; // [rsp+14h] [rbp-94h]
  unsigned int v292; // [rsp+18h] [rbp-90h]
  int v293; // [rsp+18h] [rbp-90h]
  int v294; // [rsp+18h] [rbp-90h]
  unsigned int v295; // [rsp+1Ch] [rbp-8Ch]
  int v296; // [rsp+1Ch] [rbp-8Ch]
  int v297; // [rsp+1Ch] [rbp-8Ch]
  unsigned int v298; // [rsp+20h] [rbp-88h]
  int v299; // [rsp+20h] [rbp-88h]
  int v300; // [rsp+20h] [rbp-88h]
  unsigned int v301; // [rsp+24h] [rbp-84h]
  int v302; // [rsp+24h] [rbp-84h]
  int v303; // [rsp+24h] [rbp-84h]
  unsigned int v304; // [rsp+28h] [rbp-80h]
  int v305; // [rsp+28h] [rbp-80h]
  int v306; // [rsp+28h] [rbp-80h]
  unsigned int v307; // [rsp+2Ch] [rbp-7Ch]
  int v308; // [rsp+2Ch] [rbp-7Ch]
  int v309; // [rsp+2Ch] [rbp-7Ch]
  int v310; // [rsp+2Ch] [rbp-7Ch]
  unsigned int v311; // [rsp+30h] [rbp-78h]
  int v312; // [rsp+30h] [rbp-78h]
  unsigned int v313; // [rsp+34h] [rbp-74h]
  int v314; // [rsp+34h] [rbp-74h]
  int v315; // [rsp+34h] [rbp-74h]
  int v316; // [rsp+38h] [rbp-70h]
  int v317; // [rsp+38h] [rbp-70h]
  int v318; // [rsp+38h] [rbp-70h]
  unsigned int v319; // [rsp+3Ch] [rbp-6Ch]
  int v320; // [rsp+3Ch] [rbp-6Ch]
  int v321; // [rsp+40h] [rbp-68h]
  int v322; // [rsp+44h] [rbp-64h]
  int v323; // [rsp+48h] [rbp-60h]
  int v324; // [rsp+4Ch] [rbp-5Ch]
  int v325; // [rsp+50h] [rbp-58h]
  _DWORD *v327; // [rsp+B8h] [rbp+10h]
  unsigned int v328; // [rsp+C0h] [rbp+18h]
  int v329; // [rsp+C0h] [rbp+18h]
  int v330; // [rsp+C0h] [rbp+18h]
  int v331; // [rsp+C0h] [rbp+18h]
  unsigned int v332; // [rsp+C8h] [rbp+20h]
  int v333; // [rsp+C8h] [rbp+20h]
  int v334; // [rsp+C8h] [rbp+20h]
  int v335; // [rsp+C8h] [rbp+20h]

  v327 = a2;
  v2 = a2;
  v321 = *a1;
  v325 = a1[4];
  v322 = a1[1];
  v324 = a1[3];
  v323 = a1[2];
  v285 = __ROL4__(*a2, 8) & 0xFF00FF | __ROR4__(*a2, 8) & 0xFF00FF00;
  v3 = __ROR4__(v322, 2);
  v4 = v285 + __ROL4__(*a1, 5) + (v324 ^ v322 & (v323 ^ v324)) + v325 + 0x5A827999;
  v277 = __ROL4__(v2[1], 8) & 0xFF00FF | __ROR4__(v2[1], 8) & 0xFF00FF00;
  v5 = __ROR4__(*a1, 2);
  v6 = v324 + 0x5A827999 + v277 + __ROL4__(v4, 5) + (v323 ^ *a1 & (v3 ^ v323));
  v7 = v4 & (v5 ^ v3);
  v8 = __ROR4__(v4, 2);
  v269 = __ROL4__(v2[2], 8) & 0xFF00FF | __ROR4__(v2[2], 8) & 0xFF00FF00;
  v9 = v323 + (v3 ^ v7) + 0x5A827999 + __ROL4__(v6, 5) + v269;
  v332 = __ROL4__(v2[3], 8) & 0xFF00FF | __ROR4__(v2[3], 8) & 0xFF00FF00;
  v10 = v6 & (v5 ^ v8);
  v11 = __ROR4__(v6, 2);
  v12 = v332 + __ROL4__(v9, 5) + (v5 ^ v10) + v3 + 0x5A827999;
  v13 = v8 ^ v9 & (v11 ^ v8);
  v319 = __ROL4__(v2[4], 8) & 0xFF00FF | __ROR4__(v2[4], 8) & 0xFF00FF00;
  v14 = __ROR4__(v9, 2);
  v15 = v319 + __ROL4__(v12, 5) + v13 + v5 + 0x5A827999;
  v16 = v11 ^ v12 & (v14 ^ v11);
  v311 = __ROL4__(v2[5], 8) & 0xFF00FF | __ROR4__(v2[5], 8) & 0xFF00FF00;
  v17 = __ROR4__(v12, 2);
  v18 = v311 + 0x5A827999 + __ROL4__(v15, 5) + v16 + v8;
  v304 = __ROL4__(v2[6], 8) & 0xFF00FF | __ROR4__(v2[6], 8) & 0xFF00FF00;
  v19 = v14 ^ v15 & (v17 ^ v14);
  v20 = __ROR4__(v15, 2);
  v21 = v304 + 0x5A827999 + __ROL4__(v18, 5) + v19 + v11;
  v292 = __ROL4__(v2[7], 8) & 0xFF00FF | __ROR4__(v2[7], 8) & 0xFF00FF00;
  v22 = v17 ^ v18 & (v20 ^ v17);
  v23 = __ROR4__(v18, 2);
  v24 = v292 + 0x5A827999 + __ROL4__(v21, 5) + v22 + v14;
  v25 = v20 ^ v21 & (v20 ^ v23);
  v26 = __ROR4__(v21, 2);
  v298 = __ROL4__(v2[8], 8) & 0xFF00FF | __ROR4__(v2[8], 8) & 0xFF00FF00;
  v27 = v298 + __ROL4__(v24, 5) + 0x5A827999 + v25 + v17;
  v28 = v23 ^ v24 & (v26 ^ v23);
  v301 = __ROL4__(v2[9], 8) & 0xFF00FF | __ROR4__(v2[9], 8) & 0xFF00FF00;
  v29 = __ROR4__(v24, 2);
  v30 = v301 + 0x5A827999 + __ROL4__(v27, 5) + v28 + v20;
  v328 = __ROL4__(v2[0xA], 8) & 0xFF00FF | __ROR4__(v2[0xA], 8) & 0xFF00FF00;
  v31 = v26 ^ v27 & (v29 ^ v26);
  v32 = __ROR4__(v27, 2);
  v33 = v23 + 0x5A827999 + v31 + __ROL4__(v30, 5) + v328;
  v281 = __ROL4__(v2[0xB], 8) & 0xFF00FF | __ROR4__(v2[0xB], 8) & 0xFF00FF00;
  v34 = v26 + 0x5A827999 + v281 + __ROL4__(v33, 5) + (v29 ^ v30 & (v32 ^ v29));
  v35 = __ROR4__(v30, 2);
  v36 = v33 & (v35 ^ v32);
  v37 = __ROR4__(v33, 2);
  v274 = __ROL4__(v2[0xC], 8) & 0xFF00FF | __ROR4__(v2[0xC], 8) & 0xFF00FF00;
  v38 = v29 + 0x5A827999 + v274 + __ROL4__(v34, 5) + (v32 ^ v36);
  v39 = v35 ^ v34 & (v35 ^ v37);
  v40 = __ROR4__(v34, 2);
  v307 = __ROL4__(v2[0xD], 8) & 0xFF00FF | __ROR4__(v2[0xD], 8) & 0xFF00FF00;
  v41 = v32 + 0x5A827999 + v307 + __ROL4__(v38, 5) + v39;
  v42 = v37 ^ v38 & (v40 ^ v37);
  v43 = __ROR4__(v38, 2);
  v313 = __ROL4__(v2[0xE], 8) & 0xFF00FF | __ROR4__(v2[0xE], 8) & 0xFF00FF00;
  v44 = v35 + 0x5A827999 + v313 + __ROL4__(v41, 5) + v42;
  v45 = v40 ^ v41 & (v43 ^ v40);
  v46 = __ROR4__(v41, 2);
  v295 = __ROL4__(v2[0xF], 8) & 0xFF00FF | __ROR4__(v2[0xF], 8) & 0xFF00FF00;
  v47 = v37 + v295 + __ROL4__(v44, 5) + 0x5A827999 + v45;
  v48 = __ROL4__(v285 ^ v269 ^ v298 ^ v307, 1);
  v49 = v43 ^ v44 & (v46 ^ v43);
  v50 = __ROR4__(v44, 2);
  v51 = v48 + __ROL4__(v47, 5) + 0x5A827999 + v49 + v40;
  v316 = v48;
  v270 = __ROL4__(v269 ^ v319 ^ v328 ^ v295, 1);
  v286 = __ROL4__(v48 ^ v332 ^ v311 ^ v281, 1);
  v52 = v46 ^ v47 & (v50 ^ v46);
  v53 = __ROR4__(v47, 2);
  v278 = __ROL4__(v277 ^ v332 ^ v301 ^ v313, 1);
  v54 = v278 + __ROL4__(v51, 5) + 0x5A827999 + v52 + v43;
  v55 = __ROL4__(v278 ^ v319 ^ v304 ^ v274, 1);
  v56 = v50 ^ v51 & (v50 ^ v53);
  v57 = __ROR4__(v51, 2);
  v58 = v270 + __ROL4__(v54, 5) + 0x5A827999 + v56 + v46;
  v59 = v53 ^ v54 & (v57 ^ v53);
  v60 = __ROR4__(v54, 2);
  v61 = v286 + __ROL4__(v58, 5) + 0x5A827999 + v59 + v50;
  v62 = v58 ^ v60 ^ v57;
  v63 = __ROR4__(v58, 2);
  v64 = v55 + __ROL4__(v61, 5) + 0x6ED9EBA1 + v62 + v53;
  v65 = __ROL4__(v311 ^ v292 ^ v307 ^ v270, 1);
  v66 = __ROL4__(v304 ^ v298 ^ v313 ^ v286, 1);
  v67 = v65 + __ROL4__(v64, 5) + 0x6ED9EBA1 + (v61 ^ v63 ^ v60) + v57;
  v68 = v63 ^ v64;
  v69 = __ROR4__(v64, 2);
  v70 = __ROR4__(v61, 2);
  v71 = __ROL4__(v292 ^ v301 ^ v295 ^ v55, 1);
  v72 = v66 + __ROL4__(v67, 5) + 0x6ED9EBA1 + (v70 ^ v68) + v60;
  v73 = __ROL4__(v48 ^ v298 ^ v328 ^ v65, 1);
  v74 = v70 ^ v67 ^ v69;
  v75 = __ROR4__(v67, 2);
  v76 = v71 + __ROL4__(v72, 5) + 0x6ED9EBA1 + v74 + v63;
  v77 = __ROL4__(v278 ^ v301 ^ v281 ^ v66, 1);
  v78 = v73 + __ROL4__(v76, 5) + (v72 ^ v75 ^ v69);
  v79 = __ROR4__(v72, 2);
  v80 = v78 + v70 + 0x6ED9EBA1;
  v81 = v76 ^ v79 ^ v75;
  v82 = __ROR4__(v76, 2);
  v83 = v69 + 0x6ED9EBA1 + v77 + __ROL4__(v80, 5) + v81;
  v293 = __ROL4__(v328 ^ v274 ^ v270 ^ v71, 1);
  LODWORD(v2) = v293 + __ROL4__(v83, 5) + (v80 ^ v82 ^ v79);
  v84 = __ROR4__(v80, 2);
  LODWORD(v2) = v75 + 0x6ED9EBA1 + (_DWORD)v2;
  v85 = v82 ^ v83;
  v86 = __ROR4__(v83, 2);
  v289 = __ROL4__(v281 ^ v307 ^ v286 ^ v73, 1);
  v282 = __ROL4__(v274 ^ v313 ^ v55 ^ v77, 1);
  v87 = v79 + 0x6ED9EBA1 + (v84 ^ v85) + __ROL4__((_DWORD)v2, 5) + v289;
  v88 = v84 ^ (unsigned int)v2 ^ v86;
  LODWORD(v2) = __ROR4__((_DWORD)v2, 2);
  v308 = __ROL4__(v307 ^ v295 ^ v65 ^ v293, 1);
  v89 = v82 + 0x6ED9EBA1 + v88 + __ROL4__(v87, 5) + v282;
  v90 = v87 ^ (unsigned int)v2 ^ v86;
  v91 = __ROR4__(v87, 2);
  v92 = v84 + 0x6ED9EBA1 + v90 + __ROL4__(v89, 5) + v308;
  v93 = v89 ^ v91 ^ (unsigned int)v2;
  v333 = __ROL4__(v316 ^ v313 ^ v66 ^ v289, 1);
  v94 = __ROR4__(v89, 2);
  v95 = v86 + 0x6ED9EBA1 + v333 + __ROL4__(v92, 5) + v93;
  v275 = __ROL4__(v278 ^ v295 ^ v71 ^ v282, 1);
  v96 = (v92 ^ v94 ^ v91) + __ROL4__(v95, 5) + v275;
  v97 = __ROR4__(v92, 2);
  v98 = (_DWORD)v2 + 0x6ED9EBA1 + v96;
  v99 = v97 ^ v94 ^ v95;
  v317 = __ROL4__(v316 ^ v270 ^ v73 ^ v308, 1);
  v100 = __ROR4__(v95, 2);
  v101 = v317 + 0x6ED9EBA1 + __ROL4__(v98, 5) + v99 + v91;
  LODWORD(v2) = __ROL4__(v278 ^ v286 ^ v77 ^ v333, 1);
  v102 = v97 ^ v98 ^ v100;
  v103 = __ROR4__(v98, 2);
  v104 = (_DWORD)v2 + 0x6ED9EBA1 + __ROL4__(v101, 5) + v102 + v94;
  v105 = v101 ^ v103 ^ v100;
  v329 = __ROL4__(v270 ^ v55 ^ v293 ^ v275, 1);
  v106 = __ROR4__(v101, 2);
  v107 = v329 + 0x6ED9EBA1 + __ROL4__(v104, 5) + v105 + v97;
  v108 = v104 ^ v106 ^ v103;
  v271 = __ROL4__(v317 ^ v286 ^ v65 ^ v289, 1);
  v109 = __ROR4__(v104, 2);
  v110 = v271 + 0x6ED9EBA1 + __ROL4__(v107, 5) + v108 + v100;
  v314 = __ROL4__((unsigned int)v2 ^ v55 ^ v66 ^ v282, 1);
  v111 = v308;
  v112 = (v107 ^ v109 ^ v106) + __ROL4__(v110, 5) + v314;
  v113 = __ROR4__(v107, 2);
  v114 = v109 ^ v110;
  v115 = __ROR4__(v110, 2);
  v116 = v103 + 0x6ED9EBA1 + v112;
  v117 = v329 ^ v65 ^ v71 ^ v308;
  v118 = v271;
  v309 = __ROL4__(v117, 1);
  v119 = v309 + __ROL4__(v116, 5) + 0x6ED9EBA1 + (v113 ^ v114) + v106;
  v120 = v113 ^ v116 ^ v115;
  v299 = __ROL4__(v271 ^ v66 ^ v73 ^ v333, 1);
  v121 = __ROR4__(v116, 2);
  v122 = v299 + 0x6ED9EBA1 + __ROL4__(v119, 5) + v120 + v109;
  v123 = v119 ^ v121 ^ v115;
  v124 = __ROR4__(v119, 2);
  v279 = __ROL4__(v314 ^ v71 ^ v77 ^ v275, 1);
  v125 = v279 + 0x6ED9EBA1 + __ROL4__(v122, 5) + v123 + v113;
  v302 = __ROL4__(v309 ^ v317 ^ v73 ^ v293, 1);
  v126 = v302 + (v122 & v124 | v121 & (v122 | v124));
  v127 = __ROR4__(v122, 2);
  v128 = v115 + v126 + __ROL4__(v125, 5) - 0x70E44324;
  v129 = __ROL4__((unsigned int)v2 ^ v299 ^ v77 ^ v289, 1);
  v130 = v125 & v127 | v124 & (v125 | v127);
  v131 = __ROR4__(v125, 2);
  v294 = __ROL4__(v279 ^ v329 ^ v293 ^ v282, 1);
  v132 = v121 + v129 + v130 + __ROL4__(v128, 5) - 0x70E44324;
  v305 = v129;
  v296 = __ROL4__(v271 ^ v302 ^ v289 ^ v111, 1);
  v133 = v131 & v128 | v127 & (v131 | v128);
  v134 = __ROR4__(v128, 2);
  v136 = v132 & v134;
  v135 = v124 + v294 + v133 + __ROL4__(v132, 5) - 0x70E44324;
  v137 = v131 & (v132 | v134);
  v138 = __ROR4__(v132, 2);
  v139 = v127 + v296 + (v136 | v137) + __ROL4__(v135, 5) - 0x70E44324;
  v283 = __ROL4__(v314 ^ v129 ^ v282 ^ v333, 1);
  v140 = v135 & v138 | v134 & (v135 | v138);
  v141 = __ROR4__(v135, 2);
  v142 = v131 + v283 + v140 + __ROL4__(v139, 5) - 0x70E44324;
  v143 = __ROL4__(v309 ^ v294 ^ v111 ^ v275, 1);
  v144 = v299;
  v145 = v143 + (v139 & v141 | v138 & (v139 | v141));
  v146 = __ROR4__(v139, 2);
  v147 = v134 + v145 + __ROL4__(v142, 5) - 0x70E44324;
  v334 = __ROL4__(v317 ^ v299 ^ v296 ^ v333, 1);
  v148 = v142 & v146 | v141 & (v142 | v146);
  v149 = __ROR4__(v142, 2);
  v150 = v138 + v334 + v148 + __ROL4__(v147, 5) - 0x70E44324;
  v151 = v149 & v147;
  v276 = __ROL4__((unsigned int)v2 ^ v279 ^ v283 ^ v275, 1);
  v152 = v146 & (v149 | v147);
  v153 = __ROR4__(v147, 2);
  v154 = v276 + (v151 | v152);
  v155 = v150 & v153;
  v156 = v141 + v154 + __ROL4__(v150, 5) - 0x70E44324;
  v157 = v149 & (v150 | v153);
  v158 = __ROR4__(v150, 2);
  v272 = __ROL4__(v317 ^ v302 ^ v143 ^ v329, 1);
  v290 = __ROL4__((unsigned int)v2 ^ v118 ^ v305 ^ v334, 1);
  v159 = v146 + v272 + (v155 | v157) + __ROL4__(v156, 5) - 0x70E44324;
  v160 = v290 + (v156 & v158 | v153 & (v156 | v158));
  v161 = __ROR4__(v156, 2);
  v330 = __ROL4__(v314 ^ v294 ^ v276 ^ v329, 1);
  v162 = v149 + v160 + __ROL4__(v159, 5) - 0x70E44324;
  v163 = v159 & v161;
  v164 = v158 & (v159 | v161);
  v165 = __ROR4__(v159, 2);
  v320 = __ROL4__(v314 ^ v299 ^ v283 ^ v290, 1);
  v300 = __ROL4__(v309 ^ v118 ^ v296 ^ v272, 1);
  v287 = __ROL4__(v309 ^ v279 ^ v143 ^ v330, 1);
  v166 = v153 + v330 + (v163 | v164) + __ROL4__(v162, 5) - 0x70E44324;
  v167 = v162 & v165 | v161 & (v162 | v165);
  v168 = __ROR4__(v162, 2);
  v169 = v168 & v166;
  v170 = v158 + v300 + v167 + __ROL4__(v166, 5) - 0x70E44324;
  v171 = v168 | v166;
  v172 = __ROR4__(v166, 2);
  v173 = __ROL4__(v170, 5) + v320 + (v169 | v165 & v171) - 0x70E44324 + v161;
  LODWORD(v2) = v165 - 0x70E44324 + v287 + (v170 & v172 | v168 & (v170 | v172)) + __ROL4__(v173, 5);
  v174 = v302;
  v175 = __ROR4__(v170, 2);
  v303 = __ROL4__(v144 ^ v302 ^ v334 ^ v300, 1);
  v318 = __ROL4__(v279 ^ v305 ^ v276 ^ v320, 1);
  v176 = v173 & v175 | v172 & (v173 | v175);
  v177 = __ROR4__(v173, 2);
  v178 = v168 - 0x70E44324 + v303 + v176 + __ROL4__((_DWORD)v2, 5);
  v315 = __ROL4__(v174 ^ v294 ^ v272 ^ v287, 1);
  v306 = __ROL4__(v305 ^ v296 ^ v290 ^ v303, 1);
  v179 = (unsigned int)v2 & v177 | v175 & ((unsigned int)v2 | v177);
  LODWORD(v2) = __ROR4__((_DWORD)v2, 2);
  v180 = v172 - 0x70E44324 + v318 + v179 + __ROL4__(v178, 5);
  v181 = v283;
  v182 = v178 & (unsigned int)v2 | v177 & (v178 | (unsigned int)v2);
  v183 = __ROR4__(v178, 2);
  v184 = v183 & v180;
  v185 = v175 - 0x70E44324 + v315 + v182 + __ROL4__(v180, 5);
  v186 = (unsigned int)v2 & (v183 | v180);
  v187 = __ROR4__(v180, 2);
  v188 = v177 - 0x70E44324 + v306 + (v184 | v186) + __ROL4__(v185, 5);
  v189 = v272;
  v310 = __ROL4__(v294 ^ v283 ^ v330 ^ v318, 1);
  v190 = v185 & v187 | v183 & (v185 | v187);
  v191 = __ROR4__(v185, 2);
  v192 = v188 & v191;
  v193 = (_DWORD)v2 - 0x70E44324 + v310 + v190 + __ROL4__(v188, 5);
  v284 = __ROL4__(v296 ^ v143 ^ v300 ^ v315, 1);
  v194 = v187 & (v188 | v191);
  v195 = __ROR4__(v188, 2);
  v196 = v183 - 0x70E44324 + v284 + (v192 | v194) + __ROL4__(v193, 5);
  v197 = __ROL4__(v181 ^ v334 ^ v320 ^ v306, 1);
  v198 = v197 + (v193 ^ v195 ^ v191);
  v199 = __ROR4__(v193, 2);
  v200 = v187 + v198 + __ROL4__(v196, 5) - 0x359D3E2A;
  v312 = v197;
  v297 = __ROL4__(v143 ^ v276 ^ v287 ^ v310, 1);
  v335 = __ROL4__(v334 ^ v272 ^ v303 ^ v284, 1);
  v201 = v191 + v297 + (v196 ^ v199 ^ v195);
  v202 = __ROR4__(v196, 2);
  v203 = v201 + __ROL4__(v200, 5) - 0x359D3E2A;
  v204 = v335 + (v202 ^ v199 ^ v200);
  v205 = __ROR4__(v200, 2);
  v206 = v195 + v204 + __ROL4__(v203, 5) - 0x359D3E2A;
  v207 = v202 ^ v203 ^ v205;
  v208 = __ROR4__(v203, 2);
  v273 = __ROL4__(v276 ^ v290 ^ v318 ^ v197, 1);
  v280 = __ROL4__(v189 ^ v330 ^ v315 ^ v297, 1);
  v209 = v199 + v273 + v207 + __ROL4__(v206, 5) - 0x359D3E2A;
  *v327 = v280;
  v210 = v206 ^ v208 ^ v205;
  v211 = __ROR4__(v206, 2);
  v212 = v202 - 0x359D3E2A + v280 + v210 + __ROL4__(v209, 5);
  v213 = __ROL4__(v300 ^ v306 ^ v335 ^ v290, 1);
  v214 = v205 + v213 + (v209 ^ v211 ^ v208);
  v291 = v213;
  v327[1] = v213;
  v215 = __ROR4__(v209, 2);
  v216 = __ROL4__(v320 ^ v310 ^ v273 ^ v330, 1);
  v217 = v214 + __ROL4__(v212, 5) - 0x359D3E2A;
  v327[2] = v216;
  v331 = v216;
  v218 = v212 ^ v215 ^ v211;
  v219 = __ROR4__(v212, 2);
  v220 = __ROL4__(v217, 5) + v208 - 0x359D3E2A + v218 + v216;
  v221 = __ROL4__(v300 ^ v287 ^ v284 ^ v280, 1);
  v327[3] = v221;
  v222 = v221 + (v219 ^ v215 ^ v217);
  v223 = __ROR4__(v217, 2);
  v224 = __ROL4__(v320 ^ v303 ^ v197 ^ v291, 1);
  v327[4] = v224;
  v225 = v211 - 0x359D3E2A + v222 + __ROL4__(v220, 5);
  v226 = __ROL4__(v287 ^ v318 ^ v297 ^ v331, 1);
  v227 = v219 ^ v220 ^ v223;
  v228 = __ROR4__(v220, 2);
  v229 = v215 - 0x359D3E2A + v224 + v227 + __ROL4__(v225, 5);
  v327[5] = v226;
  v230 = __ROL4__(v303 ^ v315 ^ v335 ^ v221, 1);
  v231 = v225 ^ v228 ^ v223;
  v232 = __ROR4__(v225, 2);
  v233 = v219 - 0x359D3E2A + v226 + v231 + __ROL4__(v229, 5);
  v327[6] = v230;
  v288 = __ROL4__(v318 ^ v306 ^ v273 ^ v224, 1);
  v234 = v230 + (v229 ^ v232 ^ v228);
  v235 = __ROR4__(v229, 2);
  v236 = v223 + v234 + __ROL4__(v233, 5) - 0x359D3E2A;
  v327[7] = v288;
  v237 = v233 ^ v235 ^ v232;
  v238 = __ROR4__(v233, 2);
  v239 = v228 + v288 + v237 + __ROL4__(v236, 5) - 0x359D3E2A;
  v240 = v310 ^ v197 ^ v331 ^ v288;
  v241 = __ROL4__(v315 ^ v310 ^ v280 ^ v226, 1);
  v327[8] = v241;
  v242 = __ROL4__(v306 ^ v284 ^ v291 ^ v230, 1);
  v243 = v238 ^ v235 ^ v236;
  v244 = __ROR4__(v236, 2);
  v245 = __ROL4__(v240, 1);
  LODWORD(v2) = v232 + v241 + v243 - 0x359D3E2A + __ROL4__(v239, 5);
  v246 = __ROL4__(v284 ^ v297 ^ v221 ^ v241, 1);
  v327[9] = v242;
  v247 = v239 ^ v244;
  v248 = __ROR4__(v239, 2);
  v249 = v235 + v242 + (v238 ^ v247) + __ROL4__((_DWORD)v2, 5) - 0x359D3E2A;
  v250 = __ROL4__(v312 ^ v335 ^ v224 ^ v242, 1);
  v327[0xA] = v245;
  v251 = (unsigned int)v2 ^ v248 ^ v244;
  LODWORD(v2) = __ROR4__((_DWORD)v2, 2);
  v252 = v238 + v245 + v251 + __ROL4__(v249, 5) - 0x359D3E2A;
  v327[0xB] = v246;
  v253 = v249 ^ (unsigned int)v2 ^ v248;
  v254 = __ROR4__(v249, 2);
  v255 = v244 - 0x359D3E2A + v246 + v253 + __ROL4__(v252, 5);
  v327[0xC] = v250;
  v256 = v252 ^ v254 ^ (unsigned int)v2;
  v257 = __ROR4__(v252, 2);
  v258 = __ROL4__(v255, 5) + v250 + v256 - 0x359D3E2A + v248;
  v259 = __ROL4__(v297 ^ v273 ^ v226 ^ v245, 1);
  v327[0xD] = v259;
  v260 = (_DWORD)v2 + v259 - 0x359D3E2A + (v257 ^ v254 ^ v255);
  v261 = __ROR4__(v255, 2);
  v262 = v260 + __ROL4__(v258, 5);
  v263 = __ROL4__(v335 ^ v280 ^ v230 ^ v246, 1);
  v264 = __ROL4__(v273 ^ v291 ^ v288 ^ v250, 1);
  v327[0xE] = v263;
  v265 = v257 ^ v258 ^ v261;
  v266 = __ROR4__(v258, 2);
  v327[0xF] = v264;
  v267 = v254 + v263 + v265 - 0x359D3E2A + __ROL4__(v262, 5);
  *a1 = v257 - 0x359D3E2A + __ROL4__(v267, 5) + v264 + v321 + (v262 ^ v266 ^ v261);
  a1[2] = v323 + __ROR4__(v262, 2);
  a1[1] = v267 + v322;
  a1[3] = v266 + v324;
  result = (unsigned int)(v261 + v325);
  a1[4] = result;
  return result;
}

//----- (00000001400050FC) ----------------------------------------------------
__int64 __fastcall sub_1400050FC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx

  v4 = a2 - a1;
  ((void (__fastcall *)(__int64, __int64, __int64))loc_14006F000)(a3, a1, a2 - a1);
  return v4 + a3;
}

//----- (000000014000512C) ----------------------------------------------------
__int64 __fastcall sub_14000512C(_BYTE *a1, unsigned int a2, unsigned int a3)
{
  __int64 v3; // r9
  __int64 v4; // rax

  if ( a2 )
  {
    v3 = a2;
    do
    {
      v4 = (unsigned __int8)(a3 ^ *a1++);
      a3 = dword_1400B56A0[v4] ^ (a3 >> 8);
      --v3;
    }
    while ( v3 );
  }
  return a3;
}

//----- (000000014000515C) ----------------------------------------------------
__int64 __fastcall sub_14000515C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 _40, __int64 arg8, __int64 arg10, __int64 arg18)
{
  unsigned __int16 v9; // cx
  unsigned __int64 v10; // rax
  unsigned int v11; // ebx
  unsigned __int64 v12; // rsi
  int v13; // eax

  arg10 = a3;
  arg18 = a4;
  v9 = *(_WORD *)a1;
  if ( (v9 & 1) != 0 )
    return 0xC000000D;
  v10 = *(unsigned __int16 *)(a1 + 2);
  if ( (v10 & 1) != 0 )
    return 0xC000000D;
  if ( v9 > (unsigned __int16)v10 )
    return 0xC000000D;
  if ( (_WORD)v10 == 0xFFFF )
    return 0xC000000D;
  v11 = 0;
  if ( !*(_QWORD *)(a1 + 8) && (v9 || (_WORD)v10) )
    return 0xC000000D;
  v12 = v10 >> 1;
  sub_140005BC8(*(_QWORD *)(a1 + 8), v10 >> 1, a2, (__int64)&arg10);
  if ( v13 < 0 || v13 > v12 )
  {
    LOWORD(v13) = v12;
    v11 = 0x80000005;
  }
  *(_WORD *)a1 = 2 * v13;
  return v11;
}
// 1400051C6: variable 'v13' is possibly undefined

//----- (00000001400051F0) ----------------------------------------------------
bool __fastcall sub_1400051F0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // r9
  int v8[6]; // [rsp+30h] [rbp-50h] BYREF
  int v9[13]; // [rsp+48h] [rbp-38h] BYREF
  __int16 v10; // [rsp+7Ch] [rbp-4h]
  char v11; // [rsp+7Eh] [rbp-2h]

  v9[0] = 0x245C8948;
  v9[1] = 0x81485710;
  v9[2] = 0x110EC;
  v9[3] = 0x58B4800;
  v9[4] = 0xAAAAAAAA;
  v9[5] = 0x48C43348;
  v9[6] = 0x248489;
  v9[7] = 0x48000001;
  v9[8] = 0x5824948B;
  v9[9] = 0x4C000001;
  v9[0xA] = 0x6024948B;
  v9[0xB] = 0x48000001;
  v9[0xC] = 0x6824BC8B;
  v10 = 1;
  v11 = 0;
  v8[0] = 0x935DD62;
  v8[1] = 0x8CCE967E;
  v8[2] = 0x2F9A8F65;
  v8[3] = 0x6F4DCEA6;
  v8[4] = 0x676C5D07;
  qword_1400D85E0 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v8);
  if ( qword_1400D85E0 )
    return 1;
  if ( (unsigned int)sub_14004388C() != 0x1DB1 || !sub_14000A70C(0x45474150i64, &a6, &a5, v7) )
    return 0;
  qword_1400D85E8 = ((__int64 (__fastcall *)(__int64, _QWORD, int *, __int64))loc_140015A08)(
                      a6,
                      (unsigned int)a5,
                      v9,
                      0x37i64);
  return qword_1400D85E8 != 0;
}
// 1400052B6: variable 'v7' is possibly undefined
// 1400D85E0: using guessed type __int64 qword_1400D85E0;
// 1400D85E8: using guessed type __int64 qword_1400D85E8;

//----- (00000001400052F4) ----------------------------------------------------
__int64 __fastcall sub_1400052F4(__int64 *a1)
{
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // rax
  __int64 v6; // [rsp+20h] [rbp-1E8h]
  __int64 v7; // [rsp+A0h] [rbp-168h] BYREF
  char v8[240]; // [rsp+118h] [rbp-F0h] BYREF

  if ( !sub_1400591E8((unsigned __int16 *)a1 + 8, (__int64)&v7) )
    return 0xC000000Di64;
  if ( sub_140015378(*a1, (__int64)v8) )
  {
    v5 = sub_140014BD0(v3, 0x1000i64, v4, 0x40i64, v6);
    if ( v5 )
    {
      sub_140052288(v5, 0x1000i64);
      JUMPOUT(0x14000538Fi64);
    }
    ((void (__fastcall *)(__int64, char *))loc_140015528)(*a1, v8);
  }
  return 0xC0000001i64;
}
// 14000538A: control flows out of bounds to 14000538F
// 140005683: conditional instruction was optimized away because of 'rax.8==0'
// 14000536C: variable 'v3' is possibly undefined
// 14000536C: variable 'v4' is possibly undefined
// 14000536C: variable 'v6' is possibly undefined

//----- (0000000140005810) ----------------------------------------------------
bool __fastcall sub_140005810(__int64 a1)
{
  __int64 v1; // r14
  bool v3; // bl
  char v4; // di
  __int64 v5; // r9
  unsigned int v6; // edx
  unsigned __int64 v7; // rdi
  unsigned __int64 i; // r8
  int v9; // ecx
  char v10; // cl
  int v11; // eax
  char v12; // dl
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rdi
  bool v17; // al
  __int64 v18; // [rsp+20h] [rbp-79h]
  __int64 v19; // [rsp+28h] [rbp-71h]
  __int64 v20; // [rsp+30h] [rbp-69h]
  __int64 v21; // [rsp+38h] [rbp-61h]
  int v22; // [rsp+40h] [rbp-59h]
  int v23; // [rsp+44h] [rbp-55h]
  int v24; // [rsp+48h] [rbp-51h]
  int v25; // [rsp+4Ch] [rbp-4Dh]
  int v26; // [rsp+50h] [rbp-49h]
  int v27; // [rsp+54h] [rbp-45h]
  int v28; // [rsp+58h] [rbp-41h]
  int v29; // [rsp+5Ch] [rbp-3Dh]
  int v30; // [rsp+60h] [rbp-39h]
  int v31; // [rsp+64h] [rbp-35h]
  int v32; // [rsp+68h] [rbp-31h]
  int v33; // [rsp+6Ch] [rbp-2Dh]
  int v34; // [rsp+70h] [rbp-29h]
  __int16 v35; // [rsp+74h] [rbp-25h]
  char v36[122]; // [rsp+76h] [rbp-23h] BYREF

  v1 = a1 + 0x10;
  v3 = 0;
  v4 = 0;
  if ( !sub_140007090(a1 + 0x10, 0x1000u) )
    goto LABEL_6;
  v18 = 0x3BAAFDF871C1681Fi64;
  v35 = 0xCD52;
  v19 = 0x4574E66873CDDC39i64;
  v20 = 0xC13961CFF1684CDBui64;
  v21 = 0xC63248219B5E8DE3ui64;
  v22 = 0x2EAEEE22;
  v23 = 0xDBD28CDA;
  v24 = 0x5DE75A80;
  v25 = 0x54CCCFAA;
  v26 = 0xC42E070E;
  v27 = 0x2120F71E;
  v28 = 0xE9A7F37;
  v29 = 0x7968CD5A;
  v30 = 0x39B06BF0;
  v31 = 0x4F80C970;
  v32 = 0xF3BA9EB8;
  v33 = 0x7BE2D0D5;
  v34 = 0x12074A5C;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v36, 0i64, 0x56i64);
  v6 = 0x71926843;
  v7 = 0x54i64;
  for ( i = 0i64; i < 0x54; i += 4i64 )
  {
    v9 = *(_DWORD *)((char *)&v18 + i) ^ v6;
    v6 = __ROL4__(0x41C64E6D * v6 + 0x3039, 1);
    *(_DWORD *)&v36[i] = v9;
  }
  do
  {
    v10 = v6;
    v6 >>= 8;
    v36[v7] = *((_BYTE *)&v18 + v7) ^ v10;
    ++v7;
  }
  while ( v7 < 0x56 );
  v4 = 1;
  v11 = sub_14000515C(v1, (__int64)v36, __rdtsc(), v5, v18, v19, v20, v21);
  v12 = 0;
  if ( v11 < 0 )
LABEL_6:
    v12 = 1;
  if ( (v4 & 1) != 0 )
    memset(v36, 0, 0x56ui64);
  if ( v12 )
    return 0;
  v14 = ((__int64 (__fastcall *)(void *, __int64))loc_14004466C)(&unk_1400B5AE0, 0x69D0i64);
  v16 = v14;
  if ( v14 )
  {
    if ( sub_140059578(v1, v15, v14) )
    {
      *(_BYTE *)(a1 + 8) = 1;
      v17 = (int)sub_1400052F4((__int64 *)a1) >= 0;
      *(_BYTE *)(a1 + 9) = v17;
      v3 = v17;
    }
    ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(v16, 0i64, 0x69D0i64);
    sub_140051220(v16);
  }
  return v3;
}
// 140005980: variable 'v5' is possibly undefined
// 1400059C9: variable 'v15' is possibly undefined

//----- (0000000140005A18) ----------------------------------------------------
void __fastcall sub_140005A18(__int64 a1)
{
  if ( a1 )
  {
    if ( *(_BYTE *)(a1 + 8) )
      sub_1400590E8(a1 + 0x10);
    sub_14000724C(a1 + 0x10);
    if ( *(_QWORD *)a1 )
      ObfDereferenceObject(*(PVOID *)a1);
    JUMPOUT(0x140005A50i64);
  }
}
// 140005A4A: control flows out of bounds to 140005A50

//----- (0000000140005A68) ----------------------------------------------------
char __fastcall sub_140005A68(PVOID Object)
{
  char v1; // bp
  char v2; // r14
  unsigned __int64 v4; // rbx
  PVOID *v5; // rax
  char *v6; // rbx
  unsigned __int64 v7; // rax
  _QWORD *v8; // rcx
  char *v9; // rdi
  __int64 v10; // rax
  char result; // al

  v1 = 0;
  v2 = 0;
  if ( !Object || !byte_1400D83A0 )
    goto LABEL_20;
  ExAcquireFastMutex(&FastMutex);
  v4 = 0i64;
  v5 = (PVOID *)&unk_1400D83E0;
  while ( *v5 != Object )
  {
    ++v4;
    v5 += 4;
    if ( v4 >= 0x10 )
    {
      v6 = 0i64;
      goto LABEL_7;
    }
  }
  v6 = (char *)&unk_1400D83E0 + 0x20 * v4;
  if ( v6 )
  {
    v1 = v6[9];
    v9 = v6;
    goto LABEL_15;
  }
LABEL_7:
  v7 = 0i64;
  v8 = &unk_1400D83E0;
  while ( *v8 )
  {
    ++v7;
    v8 += 4;
    if ( v7 >= 0x10 )
    {
      v9 = 0i64;
      goto LABEL_14;
    }
  }
  v10 = 0x20 * v7;
  *(_QWORD *)((char *)&unk_1400D83E0 + v10 + 8) = 0i64;
  v9 = (char *)&unk_1400D83E0 + v10;
  *(_QWORD *)((char *)&unk_1400D83E0 + v10 + 0x10) = 0i64;
  *(_QWORD *)((char *)&unk_1400D83E0 + v10 + 0x18) = 0i64;
  *(_QWORD *)((char *)&unk_1400D83E0 + v10) = Object;
  if ( (_UNKNOWN *)((char *)&unk_1400D83E0 + v10) )
    goto LABEL_15;
LABEL_14:
  v2 = 1;
LABEL_15:
  ExReleaseFastMutex(&FastMutex);
  if ( v6 )
    return v1;
  if ( !v2 && (ObfReferenceObject(Object), sub_140005810((__int64)v9)) )
    result = 1;
  else
LABEL_20:
    result = 0;
  return result;
}
// 1400D83A0: using guessed type char byte_1400D83A0;

//----- (0000000140005B74) ----------------------------------------------------
void sub_140005B74()
{
  __int64 *v0; // rbx
  __int64 v1; // rdi

  if ( byte_1400D83A0 )
  {
    v0 = (__int64 *)&unk_1400D83E0;
    v1 = 0x10i64;
    do
    {
      if ( *v0 )
      {
        if ( *((_BYTE *)v0 + 9) )
          sub_1400052F4(v0);
        sub_140005A18((__int64)v0);
      }
      v0 += 4;
      --v1;
    }
    while ( v1 );
  }
}
// 1400D83A0: using guessed type char byte_1400D83A0;

//----- (0000000140005BC8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_140005BC8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  void (__fastcall *v4)(__int64, __int64, __int64, __int64); // rax
  int v9[8]; // [rsp+20h] [rbp-20h] BYREF

  v4 = (void (__fastcall *)(__int64, __int64, __int64, __int64))qword_1400D8208;
  if ( qword_1400D8208
    || (v9[0] = 0xCBAADC97,
        v9[1] = 0x5B1E10B,
        v9[2] = 0xEF4A7DB5,
        v9[3] = 0x8E767212,
        v9[4] = 0x580925A,
        v4 = (void (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(int *))loc_1400061CC)(v9),
        (qword_1400D8208 = (__int64)v4) != 0) )
  {
    v4(a1, a2, a3, a4);
  }
  JUMPOUT(0x140005C5Bi64);
}
// 140005C68: positive sp value 58 has been found
// 140005C56: control flows out of bounds to 140005C5B
// 1400D8208: using guessed type __int64 qword_1400D8208;

//----- (0000000140005EBC) ----------------------------------------------------
char __fastcall sub_140005EBC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v5; // bl
  _QWORD *v6; // rcx

  v5 = 0;
  v6 = (_QWORD *)(a1 + 0x30);
  if ( a3 == *(_QWORD *)(a4 + 8)
    && ((*(_QWORD *)a2 >> 0x10) & 0xFFFFFFFFFFFFFFF0ui64 | 0xFFFF000000000000ui64) + 0x30 == *(_QWORD *)a4 )
  {
    v5 = 1;
    *(_DWORD *)(a2 + 8) ^= (*(_DWORD *)(a2 + 8) ^ *(_DWORD *)(a4 + 0x10)) & 0x1FFFFFF;
  }
  _InterlockedExchangeAdd((volatile signed __int32 *)a2, 1u);
  if ( a1 && *v6 )
    qword_1400D85F0(v6, 0i64);
  return v5;
}
// 1400D85F0: using guessed type __int64 (__fastcall *qword_1400D85F0)(_QWORD, _QWORD);

//----- (00000001400064FC) ----------------------------------------------------
char __fastcall sub_1400064FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // rcx
  unsigned int *v8; // rdx
  __int64 v9; // rax
  __int64 v10; // rdx
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // rdx
  __int64 v15; // rcx
  __int64 v16; // r8
  __int64 v17; // r9
  __int64 v18; // rdx
  __int64 v19; // rcx
  __int64 v20; // r8
  __int64 v21; // r9
  ULONG v23; // [rsp+20h] [rbp-8h]

  v5 = sub_14000A0E4(a1, a2, a3, a4, v23);
  qword_1400D8610 = v5;
  v6 = v5;
  if ( v5 )
  {
    if ( sub_14005240C(v5, 0x1000ui64, 0i64, &a5)
      && (v7 = *(unsigned int *)(a5 + 0x88), (_DWORD)v7)
      && *(_DWORD *)(a5 + 0x8C)
      && (v8 = (unsigned int *)(v6 + v7), *(_DWORD *)(v6 + v7 + 0x14))
      && v8[8]
      && v8[7]
      && v8[9] )
    {
      qword_1400D8618 = v6 + v7;
      if ( v8 )
      {
        v9 = qword_1400D8610 + v8[8];
        byte_1400D83A1 = 1;
        qword_1400D8620 = v9;
        qword_1400D8628 = qword_1400D8610 + v8[7];
        qword_1400D8630 = qword_1400D8610 + v8[9];
        ((void (*)(void))loc_14005E218)();
        sub_140017F34(v11, v10, v12, v13);
        sub_14002C0B8(v15, v14, v16, v17);
        ((void (*)(void))loc_14000E728)();
        ((void (*)(void))loc_140043F0C)();
        ((void (*)(void))loc_140037FB0)();
        ((void (*)(void))loc_140047C28)();
        sub_140050F30();
        sub_14002AAC8(v19, v18, v20, v21);
        ((void (*)(void))loc_14005FFEC)();
        return 1;
      }
    }
    else
    {
      qword_1400D8618 = 0i64;
    }
  }
  return 0;
}
// 140006502: variable 'v23' is possibly undefined
// 1400065C1: variable 'v11' is possibly undefined
// 1400065C1: variable 'v10' is possibly undefined
// 1400065C1: variable 'v12' is possibly undefined
// 1400065C1: variable 'v13' is possibly undefined
// 1400065C6: variable 'v15' is possibly undefined
// 1400065C6: variable 'v14' is possibly undefined
// 1400065C6: variable 'v16' is possibly undefined
// 1400065C6: variable 'v17' is possibly undefined
// 1400065E4: variable 'v19' is possibly undefined
// 1400065E4: variable 'v18' is possibly undefined
// 1400065E4: variable 'v20' is possibly undefined
// 1400065E4: variable 'v21' is possibly undefined
// 1400D83A1: using guessed type char byte_1400D83A1;
// 1400D8610: using guessed type __int64 qword_1400D8610;
// 1400D8618: using guessed type __int64 qword_1400D8618;
// 1400D8620: using guessed type __int64 qword_1400D8620;
// 1400D8628: using guessed type __int64 qword_1400D8628;
// 1400D8630: using guessed type __int64 qword_1400D8630;

//----- (0000000140006604) ----------------------------------------------------
void __fastcall sub_140006604(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 i; // r9
  char v5; // cl
  char v6; // [rsp+20h] [rbp-19h] BYREF
  char v7[111]; // [rsp+21h] [rbp-18h] BYREF

  v6 = 0x80;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v7, 0i64, 0x47i64);
  v2 = *(_QWORD *)(a1 + 0x18);
  v3 = (-((_DWORD)v2 + 9) & 0x3F) + 1i64;
  for ( i = 0i64; i < 0x40; i += 8i64 )
  {
    v5 = 0x38 - i;
    *(&v6 + v3++) = (unsigned __int64)(8 * v2) >> v5;
  }
  sub_140006740(a1, (__int64)&v6, v3);
  JUMPOUT(0x14000667Fi64);
}
// 14000667D: control flows out of bounds to 14000667F

//----- (0000000140006740) ----------------------------------------------------
__int64 __fastcall sub_140006740(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rdi
  _BYTE *v7; // rdx
  __int64 v8; // rcx
  char v9; // al
  _BYTE *v10; // rcx
  char v11; // al
  char v13[64]; // [rsp+20h] [rbp-58h] BYREF

  v3 = 0i64;
  v4 = *(_QWORD *)(a1 + 0x18) & 0x3Fi64;
  *(_QWORD *)(a1 + 0x18) += a3;
  if ( v4 + a3 >= 0x40 )
  {
    if ( v4 )
    {
      v7 = (_BYTE *)(v4 + a1 + 0x20);
      v8 = 0x40 - v4;
      do
      {
        v9 = *(_BYTE *)(v3 + a2);
        ++v3;
        *v7++ = v9;
        --v8;
      }
      while ( v8 );
    }
    ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v13, 0i64, 0x40i64);
    JUMPOUT(0x140006812i64);
  }
  if ( a3 )
  {
    v10 = (_BYTE *)(v4 + a1 + 0x20);
    do
    {
      v11 = *(_BYTE *)(v3 + a2);
      ++v3;
      *v10++ = v11;
    }
    while ( v3 < a3 );
  }
  return a1;
}
// 14000680F: control flows out of bounds to 140006812
// 14000678B: conditional instruction was optimized away because of 'rdi.8 in (1..3F)'

//----- (0000000140006A18) ----------------------------------------------------
__int64 sub_140006A18()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  __int64 v2; // r8
  __int64 v3; // rax
  __int64 v4; // rax

  if ( !_InterlockedCompareExchange(&dword_1400D83A4, 1, 0) )
  {
    stru_1400D8648.Owner = 0i64;
    stru_1400D8648.Contention = 0;
    qword_1400D8640 = (__int64)&qword_1400D8638;
    qword_1400D8638 = (__int64)&qword_1400D8638;
    stru_1400D8648.Count = 1;
    KeInitializeEvent(&stru_1400D8648.Event, SynchronizationEvent, 0);
  }
  v0 = sub_140051084(0x80ui64);
  v1 = v0;
  if ( v0 )
  {
    *(_QWORD *)(v0 + 0x38) = 0i64;
    *(_DWORD *)(v0 + 0x40) = 0;
    *(_BYTE *)(v0 + 0x18) = 0;
    *(_QWORD *)(v0 + 0x20) = 0i64;
    *(_QWORD *)(v0 + 0x28) = 0i64;
    *(_DWORD *)(v0 + 0x30) = 1;
    KeInitializeEvent((PRKEVENT)(v0 + 0x48), SynchronizationEvent, 0);
    KeInitializeEvent((PRKEVENT)(v1 + 0x68), NotificationEvent, 0);
    LOBYTE(v2) = 1;
    v3 = ((__int64 (__fastcall *)(__int64 *, __int64, __int64))loc_140069850)(qword_1400068A0, v1, v2);
    *(_QWORD *)(v1 + 0x10) = v3;
    if ( v3 )
    {
      ExAcquireFastMutex(&stru_1400D8648);
      v4 = qword_1400D8638;
      if ( *(__int64 **)(qword_1400D8638 + 8) != &qword_1400D8638 )
        __fastfail(3u);
      *(_QWORD *)v1 = qword_1400D8638;
      *(_QWORD *)(v1 + 8) = &qword_1400D8638;
      *(_QWORD *)(v4 + 8) = v1;
      qword_1400D8638 = v1;
      ExReleaseFastMutex(&stru_1400D8648);
    }
    else
    {
      sub_140051220(v1);
      v1 = 0i64;
    }
  }
  return v1;
}
// 140006AD5: variable 'v2' is possibly undefined
// 1400068A0: using guessed type __int64 qword_1400068A0[47];
// 1400D83A4: using guessed type int dword_1400D83A4;
// 1400D8638: using guessed type __int64 qword_1400D8638;
// 1400D8640: using guessed type __int64 qword_1400D8640;

//----- (0000000140006B44) ----------------------------------------------------
void __fastcall sub_140006B44(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  char v7; // si
  unsigned __int64 v8; // r15
  _QWORD *v9; // rax
  __int64 v10; // rbx
  __int64 v11; // rax
  __int64 v12; // rcx

  v7 = 0;
  v8 = 0x2710 * (unsigned __int64)a4 / KeQueryTimeIncrement();
  if ( a1 )
  {
    if ( a2 )
    {
      v9 = (_QWORD *)sub_140051084(0x20ui64);
      v10 = (__int64)v9;
      if ( v9 )
      {
        v9[3] = 0i64;
        *v9 = a2;
        v9[1] = a3;
        v9[2] = v8 + MEMORY[0xFFFFF78000000320];
        ExAcquireFastMutex((PFAST_MUTEX)(a1 + 0x30));
        if ( *(_BYTE *)(a1 + 0x18) )
          goto LABEL_14;
        v11 = *(_QWORD *)(a1 + 0x20);
        v12 = 0i64;
        if ( !v11 )
          goto LABEL_11;
        do
        {
          if ( *(_QWORD *)(v11 + 0x10) >= *(_QWORD *)(v10 + 0x10) )
            break;
          v12 = v11;
          v11 = *(_QWORD *)(v11 + 0x18);
        }
        while ( v11 );
        if ( v12 )
        {
          *(_QWORD *)(v12 + 0x18) = v10;
          if ( !v11 )
          {
LABEL_13:
            v7 = 1;
LABEL_14:
            ExReleaseFastMutex((PFAST_MUTEX)(a1 + 0x30));
            if ( v7 )
              KeSetEvent((PRKEVENT)(a1 + 0x68), 0, 0);
            else
              sub_140051220(v10);
            return;
          }
        }
        else
        {
LABEL_11:
          *(_QWORD *)(a1 + 0x20) = v10;
        }
        *(_QWORD *)(v10 + 0x18) = v11;
        goto LABEL_13;
      }
    }
  }
}

//----- (0000000140006C58) ----------------------------------------------------
void __fastcall sub_140006C58(__int64 a1)
{
  __int64 v2; // rdx
  _QWORD *v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rcx

  if ( a1 )
  {
    ExAcquireFastMutex(&stru_1400D8648);
    v2 = *(_QWORD *)a1;
    v3 = *(_QWORD **)(a1 + 8);
    if ( *(_QWORD *)(*(_QWORD *)a1 + 8i64) != a1 || *v3 != a1 )
      __fastfail(3u);
    *v3 = v2;
    *(_QWORD *)(v2 + 8) = v3;
    ExReleaseFastMutex(&stru_1400D8648);
    *(_BYTE *)(a1 + 0x18) = 1;
    KeSetEvent((PRKEVENT)(a1 + 0x68), 0, 0);
    ((void (__fastcall *)(_QWORD))loc_140069B20)(*(_QWORD *)(a1 + 0x10));
    ExAcquireFastMutex((PFAST_MUTEX)(a1 + 0x30));
    v4 = *(_QWORD *)(a1 + 0x20);
    while ( v4 )
    {
      v5 = v4;
      v4 = *(_QWORD *)(v4 + 0x18);
      sub_140051220(v5);
    }
    ExReleaseFastMutex((PFAST_MUTEX)(a1 + 0x30));
    sub_140051220(a1);
  }
}

//----- (0000000140006E64) ----------------------------------------------------
char __fastcall sub_140006E64(__int64 a1)
{
  char v1; // dl

  v1 = 0;
  if ( a1 && *(_BYTE *)(a1 + 0x18) )
    v1 = 1;
  return v1;
}

//----- (0000000140006E78) ----------------------------------------------------
__int64 __fastcall sub_140006E78(_WORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 _50, __int64 _58, __int64 arg10, __int64 arg18)
{
  unsigned int v9; // edi
  unsigned __int64 v10; // rsi
  int v11; // eax

  arg18 = a4;
  if ( (unsigned __int64)(a2 - 1) <= 0x7FFFFFFE )
  {
    v10 = a2 - 1;
    v9 = 0;
    sub_140005BC8((__int64)a1, a2 - 1, a3, (__int64)&arg18);
    if ( v11 < 0 || v11 > v10 )
    {
      v9 = 0x80000005;
    }
    else if ( v11 != v10 )
    {
      return v9;
    }
    a1[v10] = 0;
    return v9;
  }
  v9 = 0xC000000D;
  if ( a2 )
    *a1 = 0;
  return v9;
}
// 140006EC0: variable 'v11' is possibly undefined

//----- (0000000140006EE4) ----------------------------------------------------
char __fastcall sub_140006EE4(__int64 a1)
{
  char result; // al

  result = 0;
  if ( !a1 || !*(_QWORD *)(a1 + 8) || !*(_WORD *)a1 || !*(_WORD *)(a1 + 2) )
    result = 1;
  return result;
}

//----- (0000000140006F00) ----------------------------------------------------
LONG __fastcall sub_140006F00(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  BOOLEAN v4; // r9
  PCUNICODE_STRING v5; // r10
  UNICODE_STRING String2; // [rsp+20h] [rbp-18h] BYREF

  LOBYTE(a4) = a3;
  ((void (__fastcall *)(UNICODE_STRING *, __int64, __int64, __int64))loc_140007050)(&String2, a2, a3, a4);
  return RtlCompareUnicodeString(v5, &String2, v4);
}
// 140006F1F: variable 'v5' is possibly undefined
// 140006F1F: variable 'v4' is possibly undefined

//----- (0000000140006F2C) ----------------------------------------------------
char __fastcall sub_140006F2C(char **a1, char *a2)
{
  char v2; // bl
  unsigned __int64 v3; // r8

  v2 = 0;
  if ( a1 )
  {
    if ( a1[1] )
    {
      v3 = *(unsigned __int16 *)a1;
      if ( (_WORD)v3 )
      {
        if ( a2 && sub_140007598(a1[1], a2, v3 >> 1) )
          v2 = 1;
      }
    }
  }
  return v2;
}

//----- (0000000140006F6C) ----------------------------------------------------
char __fastcall sub_140006F6C(__int16 *a1, __int16 *a2)
{
  __int64 v2; // rsi
  unsigned __int16 v3; // r8
  char *v4; // r11
  unsigned __int16 v5; // r9
  __int16 v6; // r9
  unsigned __int16 v7; // r10
  unsigned __int16 v8; // r8
  __int16 v9; // bx
  char *v10; // rdx
  signed __int64 v11; // rdi

  if ( !a1 )
    return 0;
  v2 = *((_QWORD *)a1 + 1);
  if ( !v2 )
    return 0;
  v3 = *a1;
  if ( !*a1 )
    return 0;
  if ( !a1[1] )
    return 0;
  if ( !a2 )
    return 0;
  v4 = (char *)*((_QWORD *)a2 + 1);
  if ( !v4 )
    return 0;
  v5 = *a2;
  if ( !*a2 || !a2[1] || v5 > v3 )
    return 0;
  v6 = v5 >> 1;
  v7 = 0;
  v8 = (v3 >> 1) - v6;
  while ( 1 )
  {
    v9 = 0;
    v10 = (char *)(v2 + 2i64 * v7);
    if ( (*(_WORD *)v10 | 0x20) == (*(_WORD *)v4 | 0x20) )
      break;
LABEL_15:
    if ( ++v7 > v8 )
      return 0;
  }
  v11 = v4 - v10;
  while ( 1 )
  {
    ++v9;
    v10 += 2;
    if ( v9 == v6 )
      return 1;
    if ( (*(_WORD *)v10 | 0x20) != (*(_WORD *)&v10[v11] | 0x20) )
      goto LABEL_15;
  }
}

//----- (0000000140007090) ----------------------------------------------------
char __fastcall sub_140007090(__int64 a1, unsigned __int16 a2)
{
  __int64 v4; // rax
  char result; // al

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v4 = sub_140051084(a2);
  *(_QWORD *)(a1 + 8) = v4;
  if ( !v4 )
    return 0;
  *(_WORD *)(a1 + 2) = a2;
  result = 1;
  *(_WORD *)a1 = 0;
  return result;
}

//----- (00000001400070E0) ----------------------------------------------------
char __fastcall sub_1400070E0(__int64 a1, __int64 a2)
{
  char v2; // bl
  unsigned __int64 v5; // rdi
  unsigned __int64 v6; // rdi
  __int64 v7; // rax

  v2 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v5 = 0xFFFFFFFFFFFFFFFFui64;
      do
        ++v5;
      while ( *(_WORD *)(a2 + 2 * v5) );
      v6 = 2 * v5 + 2;
      if ( v6 < 0xFFFF )
      {
        v7 = sub_140051084(v6);
        *(_QWORD *)(a1 + 8) = v7;
        if ( v7 )
        {
          ((void (__fastcall *)(__int64, _QWORD, unsigned __int64))loc_14006F2C0)(v7, 0i64, v6);
          ((void (__fastcall *)(_QWORD, __int64, unsigned __int64))loc_14006F000)(*(_QWORD *)(a1 + 8), a2, v6);
          *(_WORD *)(a1 + 2) = v6;
          v2 = 1;
          *(_WORD *)a1 = v6 - 2;
        }
      }
    }
  }
  return v2;
}

//----- (0000000140007178) ----------------------------------------------------
char __fastcall sub_140007178(__int64 a1, unsigned __int16 *a2, unsigned __int16 a3)
{
  unsigned int v3; // esi
  __int64 v6; // rax
  __int64 v7; // rcx

  v3 = a3;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !*((_QWORD *)a2 + 1) )
    return 0;
  if ( !*a2 )
    return 0;
  if ( !a2[1] )
    return 0;
  if ( a3 < *a2 )
    return 0;
  v6 = sub_140051084(a3);
  *(_QWORD *)(a1 + 8) = v6;
  if ( !v6 )
    return 0;
  ((void (__fastcall *)(__int64, _QWORD, _QWORD))loc_14006F2C0)(v6, 0i64, v3);
  v7 = *(_QWORD *)(a1 + 8);
  *(_WORD *)a1 = *a2;
  *(_WORD *)(a1 + 2) = v3;
  ((void (__fastcall *)(__int64, _QWORD, _QWORD))loc_14006F000)(v7, *((_QWORD *)a2 + 1), *a2);
  return 1;
}

//----- (000000014000721C) ----------------------------------------------------
char __fastcall sub_14000721C(__int64 a1, __int64 a2)
{
  char result; // al

  result = 0;
  if ( a1 && a2 && *(_QWORD *)(a2 + 8) && *(_WORD *)a2 )
  {
    if ( *(_WORD *)(a2 + 2) )
      result = sub_140007178(a1, (unsigned __int16 *)a2, *(_WORD *)a2);
  }
  return result;
}

//----- (000000014000724C) ----------------------------------------------------
void __fastcall sub_14000724C(__int64 a1)
{
  __int64 v1; // rcx

  if ( a1 )
  {
    v1 = *(_QWORD *)(a1 + 8);
    if ( v1 )
    {
      sub_140051220(v1);
      JUMPOUT(0x140007267i64);
    }
  }
}
// 140007262: control flows out of bounds to 140007267

//----- (0000000140007274) ----------------------------------------------------
__int64 __fastcall sub_140007274(unsigned __int16 *a1, unsigned __int16 *a2, __int64 a3, __int64 a4, ULONG BytesInUnicodeString)
{
  unsigned __int64 v7; // rcx
  WCHAR *v9; // rax
  NTSTATUS v10; // eax
  __int64 v11; // rcx

  if ( !a1 || !a2 )
    return 0xC000000Di64;
  v7 = 2i64 * *a2 + 2;
  if ( v7 > 0xFFFF )
    return 0xC00000F0i64;
  a1[1] = v7;
  *a1 = v7 - 2;
  v9 = (WCHAR *)sub_140051084(v7);
  *((_QWORD *)a1 + 1) = v9;
  if ( !v9 )
    return 0xC0000017i64;
  v10 = RtlMultiByteToUnicodeN(v9, *a1, &BytesInUnicodeString, *((const CHAR **)a2 + 1), *a2);
  v11 = *((_QWORD *)a1 + 1);
  if ( v10 < 0 )
  {
    sub_140051220(v11);
    JUMPOUT(0x140007302i64);
  }
  *(_WORD *)(v11 + 2 * ((unsigned __int64)BytesInUnicodeString >> 1)) = 0;
  *a1 = BytesInUnicodeString;
  return 0i64;
}
// 1400072FD: control flows out of bounds to 140007302

//----- (0000000140007338) ----------------------------------------------------
__int64 __fastcall sub_140007338(unsigned __int16 *a1, __int64 a2)
{
  __int64 v3; // rdx
  unsigned __int64 v4; // rcx
  unsigned __int64 v5; // rsi
  __int64 v7; // r14
  unsigned __int16 v8[12]; // [rsp+20h] [rbp-18h] BYREF

  if ( a2 )
  {
    ((void (__fastcall *)(unsigned __int16 *))loc_140007050)(v8);
    v4 = *a1;
    v5 = v8[0];
    if ( (unsigned int)v4 + v8[0] > a1[1] )
      return 0xC0000023i64;
    v7 = *((_QWORD *)a1 + 1) + 2 * (v4 >> 1);
    ((void (__fastcall *)(__int64, __int64, _QWORD))loc_14006F000)(v7, v3, v8[0]);
    *a1 += v5;
    if ( a1[1] >= (unsigned __int64)*a1 + 2 )
      *(_WORD *)(v7 + 2 * (v5 >> 1)) = 0;
  }
  return 0i64;
}
// 140007394: variable 'v3' is possibly undefined

//----- (00000001400073D4) ----------------------------------------------------
__int64 __fastcall sub_1400073D4(unsigned __int16 *a1, unsigned __int16 *a2)
{
  unsigned __int64 v2; // rsi
  unsigned int v4; // ecx
  unsigned __int64 v5; // r14

  v2 = *a2;
  v4 = *a1;
  v5 = *((_QWORD *)a1 + 1) + 2 * ((unsigned __int64)v4 >> 1);
  if ( (_WORD)v2 )
  {
    if ( (unsigned int)v2 + v4 > a1[1] )
      return 0xC0000023i64;
    ((void (__fastcall *)(unsigned __int64, _QWORD, unsigned __int64))loc_14006F000)(v5, *((_QWORD *)a2 + 1), v2);
    *a1 += v2;
    if ( a1[1] >= (unsigned __int64)*a1 + 2 )
      *(_WORD *)(v5 + 2 * (v2 >> 1)) = 0;
  }
  return 0i64;
}

//----- (000000014000746C) ----------------------------------------------------
unsigned __int64 __fastcall sub_14000746C(__int64 a1, __int64 a2, unsigned __int16 *a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 v4; // r10

  if ( !a1 || !a2 || !a3 || !*((_QWORD *)a3 + 1) || !*a3 || !a3[1] )
    return 0i64;
  result = 0i64;
  v4 = (unsigned __int64)*a3 >> 1;
  if ( v4 )
  {
    do
    {
      if ( result >= a2 - 1 )
        break;
      *(_WORD *)(a1 + 2 * result) = *(_WORD *)(*((_QWORD *)a3 + 1) + 2 * result);
      ++result;
    }
    while ( result < v4 );
  }
  *(_WORD *)(a1 + 2 * result) = 0;
  return result;
}

//----- (00000001400074D4) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400074D4(__int64 a1, __int64 a2, unsigned __int16 *a3)
{
  unsigned __int64 result; // rax
  unsigned __int64 v4; // r10

  if ( !a1 || !a2 || !a3 || !*((_QWORD *)a3 + 1) || !*a3 || !a3[1] )
    return 0i64;
  result = 0i64;
  v4 = (unsigned __int64)*a3 >> 1;
  if ( v4 )
  {
    do
    {
      if ( result >= a2 - 1 )
        break;
      *(_BYTE *)(result + a1) = *(_BYTE *)(*((_QWORD *)a3 + 1) + 2 * result);
      ++result;
    }
    while ( result < v4 );
  }
  *(_BYTE *)(result + a1) = 0;
  return result;
}

//----- (0000000140007538) ----------------------------------------------------
char __fastcall sub_140007538(__int64 a1, _BYTE *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r10
  char v4; // r9
  __int64 v5; // r11

  v3 = 0i64;
  v4 = 1;
  if ( a3 )
  {
    v5 = a1 - (_QWORD)a2;
    while ( (a2[v5] | 0x20) == (*a2 | 0x20) )
    {
      if ( a2[v5] || *a2 )
      {
        ++v3;
        ++a2;
        if ( v3 < a3 )
          continue;
      }
      return v4;
    }
    v4 = 0;
  }
  return v4;
}

//----- (0000000140007598) ----------------------------------------------------
char *__fastcall sub_140007598(char *a1, char *a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // r9
  signed __int64 v5; // r10
  _WORD *v6; // r11
  unsigned __int64 v7; // rbx
  unsigned __int16 v8; // dx
  __int16 v9; // ax

  v4 = 0i64;
  if ( a3 )
  {
    v5 = a2 - a1;
    do
    {
      if ( !*(_WORD *)a1 )
        break;
      v6 = a1;
      v7 = v4;
      if ( v4 < a3 )
      {
        v8 = *(_WORD *)a2;
        do
        {
          v9 = *v6++ | 0x20;
          if ( v9 != (v8 | 0x20) )
            break;
          v8 = *(_WORD *)((char *)v6 + v5);
          if ( !v8 )
            return a1;
        }
        while ( ++v7 < a3 );
      }
      ++v4;
      a1 += 2;
      v5 -= 2i64;
    }
    while ( v4 < a3 );
  }
  return 0i64;
}

//----- (000000014000761C) ----------------------------------------------------
_BYTE *__fastcall sub_14000761C(_BYTE *a1, unsigned __int8 *a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // r9
  __int64 v5; // r10
  _BYTE *v6; // r11
  unsigned __int64 v7; // rbx
  unsigned __int8 v8; // dl
  char v9; // al

  v3 = 0i64;
  if ( a3 )
  {
    v5 = a2 - a1;
    do
    {
      if ( !*a1 )
        break;
      v6 = a1;
      v7 = v3;
      if ( v3 < a3 )
      {
        v8 = *a2;
        do
        {
          v9 = *v6++ | 0x20;
          if ( v9 != (v8 | 0x20) )
            break;
          v8 = v6[v5];
          if ( !v8 )
            return a1;
        }
        while ( ++v7 < a3 );
      }
      ++v3;
      ++a1;
      --v5;
    }
    while ( v3 < a3 );
  }
  return 0i64;
}

//----- (0000000140007688) ----------------------------------------------------
__int64 __fastcall sub_140007688(__int64 a1, unsigned __int64 a2)
{
  unsigned __int64 i; // r8
  int v3; // er9
  __int64 result; // rax

  for ( i = 0i64; i < a2; ++i )
  {
    v3 = *(unsigned __int16 *)(a1 + 2 * i);
    result = (unsigned int)(v3 - 0x41);
    if ( (unsigned __int16)(v3 - 0x41) <= 0x19u )
      *(_WORD *)(a1 + 2 * i) = v3 | 0x20;
  }
  return result;
}

//----- (00000001400076B4) ----------------------------------------------------
__int64 __fastcall sub_1400076B4(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 v4; // r9
  unsigned __int64 v5; // rcx
  unsigned __int64 v6; // rdx
  __int64 result; // rax

  if ( a1 && a3 )
  {
    v4 = 0xFFFFFFFFFFFFFFFFui64;
    do
      ++v4;
    while ( *(_BYTE *)(a3 + v4) );
    v5 = 0i64;
    v6 = a2 - 1;
    if ( v6 )
    {
      do
      {
        if ( v5 >= v4 )
          break;
        result = (unsigned int)*(char *)(v5 + a3);
        *(_WORD *)(a1 + 2 * v5) = *(char *)(v5 + a3);
        ++v5;
      }
      while ( v5 < v6 );
    }
    *(_WORD *)(a1 + 2 * v5) = 0;
  }
  return result;
}

//----- (00000001400076F8) ----------------------------------------------------
char __fastcall sub_1400076F8(__int64 a1, __int64 a2, __int64 a3)
{
  char v3; // di
  unsigned __int64 v4; // rbx
  void *v8; // rax

  v3 = 0;
  v4 = a3 + 1;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( v4 < 0xFFFF )
      {
        v8 = (void *)sub_140051084(a3 + 1);
        *(_QWORD *)(a1 + 8) = v8;
        if ( v8 )
        {
          memset(v8, 0, v4);
          ((void (__fastcall *)(_QWORD, __int64, __int64))loc_14006F000)(*(_QWORD *)(a1 + 8), a2, a3);
          *(_WORD *)(a1 + 2) = v4;
          v3 = 1;
          *(_WORD *)a1 = v4 - 1;
        }
      }
    }
  }
  return v3;
}

//----- (0000000140007788) ----------------------------------------------------
char __fastcall sub_140007788(__int64 a1, __int16 *a2, unsigned __int16 a3)
{
  unsigned int v3; // ebp
  void *v6; // rax
  __int16 v7; // r8
  __int64 v8; // rdx
  __int64 v9; // rcx

  v3 = a3;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !*((_QWORD *)a2 + 1) )
    return 0;
  if ( !*a2 )
    return 0;
  if ( !a2[1] )
    return 0;
  if ( a3 < (unsigned __int16)*a2 )
    return 0;
  v6 = (void *)sub_140051084(a3);
  *(_QWORD *)(a1 + 8) = v6;
  if ( !v6 )
    return 0;
  v7 = *a2;
  v8 = *((_QWORD *)a2 + 1);
  memset(v6, 0, v3);
  v9 = *(_QWORD *)(a1 + 8);
  *(_WORD *)a1 = v7;
  *(_WORD *)(a1 + 2) = v3;
  ((void (__fastcall *)(__int64, __int64))loc_14006F000)(v9, v8);
  return 1;
}

//----- (0000000140007824) ----------------------------------------------------
unsigned __int8 *__fastcall sub_140007824(_DWORD *a1, unsigned __int8 *a2, int a3)
{
  int v3; // ebp
  unsigned __int8 *v4; // rbx
  int v5; // er10
  _DWORD *v6; // rdi
  int v7; // er9
  int v8; // esi
  int v9; // ecx
  int v10; // ecx
  int v11; // edx
  int v12; // edx
  int v13; // er8
  int v14; // er8
  int v15; // er9
  int v16; // er10
  int v17; // er10
  int v18; // ecx
  int v19; // ecx
  int v20; // edx
  int v21; // edx
  int v22; // er15
  int v23; // er8
  int v24; // er13
  int v25; // er9
  int v26; // er10
  int v27; // er10
  int v28; // er14
  int v29; // er11
  int v30; // er12
  int v31; // ecx
  int v32; // er8
  int v33; // esi
  int v34; // ecx
  int v35; // edx
  unsigned __int8 *v36; // r10
  int v37; // ebp
  int v38; // edx
  int v39; // er8
  int v40; // ebx
  int v41; // er9
  int v42; // edi
  int v43; // ecx
  int v44; // edx
  int v45; // er8
  int v46; // er9
  int v47; // ecx
  int v48; // edx
  int v49; // er8
  int v50; // er9
  int v51; // ecx
  int v52; // edx
  int v53; // er11
  int v54; // er8
  int v55; // er9
  int v56; // edx
  int v57; // er8
  int v58; // er9
  int v59; // er11
  int v60; // edx
  int v61; // er8
  int v62; // er9
  int v63; // er11
  int v64; // er8
  int v65; // er9
  int v66; // edx
  int v67; // ecx
  int v68; // er8
  int v69; // er9
  int v70; // edx
  int v71; // ecx
  int v72; // er8
  int v73; // er9
  int v74; // edx
  int v75; // ecx
  int v76; // er8
  int v77; // er9
  int v78; // edx
  int v79; // ebp
  int v80; // esi
  int v81; // er9
  int v82; // eax
  int v83; // er9
  int v84; // eax
  int v86; // [rsp+0h] [rbp-78h]
  int v87; // [rsp+4h] [rbp-74h]
  int v88; // [rsp+8h] [rbp-70h]
  int v89; // [rsp+Ch] [rbp-6Ch]
  int v90; // [rsp+10h] [rbp-68h]
  int v91; // [rsp+14h] [rbp-64h]
  int v92; // [rsp+18h] [rbp-60h]
  int v93; // [rsp+1Ch] [rbp-5Ch]
  int v94; // [rsp+20h] [rbp-58h]
  int v95; // [rsp+24h] [rbp-54h]
  int v96; // [rsp+28h] [rbp-50h]
  _DWORD *v97; // [rsp+80h] [rbp+8h]
  unsigned __int8 *v98; // [rsp+88h] [rbp+10h]
  int v100; // [rsp+98h] [rbp+20h]

  v98 = a2;
  v97 = a1;
  v3 = a1[2];
  v4 = a2;
  v5 = a1[3];
  v6 = a1;
  v7 = a1[4];
  v8 = a1[5];
  while ( 1 )
  {
    v95 = v7;
    v93 = v3;
    v9 = *v4 | ((v4[1] | (*((unsigned __int16 *)v4 + 1) << 8)) << 8);
    v94 = v5;
    v6[0x16] = v9;
    v100 = v9;
    v96 = v8;
    v10 = v5 + __ROL4__(v3 + (v8 ^ v5 & (v7 ^ v8)) - 0x28955B88 + v9, 7);
    v11 = v4[4] | ((v4[5] | ((v4[6] | (v4[7] << 8)) << 8)) << 8);
    v6[0x17] = v11;
    v88 = v11;
    v12 = v10 + __ROL4__(v8 + (v7 ^ v10 & (v5 ^ v7)) - 0x173848AA + v11, 0xC);
    v13 = v4[8] | ((v4[9] | ((v4[0xA] | (v4[0xB] << 8)) << 8)) << 8);
    v6[0x18] = v13;
    v92 = v13;
    v14 = v12 + __ROR4__(v13 + (v5 ^ v12 & (v10 ^ v5)) + v7 + 0x242070DB, 0xF);
    v87 = v4[0xC] | ((v4[0xD] | (*((unsigned __int16 *)v4 + 7) << 8)) << 8);
    v6[0x19] = v87;
    v15 = v14 + __ROR4__(v5 + (v10 ^ v14 & (v10 ^ v12)) - 0x3E423112 + v87, 0xA);
    v16 = v4[0x10] | ((v4[0x11] | (*((unsigned __int16 *)v4 + 9) << 8)) << 8);
    v6[0x1A] = v16;
    v90 = v16;
    v17 = v15 + __ROL4__(v16 + (v12 ^ v15 & (v14 ^ v12)) + v10 - 0xA83F051, 7);
    v18 = v4[0x14] | ((v4[0x15] | (*((unsigned __int16 *)v4 + 0xB) << 8)) << 8);
    v6[0x1B] = v18;
    v86 = v18;
    v19 = v17 + __ROL4__(v18 + (v14 ^ v17 & (v15 ^ v14)) + v12 + 0x4787C62A, 0xC);
    v20 = v4[0x18] | ((v4[0x19] | (*((unsigned __int16 *)v4 + 0xD) << 8)) << 8);
    v6[0x1C] = v20;
    v89 = v20;
    v21 = v19 + __ROR4__(v14 + (v15 ^ v19 & (v17 ^ v15)) - 0x57CFB9ED + v20, 0xF);
    v22 = v4[0x1C] | ((v4[0x1D] | ((v4[0x1E] | (v4[0x1F] << 8)) << 8)) << 8);
    v6[0x1D] = v22;
    v23 = v21 + __ROR4__(v22 + (v17 ^ v21 & (v17 ^ v19)) + v15 - 0x2B96AFF, 0xA);
    v24 = v4[0x20] | ((v4[0x21] | (*((unsigned __int16 *)v4 + 0x11) << 8)) << 8);
    v6[0x1E] = v24;
    v25 = v23 + __ROL4__(v24 + (v19 ^ v23 & (v21 ^ v19)) + v17 + 0x698098D8, 7);
    v26 = v4[0x24] | ((v4[0x25] | (*((unsigned __int16 *)v4 + 0x13) << 8)) << 8);
    v6[0x1F] = v26;
    v91 = v26;
    v27 = v25 + __ROL4__(v19 + (v21 ^ v25 & (v23 ^ v21)) - 0x74BB0851 + v26, 0xC);
    v28 = v4[0x28] | ((v4[0x29] | ((v4[0x2A] | (v4[0x2B] << 8)) << 8)) << 8);
    v6[0x20] = v28;
    v29 = v27 + __ROR4__(v21 + v28 + (v23 ^ v27 & (v25 ^ v23)) - 0xA44F, 0xF);
    v30 = v4[0x2C] | ((v4[0x2D] | (*((unsigned __int16 *)v4 + 0x17) << 8)) << 8);
    v6[0x21] = v30;
    v31 = v23 + v30 + (v25 ^ v29 & (v25 ^ v27)) - 0x76A32842;
    v32 = v27 - 0x2678E6D;
    v33 = v4[0x30] | ((v4[0x31] | (*((unsigned __int16 *)v4 + 0x19) << 8)) << 8);
    v6[0x22] = v33;
    v34 = v29 + __ROR4__(v31, 0xA);
    v35 = v27 ^ v34 & (v29 ^ v27);
    v36 = v98;
    v37 = v4[0x34] | ((v4[0x35] | (*((unsigned __int16 *)v4 + 0x1B) << 8)) << 8);
    v6[0x23] = v37;
    v38 = v34 + __ROL4__(v25 + v33 + v35 + 0x6B901122, 7);
    v39 = v38 + __ROL4__(v37 + (v29 ^ v38 & (v34 ^ v29)) + v32, 0xC);
    v40 = v36[0x38] | ((v36[0x39] | ((v36[0x3A] | (v4[0x3B] << 8)) << 8)) << 8);
    v6[0x24] = v40;
    v41 = v39 + __ROR4__(v29 + v40 + (v34 ^ v39 & (v38 ^ v34)) - 0x5986BC72, 0xF);
    v42 = v36[0x3C] | ((v36[0x3D] | (*((unsigned __int16 *)v36 + 0x1F) << 8)) << 8);
    v97[0x25] = v42;
    v43 = v41 + __ROR4__(v42 + (v38 ^ v41 & (v38 ^ v39)) + 0x49B40821 + v34, 0xA);
    v44 = v43 + __ROL4__(v88 + (v41 ^ v39 & (v43 ^ v41)) - 0x9E1DA9E + v38, 5);
    v45 = v44 + __ROL4__(v89 + (v43 ^ v41 & (v44 ^ v43)) - 0x3FBF4CC0 + v39, 9);
    v46 = v45 + __ROL4__(v30 + (v44 ^ v43 & (v44 ^ v45)) + 0x265E5A51 + v41, 0xE);
    LODWORD(v36) = v46 + __ROR4__(v100 + (v45 ^ v44 & (v46 ^ v45)) + v43 - 0x16493856, 0xC);
    v47 = (_DWORD)v36 + __ROL4__(v86 + (v46 ^ v45 & ((unsigned int)v36 ^ v46)) + v44 - 0x29D0EFA3, 5);
    v48 = v47 + __ROL4__(v28 + ((unsigned int)v36 ^ v46 & (v47 ^ (unsigned int)v36)) + v45 + 0x2441453, 9);
    v49 = v48 + __ROL4__(v42 + (v47 ^ (unsigned int)v36 & (v47 ^ v48)) + v46 - 0x275E197F, 0xE);
    v50 = v49 + __ROR4__(v90 + (v48 ^ v47 & (v49 ^ v48)) + (_DWORD)v36 - 0x182C0438, 0xC);
    LODWORD(v36) = v50 + __ROL4__(v91 + (v49 ^ v48 & (v50 ^ v49)) + v47 + 0x21E1CDE6, 5);
    v51 = (_DWORD)v36 + __ROL4__(v40 + (v50 ^ v49 & ((unsigned int)v36 ^ v50)) + v48 - 0x3CC8F82A, 9);
    v52 = v51 + __ROL4__(v87 + ((unsigned int)v36 ^ v50 & ((unsigned int)v36 ^ v51)) + v49 - 0xB2AF279, 0xE);
    v53 = v52 + __ROR4__(v24 + (v51 ^ (unsigned int)v36 & (v52 ^ v51)) + v50 + 0x455A14ED, 0xC);
    v54 = v53 + __ROL4__(v37 + (v52 ^ v51 & (v53 ^ v52)) + (_DWORD)v36 - 0x561C16FB, 5);
    v55 = v54 + __ROL4__(v92 + (v53 ^ v52 & (v54 ^ v53)) + v51 - 0x3105C08, 9);
    LODWORD(v36) = v55 + __ROL4__(v22 + (v54 ^ v53 & (v54 ^ v55)) + v52 + 0x676F02D9, 0xE);
    v56 = (_DWORD)v36 + __ROR4__(v33 + (v55 ^ v54 & ((unsigned int)v36 ^ v55)) + v53 - 0x72D5B376, 0xC);
    v57 = v56 + __ROL4__(v86 + (v56 ^ (unsigned int)v36 ^ v55) - 0x5C6BE + v54, 4);
    v58 = v57 + __ROL4__(v24 + (v57 ^ v56 ^ (unsigned int)v36) - 0x788E097F + v55, 0xB);
    LODWORD(v36) = v58 + __ROL4__(v30 + (v57 ^ v56 ^ v58) + 0x6D9D6122 + (_DWORD)v36, 0x10);
    v59 = (_DWORD)v36 + __ROR4__(v40 + (v57 ^ (unsigned int)v36 ^ v58) + v56 - 0x21AC7F4, 9);
    v60 = v59 + __ROL4__(v88 + (v59 ^ (unsigned int)v36 ^ v58) + v57 - 0x5B4115BC, 4);
    v61 = v60 + __ROL4__(v90 + (v60 ^ v59 ^ (unsigned int)v36) + v58 + 0x4BDECFA9, 0xB);
    v62 = v61 + __ROL4__(v22 + (v60 ^ v59 ^ v61) + (_DWORD)v36 - 0x944B4A0, 0x10);
    LODWORD(v36) = v62 + __ROR4__(v28 + (v60 ^ v62 ^ v61) + v59 - 0x41404390, 9);
    v63 = (_DWORD)v36 + __ROL4__(v37 + ((unsigned int)v36 ^ v62 ^ v61) + v60 + 0x289B7EC6, 4);
    v64 = v63 + __ROL4__(v100 + (v63 ^ (unsigned int)v36 ^ v62) - 0x155ED806 + v61, 0xB);
    v65 = v64 + __ROL4__(v87 + (v63 ^ (unsigned int)v36 ^ v64) - 0x2B10CF7B + v62, 0x10);
    v66 = v65 + __ROR4__(v89 + (v63 ^ v65 ^ v64) + (_DWORD)v36 + 0x4881D05, 9);
    LODWORD(v36) = v66 + __ROL4__(v63 + v91 + (v66 ^ v65 ^ v64) - 0x262B2FC7, 4);
    v67 = (_DWORD)v36 + __ROL4__(v33 + ((unsigned int)v36 ^ v66 ^ v65) + v64 - 0x1924661B, 0xB);
    v68 = v67 + __ROL4__(v42 + ((unsigned int)v36 ^ v66 ^ v67) + v65 + 0x1FA27CF8, 0x10);
    v69 = v68 + __ROR4__(v92 + ((unsigned int)v36 ^ v68 ^ v67) + v66 - 0x3B53A99B, 9);
    v70 = v69 + __ROL4__(v100 + (v68 ^ (v69 | ~v67)) + (_DWORD)v36 - 0xBD6DDBC, 6);
    LODWORD(v36) = v70 + __ROL4__(v22 + (v69 ^ (v70 | ~v68)) + v67 + 0x432AFF97, 0xA);
    v71 = (_DWORD)v36 + __ROL4__(v40 + (v70 ^ ((unsigned int)v36 | ~v69)) + v68 - 0x546BDC59, 0xF);
    v72 = v71 + __ROR4__(v86 + ((unsigned int)v36 ^ (v71 | ~v70)) + v69 - 0x36C5FC7, 0xB);
    v73 = v72 + __ROL4__(v33 + (v71 ^ (v72 | ~(_DWORD)v36)) + v70 + 0x655B59C3, 6);
    v74 = v73 + __ROL4__(v87 + (v72 ^ (v73 | ~v71)) + (_DWORD)v36 - 0x70F3336E, 0xA);
    LODWORD(v36) = v74 + __ROL4__(v28 + (v73 ^ (v74 | ~v72)) + v71 - 0x100B83, 0xF);
    v75 = (_DWORD)v36 + __ROR4__(v88 + (v74 ^ ((unsigned int)v36 | ~v73)) + v72 - 0x7A7BA22F, 0xB);
    v76 = v75 + __ROL4__(v24 + ((unsigned int)v36 ^ (v75 | ~v74)) + v73 + 0x6FA87E4F, 6);
    v77 = v76 + __ROL4__(v42 + (v75 ^ (v76 | ~(_DWORD)v36)) + v74 - 0x1D31920, 0xA);
    v78 = v77 + __ROL4__(v89 + (v76 ^ (v77 | ~v75)) + (_DWORD)v36 - 0x5CFEBCEC, 0xF);
    LODWORD(v36) = v78 + __ROR4__(v75 + v37 + (v77 ^ (v78 | ~v76)) + 0x4E0811A1, 0xB);
    v79 = (_DWORD)v36 + __ROL4__(v76 + v90 + (v78 ^ ((unsigned int)v36 | ~v77)) - 0x8AC817E, 6);
    v80 = v79 + __ROL4__(v30 + ((unsigned int)v36 ^ (v79 | ~v78)) + v77 - 0x42C50DCB, 0xA);
    v81 = v79 ^ (v80 | ~(_DWORD)v36);
    v82 = v79;
    v3 = v93 + v79;
    v4 = v98 + 0x40;
    v83 = v80 + __ROL4__(v78 + v92 + v81 + 0x2AD7D2BB, 0xF);
    v98 += 0x40;
    v84 = v80 ^ (v83 | ~v82);
    v8 = v96 + v80;
    LODWORD(v36) = v83 + __ROR4__(v91 + v84 + (_DWORD)v36 - 0x14792C6F, 0xB);
    v7 = v95 + v83;
    v5 = v94 + (_DWORD)v36;
    a3 -= 0x40;
    if ( !a3 )
      break;
    v6 = v97;
  }
  v97[2] = v3;
  v97[3] = v5;
  v97[4] = v7;
  v97[5] = v8;
  return v4;
}

//----- (00000001400082A0) ----------------------------------------------------
#error "1400082FD: positive sp value has been found (funcsize=91)"

//----- (000000014000835C) ----------------------------------------------------
#error "140008397: positive sp value has been found (funcsize=120)"

//----- (00000001400084A4) ----------------------------------------------------
void sub_1400084A4()
{
  struct _UNICODE_STRING DestinationString; // [rsp+20h] [rbp-48h] BYREF
  __int64 v1; // [rsp+38h] [rbp-30h]

  RtlInitUnicodeString(&DestinationString, L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat");
  v1 = 0i64;
  JUMPOUT(0x1400084C5i64);
}
// 1400084C0: control flows out of bounds to 1400084C5

//----- (00000001400086EC) ----------------------------------------------------
char __fastcall sub_1400086EC(PVOID ValueData, __int64 a2, __int64 a3, __int64 a4, int a5, int a6, int a7, __int64 a8)
{
  __int64 v9; // rax
  __int64 v10; // rdi
  unsigned int (__fastcall *v11)(__int64); // rax
  struct _KPROCESS *v12; // rax
  unsigned __int64 v13; // r14
  unsigned __int64 v14; // r15
  ULONG64 v15; // rcx
  __int64 v16; // rdx
  ULONG64 v17; // rbx
  unsigned __int64 i; // rcx
  __int64 v19; // rsi
  ULONG64 v20; // rdi
  unsigned __int64 v21; // rax
  __int64 v22; // rax
  unsigned int v23; // eax
  ULONG64 v25; // [rsp+30h] [rbp-88h]
  __int64 v26; // [rsp+38h] [rbp-80h] BYREF
  __int64 v27; // [rsp+40h] [rbp-78h] BYREF
  __int64 v28; // [rsp+48h] [rbp-70h] BYREF
  __int64 v29; // [rsp+50h] [rbp-68h] BYREF
  __int64 v30; // [rsp+58h] [rbp-60h] BYREF
  __int64 v31; // [rsp+60h] [rbp-58h] BYREF
  __int64 v32; // [rsp+68h] [rbp-50h] BYREF
  __int64 v33[9]; // [rsp+70h] [rbp-48h] BYREF

  LOBYTE(v9) = 0;
  HIDWORD(a8) = 0;
  v26 = 0i64;
  v27 = 0i64;
  v28 = 0i64;
  v29 = 0i64;
  v30 = 0i64;
  v31 = 0i64;
  v32 = 0i64;
  if ( ValueData )
  {
    v9 = sub_140048808();
    if ( v9 == *((_QWORD *)ValueData + 1) )
    {
      v10 = sub_140048808();
      v11 = (unsigned int (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                    qword_1400DAE68,
                                                    &qword_1400DAE68,
                                                    0i64);
      LODWORD(v9) = v11 ? v11(v10) : 0xC0000002;
      a6 = v9;
      if ( (_DWORD)v9 || *((_DWORD *)ValueData + 0x87) )
      {
        a8 = MEMORY[0xFFFFF78000000014];
        v12 = IoGetCurrentProcess();
        v33[0] = PsGetProcessCreateTimeQuadPart(v12);
        a7 = sub_14000A840(*((_QWORD *)ValueData + 6));
        a5 = *((_DWORD *)ValueData + 4);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameState",
          4u,
          (char *)ValueData + 0x21C,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashGameID",
          4u,
          ValueData,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashPID",
          4u,
          &a5,
          4u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashCreateTime",
          0xBu,
          v33,
          8u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashExitTime",
          0xBu,
          &a8,
          8u);
        RtlWriteRegistryValue(
          0,
          L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
          L"ErrRpt_GameCrashExitStatus",
          4u,
          &a6,
          4u);
        LOBYTE(v9) = RtlWriteRegistryValue(
                       0,
                       L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                       L"ErrRpt_GameCrashInfo01",
                       4u,
                       &a7,
                       4u);
        v13 = *((_QWORD *)ValueData + 0x17);
        v14 = v13 + *((_QWORD *)ValueData + 0x18);
        v15 = *((_QWORD *)ValueData + 0x2C);
        if ( v15 )
        {
          LOBYTE(v9) = sub_14005221C(v15, 0x3Ci64, 1);
          v16 = *((_QWORD *)ValueData + 0x2C);
          v17 = 0i64;
          v25 = 0i64;
          if ( v16 )
          {
            for ( i = 0i64; ; ++i )
            {
              v33[1] = i;
              if ( i >= 8 )
                break;
              LOBYTE(v9) = *(_BYTE *)(v16 + 4 * i + 0x1C) ^ 0x90;
              *((_BYTE *)&v25 + i) = v9;
              v17 = v25;
            }
          }
          if ( v17 )
          {
            LOBYTE(v9) = sub_14005221C(v17, 0x28i64, 1);
            v19 = *(_QWORD *)(v17 + 0x18);
            v20 = *(_QWORD *)(v17 + 0x20);
            if ( v19 )
            {
              LOBYTE(v9) = sub_14005221C(*(_QWORD *)(v17 + 0x18), 0x40i64, 1);
              if ( *(_DWORD *)v19 )
              {
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo02",
                  4u,
                  (PVOID)(v19 + 0xC),
                  4u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo03",
                  0xBu,
                  (PVOID)(v19 + 0x10),
                  8u);
                v21 = *(_QWORD *)(v19 + 0x10);
                if ( v21 <= v13 || v21 > v14 )
                  v22 = 0i64;
                else
                  v22 = v21 - v13;
                v26 = v22;
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo04",
                  0xBu,
                  &v26,
                  8u);
                if ( *(_DWORD *)(v19 + 0x1C) )
                  v27 = *(_QWORD *)(v19 + 0x20);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo05",
                  0xBu,
                  &v27,
                  8u);
                if ( *(_DWORD *)(v19 + 0x1C) >= 2u )
                  v28 = *(_QWORD *)(v19 + 0x28);
                LOBYTE(v9) = RtlWriteRegistryValue(
                               0,
                               L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                               L"ErrRpt_GameCrashInfo06",
                               0xBu,
                               &v28,
                               8u);
              }
            }
            if ( v20 )
            {
              LOBYTE(v9) = sub_14005221C(v20, 0x34i64, 1);
              if ( *(_DWORD *)v20 )
              {
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo07",
                  4u,
                  (PVOID)(v20 + 0xC),
                  4u);
                v23 = *(_DWORD *)(v20 + 0x10);
                if ( v23 )
                {
                  v29 = *(_QWORD *)(v20 + 0x14);
                  v23 = *(_DWORD *)(v20 + 0x10);
                }
                if ( v23 >= 2 )
                {
                  v30 = *(_QWORD *)(v20 + 0x1C);
                  v23 = *(_DWORD *)(v20 + 0x10);
                }
                if ( v23 >= 3 )
                {
                  v31 = *(_QWORD *)(v20 + 0x24);
                  v23 = *(_DWORD *)(v20 + 0x10);
                }
                if ( v23 >= 4 )
                  v32 = *(_QWORD *)(v20 + 0x2C);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo08",
                  0xBu,
                  &v29,
                  8u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo09",
                  0xBu,
                  &v30,
                  8u);
                RtlWriteRegistryValue(
                  0,
                  L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                  L"ErrRpt_GameCrashInfo10",
                  0xBu,
                  &v31,
                  8u);
                LOBYTE(v9) = RtlWriteRegistryValue(
                               0,
                               L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat",
                               L"ErrRpt_GameCrashInfo11",
                               0xBu,
                               &v32,
                               8u);
              }
            }
          }
        }
      }
    }
  }
  return v9;
}
// 1400DAE68: using guessed type __int64 qword_1400DAE68;

//----- (0000000140008BAC) ----------------------------------------------------
NTSTATUS sub_140008BAC()
{
  return RtlDeleteRegistryValue(0, L"\\Registry\\Machine\\Software\\Wow6432Node\\EasyAntiCheat", L"ErrRpt_ServiceState");
}
// 14006F3C0: using guessed type wchar_t aErrrptServices[20];

//----- (0000000140008E4C) ----------------------------------------------------
#error "140008E65: call analysis failed (funcsize=45)"

//----- (000000014000A0C0) ----------------------------------------------------
char sub_14000A0C0()
{
  char v0; // cl

  if ( !KeAreApcsDisabled() || (v0 = 1, !KeGetCurrentIrql()) )
    v0 = 0;
  return v0;
}

//----- (000000014000A0E4) ----------------------------------------------------
__int64 __fastcall sub_14000A0E4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ULONG SystemInformation)
{
  _QWORD *v5; // rax
  _QWORD *v6; // rbx

  SystemInformation = 0;
  if ( !qword_1400D81C0
    && ZwQuerySystemInformation(SystemModuleInformation, &SystemInformation, 0, &SystemInformation) == 0xC0000004 )
  {
    if ( SystemInformation )
    {
      v5 = ExAllocatePoolWithTag(NonPagedPool, SystemInformation, 0x6D4D6D53u);
      v6 = v5;
      if ( v5 )
      {
        if ( ZwQuerySystemInformation(SystemModuleInformation, v5, SystemInformation, &SystemInformation) >= 0
          && *(_DWORD *)v6 )
        {
          qword_1400D81C0 = v6[3];
        }
        ExFreePoolWithTag(v6, 0x6D4D6D53u);
      }
    }
  }
  return qword_1400D81C0;
}
// 1400D81C0: using guessed type __int64 qword_1400D81C0;

//----- (000000014000A180) ----------------------------------------------------
__int64 __fastcall sub_14000A180(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  _DWORD *v4; // rax
  unsigned int v6; // [rsp+20h] [rbp-8h]

  v4 = (_DWORD *)sub_14002D72C(a1, a2, a3, a4, v6);
  if ( v4 )
  {
    if ( *v4 )
      dword_1400D81B8 = v4[8];
    sub_140051220((__int64)v4);
  }
  return (unsigned int)dword_1400D81B8;
}
// 14000A184: variable 'v6' is possibly undefined
// 1400D81B8: using guessed type int dword_1400D81B8;

//----- (000000014000A1B0) ----------------------------------------------------
__int64 __fastcall sub_14000A1B0(CHAR *a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  unsigned __int64 v6; // rax
  _DWORD *v7; // rax
  _DWORD *v8; // rdi
  int v9; // esi
  _DWORD *v10; // rbp
  CHAR *v11; // rcx
  unsigned __int64 v12; // rax
  STRING String2; // [rsp+20h] [rbp-28h] BYREF
  STRING String1; // [rsp+30h] [rbp-18h] BYREF

  v4 = 0i64;
  if ( !a1 )
    return 0i64;
  String1.Buffer = a1;
  v6 = 0xFFFFFFFFFFFFFFFFui64;
  do
    ++v6;
  while ( a1[v6] );
  String1.Length = v6;
  String1.MaximumLength = v6 + 1;
  v7 = (_DWORD *)sub_14002D72C((__int64)a1, a2, a3, a4, *(unsigned int *)&String2.Length);
  v8 = v7;
  if ( v7 )
  {
    v9 = 0;
    if ( *v7 )
    {
      while ( 1 )
      {
        v10 = &v8[0x4A * v9];
        if ( *((_QWORD *)v10 + 3) >= (unsigned __int64)MmSystemRangeStart )
        {
          v11 = (char *)v10 + *((unsigned __int16 *)v10 + 0x17) + 0x30;
          String2.Buffer = v11;
          if ( v11 )
          {
            v12 = 0xFFFFFFFFFFFFFFFFui64;
            do
              ++v12;
            while ( v11[v12] );
            String2.Length = v12;
            String2.MaximumLength = v12 + 1;
          }
          else
          {
            *(_DWORD *)&String2.Length = 0;
          }
          if ( !RtlCompareString(&String1, &String2, 1u) )
            break;
        }
        if ( (unsigned int)++v9 >= *v8 )
          goto LABEL_17;
      }
      v4 = *((_QWORD *)v10 + 3);
    }
LABEL_17:
    sub_140051220((__int64)v8);
  }
  return v4;
}

//----- (000000014000A70C) ----------------------------------------------------
char __fastcall sub_14000A70C(__int64 a1, _QWORD *a2, _QWORD *a3, __int64 a4)
{
  char v4; // bl
  __int64 v8; // r8
  __int64 v9; // rcx
  unsigned __int64 v10; // r9
  __int64 v11; // rdx
  unsigned __int64 v12; // rax
  __int64 v13; // rcx
  ULONG v15; // [rsp+20h] [rbp-8h]

  v4 = 0;
  if ( !a2 )
    return 0;
  if ( !a3 )
    return 0;
  *a2 = 0i64;
  *a3 = 0i64;
  v8 = sub_14000A0E4(a1, (__int64)a2, (__int64)a3, a4, v15);
  if ( !v8 )
    return 0;
  if ( *(_WORD *)v8 != 0x5A4D )
    return 0;
  v9 = v8 + *(int *)(v8 + 0x3C);
  if ( *(_DWORD *)v9 != 0x4550 )
    return 0;
  v10 = *(unsigned __int16 *)(v9 + 6);
  v11 = *(unsigned __int16 *)(v9 + 0x14) + v9 + 0x18;
  v12 = 0i64;
  if ( *(_WORD *)(v9 + 6) )
  {
    while ( 1 )
    {
      v13 = *(unsigned int *)(v11 + 0xC);
      if ( (_DWORD)v13 )
      {
        if ( *(_DWORD *)(v11 + 8) && *(_QWORD *)v11 == a1 )
          break;
      }
      ++v12;
      v11 += 0x28i64;
      if ( v12 >= v10 )
        return v4;
    }
    v4 = 1;
    *a2 = v8 + v13;
    *a3 = *(unsigned int *)(v11 + 8);
  }
  return v4;
}
// 14000A73B: variable 'v15' is possibly undefined

//----- (000000014000A7C4) ----------------------------------------------------
char __fastcall sub_14000A7C4(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // bl
  __int64 v6; // rdx
  __int64 v7; // rcx
  unsigned __int64 v8; // rsi
  __int64 v9; // r8
  __int64 v10; // r9
  unsigned int v11; // eax
  ULONG v13; // [rsp+20h] [rbp-8h]

  v4 = 0;
  if ( a1 )
  {
    v8 = sub_14000A0E4(a1, a2, a3, a4, v13);
    if ( v8 )
    {
      v11 = sub_14000A180(v7, v6, v9, v10);
      if ( v11 )
      {
        if ( a1 >= v8 && a1 < v8 + v11 )
          v4 = 1;
      }
    }
  }
  return v4;
}
// 14000A7DD: variable 'v13' is possibly undefined
// 14000A7EA: variable 'v7' is possibly undefined
// 14000A7EA: variable 'v6' is possibly undefined
// 14000A7EA: variable 'v9' is possibly undefined
// 14000A7EA: variable 'v10' is possibly undefined

//----- (000000014000A818) ----------------------------------------------------
NTSTATUS __fastcall sub_14000A818(int a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, union _LARGE_INTEGER Interval)
{
  Interval.QuadPart = (int)(0xFFFFD8F0 * a1);
  return KeDelayExecutionThread(0, 0, &Interval);
}

//----- (000000014000A840) ----------------------------------------------------
__int64 __fastcall sub_14000A840(__int64 a1)
{
  __int64 v1; // rbx

  v1 = MEMORY[0xFFFFF78000000320];
  return (v1 * KeQueryTimeIncrement() - a1) / 0x2710;
}

//----- (000000014000A890) ----------------------------------------------------
__int64 __fastcall sub_14000A890(int a1, int a2)
{
  unsigned __int64 v2; // rax
  int v3; // er8
  unsigned int v5; // ecx

  LODWORD(v2) = dword_1400D81A8;
  v3 = 0;
  if ( !dword_1400D81A8 )
    v2 = __rdtsc();
  dword_1400D81A8 = 0x343FD * v2 + 0x269EC3;
  if ( a1 != a2 )
  {
    v5 = ((dword_1400D81A8 ^ (unsigned int)(dword_1400D81A8 << 0xD)) >> 0x11) ^ dword_1400D81A8 ^ (dword_1400D81A8 << 0xD);
    v3 = (v5 ^ (unsigned __int64)(0x20 * v5)) % (unsigned int)(a2 - a1);
  }
  return (unsigned int)(v3 + a1);
}
// 1400D81A8: using guessed type int dword_1400D81A8;

//----- (000000014000A8E8) ----------------------------------------------------
void __fastcall sub_14000A8E8(_BYTE *a1, __int64 a2)
{
  unsigned __int64 v2; // r9
  _BYTE *v3; // r8
  unsigned __int64 v4; // rax
  __int64 v5; // rax

  v2 = (unsigned __int64)&a1[a2];
  v3 = a1;
  if ( a1 && a2 && (unsigned __int64)a1 < v2 )
  {
    do
    {
      v4 = __rdtsc();
      if ( (unsigned __int64)&v3[-v2] < 4 )
      {
        *v3 = v4;
        v5 = 1i64;
      }
      else
      {
        *(_DWORD *)v3 = v4;
        v5 = 4i64;
      }
      v3 += v5;
    }
    while ( (unsigned __int64)v3 < v2 );
  }
}

//----- (000000014000A930) ----------------------------------------------------
__int64 __fastcall sub_14000A930(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 (__fastcall *v5)(unsigned int *); // rax
  __int64 result; // rax
  int v7[8]; // [rsp+20h] [rbp-20h] BYREF

  a5 = sub_14000A890(0, 0xFFFFFFFF);
  v5 = (__int64 (__fastcall *)(unsigned int *))qword_1400D81A0;
  if ( qword_1400D81A0
    || (v7[0] = 0xBB906C8A,
        v7[1] = 0x4FF32641,
        v7[2] = 0xA0D6F6C4,
        v7[3] = 0xCB529DB6,
        v7[4] = 0xD171D5C5,
        v5 = (__int64 (__fastcall *)(unsigned int *))((__int64 (__fastcall *)(int *))loc_1400061CC)(v7),
        (qword_1400D81A0 = (__int64)v5) != 0) )
  {
    result = v5(&a5);
  }
  else
  {
    result = a5;
  }
  return result;
}
// 1400D81A0: using guessed type __int64 qword_1400D81A0;

//----- (000000014000A99C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_14000A99C()
{
  JUMPOUT(0x14000A9ADi64);
}
// 14000AAB9: positive sp value 8 has been found
// 14000A9AB: control flows out of bounds to 14000A9AD

//----- (000000014000AABC) ----------------------------------------------------
char __fastcall sub_14000AABC(__int64 a1, __int64 a2)
{
  int v3; // [rsp+20h] [rbp-40h] BYREF
  __int64 v4; // [rsp+28h] [rbp-38h]
  int v5; // [rsp+30h] [rbp-30h]
  int v6; // [rsp+34h] [rbp-2Ch]
  __int16 v7; // [rsp+44h] [rbp-1Ch]
  int v8; // [rsp+56h] [rbp-Ah]

  if ( !a1 || !a2 )
    return 0;
  *(_DWORD *)a2 = 0;
  *(_QWORD *)(a2 + 8) = 0i64;
  v3 = 0;
  v4 = 0i64;
  if ( sub_140007090((__int64)&v3, 0x100u) )
  {
    v5 = 0x45550753;
    v7 = 0x3705;
    v6 = 0x443FA485;
    v8 = 0;
    JUMPOUT(0x14000AB34i64);
  }
  return 0;
}
// 14000AB31: control flows out of bounds to 14000AB34

//----- (000000014000AC3C) ----------------------------------------------------
char sub_14000AC3C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  __int64 v5; // rdx
  char v7[24]; // [rsp+20h] [rbp-18h] BYREF
  va_list va; // [rsp+40h] [rbp+8h] BYREF

  va_start(va, a4);
  if ( !a1 || !a2 )
    return 0;
  if ( sub_14000AABC(a1, (__int64)v7) )
  {
    sub_14002C384((__int64)v7, v5, a2, (__int64)va);
    JUMPOUT(0x14000AC84i64);
  }
  return 0;
}
// 14000AC7F: control flows out of bounds to 14000AC84
// 14000AC70: variable 'v5' is possibly undefined

//----- (000000014000ACA0) ----------------------------------------------------
char __fastcall sub_14000ACA0(struct _FILE_OBJECT *a1, __int64 a2, __int64 a3, __int64 a4, POBJECT_NAME_INFORMATION ObjectNameInformation)
{
  char v5; // bl
  POBJECT_NAME_INFORMATION v7; // rcx
  char v8; // al

  v5 = 0;
  if ( !a1 || !a2 )
    return 0;
  if ( IoQueryFileDosDeviceName(a1, &ObjectNameInformation) >= 0 )
  {
    v7 = ObjectNameInformation;
    if ( ObjectNameInformation && ObjectNameInformation->Name.Buffer && ObjectNameInformation->Name.Length )
    {
      if ( ObjectNameInformation->Name.MaximumLength )
      {
        v8 = sub_140007178(a2, &ObjectNameInformation->Name.Length, ObjectNameInformation->Name.Length);
        v7 = ObjectNameInformation;
        v5 = v8;
      }
    }
    ExFreePoolWithTag(v7, 0);
  }
  return v5;
}

//----- (000000014000AD14) ----------------------------------------------------
char __fastcall sub_14000AD14(PFILE_OBJECT FileObject, __int64 a2, __int64 a3, __int64 a4, PFLT_FILE_NAME_INFORMATION FileNameInformation)
{
  char v5; // bl
  struct _FLT_FILE_NAME_INFORMATION *v8; // rcx
  UNICODE_STRING *v9; // rdx
  char v10; // al

  v5 = 0;
  if ( !FileObject || !a2 || KeGetCurrentIrql() > 1u || IoGetTopLevelIrp() )
    return 0;
  if ( FltGetFileNameInformationUnsafe(FileObject, 0i64, 0x101u, &FileNameInformation) >= 0
    || FltGetFileNameInformationUnsafe(FileObject, 0i64, 0x102u, &FileNameInformation) >= 0 )
  {
    v8 = FileNameInformation;
    v9 = &FileNameInformation->Name;
    if ( FileNameInformation != (PFLT_FILE_NAME_INFORMATION)0xFFFFFFFFFFFFFFF8i64
      && FileNameInformation->Name.Buffer
      && v9->Length )
    {
      if ( FileNameInformation->Name.MaximumLength )
      {
        v10 = sub_140007178(a2, &v9->Length, v9->Length);
        v8 = FileNameInformation;
        v5 = v10;
      }
    }
    FltReleaseFileNameInformation(v8);
  }
  return v5;
}

//----- (000000014000ADD4) ----------------------------------------------------
char __fastcall sub_14000ADD4(__int64 a1, __int64 a2)
{
  __int64 v2; // rdi
  unsigned __int16 v4; // r8
  unsigned __int16 v5; // dx
  __int64 v6; // r8
  unsigned __int16 v8; // cx
  __int64 v9; // rdx
  _WORD *v10; // rcx
  _WORD *v11; // rax

  v2 = 0i64;
  if ( !a1 )
    return 0;
  if ( !*(_QWORD *)(a1 + 8) )
    return 0;
  v4 = *(_WORD *)a1;
  if ( !*(_WORD *)a1
    || !*(_WORD *)(a1 + 2)
    || v4 > 0xFFEFu
    || !a2
    || !sub_140007178(a2, (unsigned __int16 *)a1, v4 + 0x10) )
  {
    return 0;
  }
  v5 = *(_WORD *)a2;
  if ( *(_WORD *)a2 >= 8u )
  {
    v6 = *(_QWORD *)(a2 + 8);
    if ( *(_QWORD *)v6 == 0x5C003F005C005Ci64 )
    {
      *(_WORD *)(v6 + 2) = 0x3F;
      return 1;
    }
  }
  v8 = 0;
  if ( (v5 & 0xFFFE) != 0 )
  {
    do
    {
      v9 = *(_QWORD *)(a2 + 8);
      if ( *(_WORD *)(v9 + 2i64 * v8) == 0x2F )
        *(_WORD *)(v9 + 2i64 * v8) = 0x5C;
      v5 = *(_WORD *)a2;
      ++v8;
    }
    while ( v8 < (unsigned __int16)(*(_WORD *)a2 >> 1) );
  }
  if ( v5 >= 8u )
  {
    if ( **(_QWORD **)(a2 + 8) == 0x5C002E005C005Ci64 )
    {
      do
      {
        *(_WORD *)(v2 + *(_QWORD *)(a2 + 8) + 2) = 0x3F;
        v2 += 2i64;
      }
      while ( v2 < 4 );
      return 1;
    }
    goto LABEL_21;
  }
  if ( v5 >= 4u )
  {
LABEL_21:
    v10 = *(_WORD **)(a2 + 8);
    if ( *v10 == 0x5C && v10[1] == 0x5C )
    {
      ((void (__fastcall *)(_WORD *, _WORD *, __int64))loc_14006F000)(v10 + 8, v10 + 2, v5 - 4i64);
      JUMPOUT(0x14000AF07i64);
    }
LABEL_26:
    v11 = *(_WORD **)(a2 + 8);
    if ( *v11 != 0x5C && *v11 != 0x2E && v5 >= 3u && v11[1] == 0x3A && v11[2] == 0x5C )
    {
      ((void (__fastcall *)(_WORD *, _QWORD, _QWORD, __int64))loc_14006F000)(v11 + 4, *(_QWORD *)(a2 + 8), v5, 4i64);
      **(_QWORD **)(a2 + 8) = 0x5C003F003F005Ci64;
      *(_WORD *)a2 += 8;
      return 1;
    }
    goto LABEL_32;
  }
  if ( v5 >= 2u )
    goto LABEL_26;
LABEL_32:
  sub_14000724C(a2);
  return 0;
}
// 14000AF02: control flows out of bounds to 14000AF07

//----- (000000014000AF90) ----------------------------------------------------
bool __fastcall sub_14000AF90(__int64 a1, __int64 a2, __int64 a3, __int64 a4, char a5, int *a6, char *a7)
{
  int v7; // edx
  unsigned __int64 v8; // rdi
  unsigned int v9; // edx
  unsigned __int64 v10; // rdi
  unsigned int v11; // edx
  unsigned __int64 v12; // r8
  unsigned __int64 v13; // rdi
  int v14; // ecx
  char v15; // cl
  unsigned int v16; // edx
  unsigned __int64 v17; // rdi
  unsigned int v18; // edx
  unsigned __int64 v19; // rdi
  int v20; // ecx
  unsigned __int64 v21; // rdi
  char v22; // cl
  unsigned int v23; // edx
  unsigned __int64 v24; // rdi
  unsigned int v25; // edx
  unsigned __int64 v26; // rdi
  int v27; // ecx
  unsigned __int64 v28; // rdi
  char v29; // cl
  unsigned int v30; // edx
  unsigned __int64 v31; // rdi
  int v32; // edx
  int v35[2]; // [rsp+20h] [rbp-E0h] BYREF
  __int16 v36; // [rsp+28h] [rbp-D8h]
  __int64 v37[2]; // [rsp+30h] [rbp-D0h] BYREF
  int v38[21]; // [rsp+40h] [rbp-C0h] BYREF
  __int16 v39; // [rsp+94h] [rbp-6Ch]
  int v40[21]; // [rsp+96h] [rbp-6Ah] BYREF
  __int16 v41; // [rsp+EAh] [rbp-16h]
  int v42[20]; // [rsp+ECh] [rbp-14h] BYREF
  int v43[21]; // [rsp+13Ch] [rbp+3Ch] BYREF
  int v44[21]; // [rsp+190h] [rbp+90h] BYREF
  int v45[31]; // [rsp+1E4h] [rbp+E4h] BYREF
  int v46[34]; // [rsp+260h] [rbp+160h] BYREF
  char v47[16]; // [rsp+2E8h] [rbp+1E8h] BYREF
  char v48[16]; // [rsp+2F8h] [rbp+1F8h] BYREF
  char v49[16]; // [rsp+308h] [rbp+208h] BYREF
  char v50[16]; // [rsp+318h] [rbp+218h] BYREF
  char v51[24]; // [rsp+328h] [rbp+228h] BYREF
  char v52[96]; // [rsp+340h] [rbp+240h] BYREF
  char v53[96]; // [rsp+3A0h] [rbp+2A0h] BYREF
  char v54[80]; // [rsp+400h] [rbp+300h] BYREF
  char v55[96]; // [rsp+450h] [rbp+350h] BYREF
  char v56[96]; // [rsp+4B0h] [rbp+3B0h] BYREF
  char v57[128]; // [rsp+510h] [rbp+410h] BYREF
  char v58[176]; // [rsp+590h] [rbp+490h] BYREF

  v46[0] = 0x3AE87196;
  v46[1] = 0x577AE2AF;
  v46[2] = 0x26A23CA2;
  v46[3] = 0xAC01A8B1;
  v46[4] = 0x5B81F090;
  v46[5] = 0x66EA605C;
  v46[6] = 0xE4100542;
  v46[7] = 0x8692A6A9;
  v46[8] = 0xF72B5563;
  v46[9] = 0x96A96F30;
  v46[0xA] = 0xCE9D3946;
  v46[0xB] = 0x64150E2D;
  v46[0xC] = 0xC280278B;
  v46[0xD] = 0xB9C8609;
  v46[0xE] = 0x976AF6ED;
  v46[0xF] = 0xB8DFEDA2;
  v46[0x10] = 0x950D0AFD;
  v46[0x11] = 0xD65DED7C;
  v46[0x12] = 0xCFC03F68;
  v46[0x13] = 0xB6009287;
  v46[0x14] = 0x9192A460;
  v46[0x15] = 0xF4550D34;
  v46[0x16] = 0xCE8A2D73;
  v46[0x17] = 0xC9ADF74;
  v46[0x18] = 0x7B7E1319;
  v46[0x19] = 0xF48398D8;
  v46[0x1A] = 0xA04E81E3;
  v46[0x1B] = 0xED44542D;
  v46[0x1C] = 0xD8ACB29A;
  v46[0x1D] = 0x442223BA;
  v46[0x1E] = 0x2C06DC;
  v46[0x1F] = 0xF11B0E5E;
  v46[0x20] = 0x9C2D4817;
  v46[0x21] = 0x9FEE7AF6;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v58, 0i64, 0x88i64);
  v7 = 0x7E67AF4A;
  a6 = v46;
  v8 = 0i64;
  a7 = v58;
  do
  {
    v7 = __ROL4__(0x343FD * v7 + 0x269EC3, 1);
    *(_DWORD *)&a7[v8 * 4] = a6[v8] ^ v7;
    ++v8;
  }
  while ( v8 < 0x22 );
  v45[0] = 0x8C9378D7;
  v45[1] = 0xE10878B4;
  v45[2] = 0xDF52C914;
  v45[3] = 0xC18C59B;
  v45[4] = 0x42F0D7EE;
  v45[5] = 0x89CABCF5;
  v45[6] = 0xCB2D15B4;
  v45[7] = 0x6F164492;
  v45[8] = 0x16263064;
  v45[9] = 0xDEA7C4DE;
  v45[0xA] = 0xCCF9EC0B;
  v45[0xB] = 0x2789838A;
  v45[0xC] = 0x89AB98BF;
  v45[0xD] = 0xF32AF4DE;
  v45[0xE] = 0x71E08756;
  v45[0xF] = 0xE3ADDE8B;
  v45[0x10] = 0xF67E5BB5;
  v45[0x11] = 0x6808999E;
  v45[0x12] = 0x830C2D13;
  v45[0x13] = 0x4DDD8556;
  v45[0x14] = 0x3142489E;
  v45[0x15] = 0xC8B2C430;
  v45[0x16] = 0x4E9408A6;
  v45[0x17] = 0xCFD47A7B;
  v45[0x18] = 0x51581F57;
  v45[0x19] = 0x7AEC5D78;
  v45[0x1A] = 0x81AFF258;
  v45[0x1B] = 0xD0F74B0A;
  v45[0x1C] = 0xBF296433;
  v45[0x1D] = 0x9E83031D;
  v45[0x1E] = 0x86D50CCC;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v57, 0i64, 0x7Ci64);
  v9 = 0xA8BD414E;
  a6 = v45;
  v10 = 0i64;
  a7 = v57;
  do
  {
    v9 = __ROL4__(((v9 ^ (v9 >> 7)) << 9) ^ v9 ^ (v9 >> 7) ^ ((((v9 ^ (v9 >> 7)) << 9) ^ v9 ^ (v9 >> 7)) >> 0xD), 3);
    *(_DWORD *)&a7[v10 * 4] = a6[v10] ^ v9;
    ++v10;
  }
  while ( v10 < 0x1F );
  v35[0] = 0xA6121F88;
  v36 = 0xDC95;
  v11 = 0xA66B1FDC;
  v35[1] = 0xE9FF28E;
  v37[0] = 0i64;
  v12 = 0i64;
  LOWORD(v37[1]) = 0;
  a6 = v35;
  a7 = (char *)v37;
  v13 = 8i64;
  do
  {
    v14 = a6[v12] ^ v11;
    v11 = __ROL4__(0x343FD * v11 + 0x269EC3, 4);
    *(_DWORD *)&a7[v12 * 4] = v14;
    ++v12;
  }
  while ( v12 < 2 );
  a6 = v35;
  a7 = (char *)v37;
  do
  {
    v15 = v11;
    v11 >>= 8;
    a7[v13] = *((_BYTE *)a6 + v13) ^ v15;
    ++v13;
  }
  while ( v13 < 0xA );
  v42[0] = 0x436CEB6;
  v42[1] = 0xE66284F4;
  v42[2] = 0xC961B161;
  v42[3] = 0x5E459433;
  v42[4] = 0x9DBE99AF;
  v42[5] = 0x898580A0;
  v42[6] = 0xCAAECBE2;
  v42[7] = 0xF8F54527;
  v42[8] = 0x9F9E4274;
  v42[9] = 0x78692BA3;
  v42[0xA] = 0xF972F42E;
  v42[0xB] = 0x150F7221;
  v42[0xC] = 0xC33E13EE;
  v42[0xD] = 0x992270E5;
  v42[0xE] = 0xFC0904A9;
  v42[0xF] = 0x4DEA2113;
  v42[0x10] = 0x76B04564;
  v42[0x11] = 0x7B44A171;
  v42[0x12] = 0x3717FE07;
  v42[0x13] = 0x74689B60;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v54, 0i64, 0x50i64);
  v16 = 0xFCD718C5;
  a6 = v42;
  v17 = 0i64;
  a7 = v54;
  do
  {
    v16 = __ROL4__(
            ((v16 ^ (v16 >> 7)) << 9) ^ v16 ^ (v16 >> 7) ^ ((((v16 ^ (v16 >> 7)) << 9) ^ v16 ^ (v16 >> 7)) >> 0xD),
            4);
    *(_DWORD *)&a7[v17 * 4] = a6[v17] ^ v16;
    ++v17;
  }
  while ( v17 < 0x14 );
  v38[0] = 0x4C3559B0;
  v38[1] = 0xAC3E2006;
  v38[2] = 0x6CCBFCD7;
  v38[3] = 0x15DCFA00;
  v38[4] = 0x54CDD1D1;
  v38[5] = 0xDBCB50B0;
  v38[6] = 0xC8E95E48;
  v38[7] = 0xD63187A;
  v38[8] = 0x21C25D31;
  v38[9] = 0xA3DD6B50;
  v38[0xA] = 0x77E7D411;
  v38[0xB] = 0xD1A4A9C;
  v38[0xC] = 0xAC5BFA8A;
  v38[0xD] = 0xD3F74E95;
  v38[0xE] = 0x4BC1075B;
  v38[0xF] = 0x1E7BB2B4;
  v38[0x10] = 0x4880D170;
  v38[0x11] = 0x265033C7;
  v38[0x12] = 0x5B3D47BB;
  v38[0x13] = 0x261A2D8C;
  v38[0x14] = 0x828B0E97;
  v39 = 0xD4FC;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v53, 0i64, 0x56i64);
  v18 = 0x4C6659EC;
  a6 = v38;
  v19 = 0i64;
  a7 = v53;
  do
  {
    v20 = a6[v19] ^ v18;
    v18 = __ROR4__(0x343FD * v18 + 0x269EC3, 1);
    *(_DWORD *)&a7[v19 * 4] = v20;
    ++v19;
  }
  while ( v19 < 0x15 );
  v21 = 0x54i64;
  a6 = v38;
  a7 = v53;
  do
  {
    v22 = v18;
    v18 >>= 8;
    a7[v21] = *((_BYTE *)a6 + v21) ^ v22;
    ++v21;
  }
  while ( v21 < 0x56 );
  v43[0] = 0x908B1C40;
  v43[1] = 0x9D2E0EAC;
  v43[2] = 0xAC964333;
  v43[3] = 0x74B1F55;
  v43[4] = 0xD6DC94FE;
  v43[5] = 0x155D2BF8;
  v43[6] = 0xBCFC7B92;
  v43[7] = 0xBA978A6F;
  v43[8] = 0x689A1AF3;
  v43[9] = 0xDA036311;
  v43[0xA] = 0x2E1BBA72;
  v43[0xB] = 0x973C4B99;
  v43[0xC] = 0x9E20EB3A;
  v43[0xD] = 0x9237C6DA;
  v43[0xE] = 0xAC716577;
  v43[0xF] = 0xE4008295;
  v43[0x10] = 0x4CB8D16C;
  v43[0x11] = 0x351C8366;
  v43[0x12] = 0xF800BB08;
  v43[0x13] = 0xBB962D10;
  v43[0x14] = 0x74852540;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v56, 0i64, 0x54i64);
  v23 = 0x4D8A0EDD;
  a6 = v43;
  v24 = 0i64;
  a7 = v56;
  do
  {
    v23 = -(((v23 ^ (v23 >> 7)) << 9) ^ v23 ^ (v23 >> 7) ^ ((((v23 ^ (v23 >> 7)) << 9) ^ v23 ^ (v23 >> 7)) >> 0xD));
    *(_DWORD *)&a7[v24 * 4] = a6[v24] ^ v23;
    ++v24;
  }
  while ( v24 < 0x15 );
  v40[0] = 0x1B077EF0;
  v41 = 0xEAB7;
  v40[1] = 0xE687B4D6;
  v40[2] = 0x9A31FF59;
  v40[3] = 0x30CFA522;
  v40[4] = 0x8FE7EADA;
  v40[5] = 0x1C5CBCDD;
  v40[6] = 0x5761341;
  v40[7] = 0x4A9E2B38;
  v40[8] = 0xB55F425D;
  v40[9] = 0xC001AE35;
  v40[0xA] = 0x6091CB70;
  v40[0xB] = 0xE2593B3D;
  v40[0xC] = 0xB6B5FA43;
  v40[0xD] = 0x1341317B;
  v40[0xE] = 0x2BC55BB6;
  v40[0xF] = 0x56316CB2;
  v40[0x10] = 0xA7C6753;
  v40[0x11] = 0xF1C5BA3A;
  v40[0x12] = 0xEC9F7381;
  v40[0x13] = 0x478D5E90;
  v40[0x14] = 0x7510FEDB;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v52, 0i64, 0x56i64);
  v25 = 0x1B547EAC;
  a6 = v40;
  v26 = 0i64;
  a7 = v52;
  do
  {
    v27 = a6[v26] ^ v25;
    v25 = __ROR4__(0x343FD * v25 + 0x269EC3, 2);
    *(_DWORD *)&a7[v26 * 4] = v27;
    ++v26;
  }
  while ( v26 < 0x15 );
  v28 = 0x54i64;
  a6 = v40;
  a7 = v52;
  do
  {
    v29 = v25;
    v25 >>= 8;
    a7[v28] = *((_BYTE *)a6 + v28) ^ v29;
    ++v28;
  }
  while ( v28 < 0x56 );
  v44[0] = 0x263376C8;
  v44[1] = 0x80CF41FD;
  v44[2] = 0x45216F5;
  v44[3] = 0x8560094F;
  v44[4] = 0xB7555B0;
  v44[5] = 0xEC6DE88B;
  v44[6] = 0xC178DF5C;
  v44[7] = 0x38B738CA;
  v44[8] = 0xA25F3F2B;
  v44[9] = 0xB00FBAFD;
  v44[0xA] = 0xF5451EED;
  v44[0xB] = 0x9DE7A893;
  v44[0xC] = 0x84394CF;
  v44[0xD] = 0x9A0A2A32;
  v44[0xE] = 0xFF6B0858;
  v44[0xF] = 0xF973EC99;
  v44[0x10] = 0xD4D35872;
  v44[0x11] = 0x3A948AD3;
  v44[0x12] = 0xA7657F9E;
  v44[0x13] = 0x52545A23;
  v44[0x14] = 0xBF75332E;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v55, 0i64, 0x54i64);
  v30 = 0xF47EFA55;
  a6 = v44;
  v31 = 0i64;
  a7 = v55;
  do
  {
    v30 = ~(((v30 ^ (v30 >> 7)) << 9) ^ v30 ^ (v30 >> 7) ^ ((((v30 ^ (v30 >> 7)) << 9) ^ v30 ^ (v30 >> 7)) >> 0xD));
    *(_DWORD *)&a7[v31 * 4] = a6[v31] ^ v30;
    ++v31;
  }
  while ( v31 < 0x15 );
  v32 = dword_1400D803C;
  if ( dword_1400D803C == 0xFFFFFFFF )
  {
    v32 = 1;
    if ( !(unsigned __int8)((__int64 (__fastcall *)(char *, __int64 *, char *))loc_140027B08)(v58, v37, &a5)
      && !(unsigned __int8)((__int64 (__fastcall *)(char *, __int64 *, char *))loc_140027B08)(v57, v37, &a5) )
    {
      ((void (__fastcall *)(char *, char *))loc_140007050)(v47, v54);
      if ( !sub_140059160((__int64)v47) )
      {
        ((void (__fastcall *)(char *, char *))loc_140007050)(v48, v53);
        if ( !sub_140059160((__int64)v48) )
        {
          ((void (__fastcall *)(char *, char *))loc_140007050)(v49, v56);
          if ( !sub_140059160((__int64)v49) )
          {
            ((void (__fastcall *)(char *, char *))loc_140007050)(v50, v52);
            if ( !sub_140059160((__int64)v50) )
            {
              ((void (__fastcall *)(char *, char *))loc_140007050)(v51, v55);
              if ( !sub_140059160((__int64)v51) )
                v32 = 0;
            }
          }
        }
      }
    }
    dword_1400D803C = v32;
  }
  memset(v55, 0, 0x54ui64);
  memset(v52, 0, 0x56ui64);
  memset(v56, 0, 0x54ui64);
  memset(v53, 0, 0x56ui64);
  memset(v54, 0, sizeof(v54));
  memset(v37, 0, 0xAui64);
  memset(v57, 0, 0x7Cui64);
  memset(v58, 0, 0x88ui64);
  return v32 == 1;
}
// 1400D803C: using guessed type int dword_1400D803C;

//----- (000000014000BB08) ----------------------------------------------------
char __fastcall sub_14000BB08(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, int a6, __int64 a7, unsigned __int64 a8)
{
  unsigned int v8; // er15
  unsigned int v9; // ebx
  char v10; // r13
  __int64 v11; // rax
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r8
  __int64 v15; // r9
  __int64 v16; // rsi
  unsigned int v17; // er12
  __int64 *v18; // r14
  char v19; // di
  int v20; // ebx
  unsigned int v21; // edx
  unsigned __int64 i; // rdi
  unsigned int v23; // edi
  unsigned __int64 v24; // rdx
  char v25; // dl
  _DWORD *v26; // rax
  _DWORD *v27; // rsi
  unsigned int v28; // er14
  __int64 v29; // rdx
  __int64 v30; // rax
  _DWORD *v31; // rcx
  bool v32; // zf
  CHAR *v33; // rcx
  unsigned __int64 v34; // rax
  int v35; // ebx
  unsigned __int32 v36; // edx
  unsigned __int64 v37; // rdi
  int v38; // ecx
  unsigned __int64 v39; // rax
  unsigned __int32 v40; // edx
  unsigned __int64 v41; // rdi
  unsigned __int64 j; // rdi
  char v43; // cl
  unsigned __int64 v44; // rax
  unsigned int v45; // edx
  unsigned __int64 v46; // rdi
  unsigned __int64 k; // rdi
  char v48; // cl
  unsigned __int64 v49; // rax
  LONG v50; // eax
  char v51; // dl
  __int64 *v53; // [rsp+20h] [rbp-A9h]
  int v54[2]; // [rsp+30h] [rbp-99h]
  char v55; // [rsp+38h] [rbp-91h]
  int v56[2]; // [rsp+39h] [rbp-90h]
  __int16 v57; // [rsp+41h] [rbp-88h]
  int v58[3]; // [rsp+43h] [rbp-86h]
  __int16 v59; // [rsp+4Fh] [rbp-7Ah]
  _BYTE v60[9]; // [rsp+51h] [rbp-78h] BYREF
  _BYTE v61[10]; // [rsp+5Ah] [rbp-6Fh] BYREF
  _BYTE v62[14]; // [rsp+64h] [rbp-65h] BYREF
  __int64 v63; // [rsp+72h] [rbp-57h] BYREF
  __int64 v64; // [rsp+7Ah] [rbp-4Fh] BYREF
  STRING String1; // [rsp+88h] [rbp-41h] BYREF
  PVOID Object; // [rsp+98h] [rbp-31h] BYREF
  char v67[16]; // [rsp+A0h] [rbp-29h] BYREF
  STRING String2; // [rsp+B0h] [rbp-19h] BYREF
  STRING v69; // [rsp+C0h] [rbp-9h] BYREF
  STRING v70; // [rsp+D0h] [rbp+7h] BYREF

  v8 = 0;
  v9 = 0;
  v10 = 0;
  v11 = sub_140051084(0x800ui64);
  v16 = v11;
  if ( !v11 )
    goto LABEL_23;
  v17 = sub_140014308(v11, 0x100i64);
  if ( v17 )
  {
    v18 = (__int64 *)v16;
    while ( 1 )
    {
      if ( *v18 )
      {
        if ( (int)sub_1400488FC(*v18, (__int64)&Object) >= 0 )
        {
          v19 = sub_1400144E4((__int64)Object, v67);
          ObfDereferenceObject(Object);
          if ( v19 )
          {
            a7 = 0x7631F545AF19287i64;
            v64 = 0i64;
            v20 = v9 | 1;
            v53 = &a7;
            v21 = 0x5F0C9E20;
            for ( i = 0i64; i < 8; i += 4i64 )
            {
              v21 = ~(((v21 ^ (v21 << 0xD)) >> 7) ^ v21 ^ (v21 << 0xD) ^ ((((v21 ^ (v21 << 0xD)) >> 7) ^ v21 ^ (v21 << 0xD)) << 0x11));
              *(_DWORD *)((char *)&v64 + i) = *(_DWORD *)((char *)&a7 + i) ^ v21;
            }
            if ( sub_140007538((__int64)v67, &v64, 7ui64) )
              goto LABEL_15;
            a8 = 0x9EC34C54B65BBEFBui64;
            v63 = 0i64;
            v20 |= 2u;
            v23 = 0x6946A5AC;
            v24 = 0i64;
            v53 = &v63;
            do
            {
              v23 = 0xFFB95A53 - 0x6947 * v23;
              *(_DWORD *)((char *)&v63 + v24) = *(_DWORD *)((char *)&a8 + v24) ^ v23;
              v24 += 4i64;
            }
            while ( v24 < 8 );
            if ( sub_140007538((__int64)v67, &v63, 7ui64)
              || (v20 |= 4u, v53 = (__int64 *)&a6, a6 = 0x5F7674, sub_140007538((__int64)v67, &a6, 3ui64)) )
            {
LABEL_15:
              v25 = 1;
            }
            else
            {
              v25 = 0;
            }
            if ( (v20 & 4) != 0 )
            {
              v20 &= 0xFFFFFFFB;
              memset(&a6, 0, sizeof(a6));
            }
            if ( (v20 & 2) != 0 )
            {
              v20 &= 0xFFFFFFFD;
              memset(&v63, 0, sizeof(v63));
            }
            v9 = v20 & 0xFFFFFFFE;
            memset(&v64, 0, sizeof(v64));
            if ( v25 )
              break;
          }
        }
      }
      ++v8;
      ++v18;
      if ( v8 >= v17 )
        goto LABEL_22;
    }
    v10 = 1;
  }
LABEL_22:
  sub_140051220(v16);
  if ( !v10 )
  {
LABEL_23:
    v26 = (_DWORD *)sub_14002D72C(v13, v12, v14, v15, (unsigned int)v53);
    v27 = v26;
    if ( v26 )
    {
      v28 = 0;
      if ( *v26 )
      {
        while ( 1 )
        {
          v29 = 0x4Ai64 * v28;
          if ( *(_QWORD *)&v27[v29 + 6] >= (unsigned __int64)MmSystemRangeStart )
          {
            v30 = HIWORD(v27[v29 + 0xB]);
            v31 = &v27[v29 + 0xC];
            v32 = (_DWORD *)((char *)v31 + v30) == 0i64;
            v33 = (char *)v31 + v30;
            String1.Buffer = v33;
            if ( v32 )
            {
              *(_DWORD *)&String1.Length = 0;
            }
            else
            {
              v34 = 0xFFFFFFFFFFFFFFFFui64;
              do
                ++v34;
              while ( v33[v34] );
              String1.Length = v34;
              String1.MaximumLength = v34 + 1;
            }
            v54[0] = 0xB7FFA40E;
            v35 = v9 | 8;
            v54[1] = 0xC850C00F;
            *(_QWORD *)v60 = 0i64;
            v36 = 0xC198C64A;
            v60[8] = 0;
            v37 = 0i64;
            v55 = 0x51;
            do
            {
              v38 = v54[v37] ^ v36;
              v36 = _byteswap_ulong(0x41C64E6D * v36 + 0x3039);
              *(_DWORD *)&v60[v37 * 4] = v38;
              ++v37;
            }
            while ( v37 < 2 );
            v60[8] = v55 ^ v36;
            String2.Buffer = v60;
            v39 = 0xFFFFFFFFFFFFFFFFui64;
            do
              ++v39;
            while ( v60[v39] );
            String2.Length = v39;
            String2.MaximumLength = v39 + 1;
            if ( !RtlCompareString(&String1, &String2, 1u) )
              goto LABEL_51;
            v58[0] = 0x85B61DAE;
            v35 |= 0x10u;
            v58[1] = 0xEFB99642;
            *(_QWORD *)v62 = 0i64;
            v40 = 0xC6F94FFE;
            *(_DWORD *)&v62[8] = 0;
            v41 = 0i64;
            *(_WORD *)&v62[0xC] = 0;
            v58[2] = 0x9D153DCF;
            v59 = 0x2996;
            do
            {
              *(_DWORD *)&v62[v41 * 4] = v58[v41] ^ v40;
              ++v41;
              v40 = _byteswap_ulong(((v40 ^ (v40 << 0xD)) >> 0x11) ^ v40 ^ (v40 << 0xD) ^ (0x20
                                                                                         * (((v40 ^ (v40 << 0xD)) >> 0x11) ^ v40 ^ (v40 << 0xD))));
            }
            while ( v41 < 3 );
            for ( j = 0xCi64; j < 0xE; ++j )
            {
              v43 = v40;
              v40 >>= 8;
              v62[j] = *((_BYTE *)v58 + j) ^ v43;
            }
            v69.Buffer = v62;
            v44 = 0xFFFFFFFFFFFFFFFFui64;
            do
              ++v44;
            while ( v62[v44] );
            v69.Length = v44;
            v69.MaximumLength = v44 + 1;
            if ( !RtlCompareString(&String1, &v69, 1u) )
              goto LABEL_51;
            v56[0] = 0xD217FF82;
            v35 |= 0x20u;
            v56[1] = 0x4183AEEC;
            *(_QWORD *)v61 = 0i64;
            v45 = 0xE47C9DE6;
            *(_WORD *)&v61[8] = 0;
            v46 = 0i64;
            v57 = 0x23BD;
            do
            {
              *(_DWORD *)&v61[v46 * 4] = v56[v46] ^ v45;
              ++v46;
              v45 = 0xFFFFCFC6 - 0x41C64E6D * v45;
            }
            while ( v46 < 2 );
            for ( k = 8i64; k < 0xA; ++k )
            {
              v48 = v45;
              v45 >>= 8;
              v61[k] = *((_BYTE *)v56 + k) ^ v48;
            }
            v70.Buffer = v61;
            v49 = 0xFFFFFFFFFFFFFFFFui64;
            do
              ++v49;
            while ( v61[v49] );
            v70.Length = v49;
            v70.MaximumLength = v49 + 1;
            v50 = RtlCompareString(&String1, &v70, 1u);
            v51 = 0;
            if ( !v50 )
LABEL_51:
              v51 = 1;
            if ( (v35 & 0x20) != 0 )
            {
              v35 &= 0xFFFFFFDF;
              memset(v61, 0, sizeof(v61));
            }
            if ( (v35 & 0x10) != 0 )
            {
              v35 &= 0xFFFFFFEF;
              memset(v62, 0, sizeof(v62));
            }
            v9 = v35 & 0xFFFFFFF7;
            memset(v60, 0, sizeof(v60));
            if ( v51 )
              break;
          }
          if ( ++v28 >= *v27 )
            goto LABEL_60;
        }
        v10 = 1;
      }
LABEL_60:
      sub_140051220((__int64)v27);
    }
  }
  return v10;
}
// 14000BD4B: variable 'v13' is possibly undefined
// 14000BD4B: variable 'v12' is possibly undefined
// 14000BD4B: variable 'v14' is possibly undefined
// 14000BD4B: variable 'v15' is possibly undefined
// 14000BD4B: variable 'v53' is possibly undefined
// 140014308: using guessed type __int64 __fastcall sub_140014308(_QWORD, _QWORD);

//----- (000000014000C0C8) ----------------------------------------------------
char __fastcall sub_14000C0C8(__int64 a1)
{
  char v1; // bl
  int v2; // esi
  __int64 v3; // rcx
  unsigned int i; // er14
  unsigned int v5; // edi
  unsigned __int64 v6; // rdx
  unsigned __int64 j; // r8
  char v8; // dl
  bool v9; // dl
  int v11[3]; // [rsp+20h] [rbp-40h]
  __int16 v12; // [rsp+2Ch] [rbp-34h]
  _BYTE v13[14]; // [rsp+2Eh] [rbp-32h] BYREF
  char v14[18]; // [rsp+3Ch] [rbp-24h] BYREF

  v1 = 0;
  v2 = 0;
  sub_140069DC8(a1, 0);
  for ( i = 0; i < (unsigned __int16)word_1400D82CC; ++i )
  {
    v3 = qword_1400D82D0 + 0x340i64 * i;
    if ( !v3 )
      break;
    if ( v3 != 0xFFFFFFFFFFFFFFF8ui64 )
      JUMPOUT(0x14000C122i64);
    v11[0] = 0xCCBE26EA;
    v2 |= 2u;
    v11[1] = 0x9927D6A4;
    *(_QWORD *)v13 = 0i64;
    v5 = 0xB8CE47A9;
    *(_DWORD *)&v13[8] = 0;
    v6 = 0i64;
    *(_WORD *)&v13[0xC] = 0;
    v11[2] = 0xAE757704;
    v12 = 0x2030;
    do
    {
      *(_DWORD *)&v13[v6 * 4] = v11[v6] ^ v5;
      ++v6;
      v5 = __ROL4__(
             ((v5 ^ (v5 << 0xD)) >> 0x11) ^ v5 ^ (v5 << 0xD) ^ (0x20 * (((v5 ^ (v5 << 0xD)) >> 0x11) ^ v5 ^ (v5 << 0xD))),
             2);
    }
    while ( v6 < 3 );
    for ( j = 0xCi64; j < 0xE; ++j )
    {
      v8 = v5;
      v5 >>= 8;
      v13[j] = *((_BYTE *)v11 + j) ^ v8;
    }
    v9 = sub_140007538(v3 + 8, v13, 0x100ui64) != 0;
    if ( (v2 & 2) != 0 )
    {
      v2 &= 0xFFFFFFFD;
      memset(v13, 0, sizeof(v13));
      v3 = 0i64;
    }
    if ( (v2 & 1) != 0 )
    {
      v2 &= 0xFFFFFFFE;
      memset(v14, 0, sizeof(v14));
      v3 = 0i64;
    }
    if ( v9 )
    {
      v1 = 1;
      break;
    }
  }
  sub_140069DC8(v3, 1);
  return v1;
}
// 14000C11C: control flows out of bounds to 14000C122
// 14000C2D8: variable 'v3' is possibly undefined
// 1400D82CC: using guessed type __int16 word_1400D82CC;
// 1400D82D0: using guessed type __int64 qword_1400D82D0;

//----- (000000014000C2F4) ----------------------------------------------------
bool __fastcall sub_14000C2F4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // rax
  __int64 v6; // rdi
  int v7; // ebx
  bool result; // al

  result = 0;
  if ( a1 )
  {
    v5 = sub_140048944(a1);
    v6 = v5;
    if ( v5 )
    {
      v7 = sub_14002AC18(v5, 0x19u, (__int64)&a5);
      sub_14004897C(v6);
      if ( v7 >= 0 && a5 >= 0x4000 )
        result = 1;
    }
  }
  return result;
}

//----- (000000014000CD78) ----------------------------------------------------
char __fastcall sub_14000CD78(__int64 a1)
{
  unsigned __int64 v1; // rdi
  unsigned __int32 v2; // edx
  char v3; // dl
  int v5[9]; // [rsp+30h] [rbp-79h]
  __int16 v6; // [rsp+54h] [rbp-55h]
  __int64 v7[11]; // [rsp+86h] [rbp-23h] BYREF
  char v8[32]; // [rsp+E0h] [rbp+37h] BYREF

  v1 = 0i64;
  if ( a1 )
  {
    if ( !sub_1400144E4(a1, v8) )
      goto LABEL_7;
    v5[0] = 0xD3CED35;
    v7[0] = 0i64;
    v2 = 0x405426A4;
    LODWORD(v7[1]) = 0;
    v5[1] = 0x733B72F2;
    v5[2] = 0x1A970C4B;
    do
    {
      v2 = _byteswap_ulong(((v2 ^ (v2 << 0xD)) >> 0x11) ^ v2 ^ (v2 << 0xD) ^ (0x20
                                                                            * (((v2 ^ (v2 << 0xD)) >> 0x11) ^ v2 ^ (v2 << 0xD))));
      *(_DWORD *)((char *)v7 + v1) = *(int *)((char *)v5 + v1) ^ v2;
      v1 += 4i64;
    }
    while ( v1 < 0xC );
    LOBYTE(v1) = 1;
    if ( sub_140007538((__int64)v8, v7, 0xBui64) )
LABEL_7:
      v3 = 0;
    else
      v3 = 1;
    if ( (v1 & 1) != 0 )
      memset(v7, 0, 0xCui64);
    if ( !v3 )
    {
      v5[3] = 0x4C19537A;
      v6 = 0xBFAC;
      JUMPOUT(0x14000CE5Ci64);
    }
  }
  return 0;
}
// 14000CE58: control flows out of bounds to 14000CE5C

//----- (000000014000D0A4) ----------------------------------------------------
char __fastcall sub_14000D0A4(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 8) && *(_WORD *)a1 && *(_WORD *)(a1 + 2) )
    JUMPOUT(0x14000D0FCi64);
  return 0;
}
// 14000D0F5: control flows out of bounds to 14000D0FC

//----- (000000014000D5A4) ----------------------------------------------------
__int64 sub_14000D5A4()
{
  __int64 v0; // rax
  void (__fastcall *v1)(__int64, __int64, _QWORD); // r15
  __int64 v2; // rax
  void (__fastcall *v3)(__int64, _QWORD, _QWORD); // r14
  __int64 v4; // rax
  __int64 (*v5)(void); // rsi
  __int64 v6; // rbx
  __int64 v7; // rdx
  __int64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdi
  ULONG v13; // [rsp+20h] [rbp-20h] BYREF
  int v14; // [rsp+24h] [rbp-1Ch]
  int v15; // [rsp+28h] [rbp-18h]
  int v16; // [rsp+2Ch] [rbp-14h]
  int v17; // [rsp+30h] [rbp-10h]

  v13 = 0xE1495A27;
  v14 = 0x34554477;
  v15 = 0xD6FBC841;
  v16 = 0xFEB2AE66;
  v17 = 0x4DF6B966;
  v0 = ((__int64 (__fastcall *)(ULONG *))loc_1400061CC)(&v13);
  v13 = 0x9E7917D4;
  v1 = (void (__fastcall *)(__int64, __int64, _QWORD))v0;
  v14 = 0xA91892E7;
  v15 = 0x5CBFC391;
  v16 = 0xEB6C3727;
  v17 = 0xD24EAA80;
  v2 = ((__int64 (__fastcall *)(ULONG *))loc_1400061CC)(&v13);
  v13 = 0x2CCF00E8;
  v3 = (void (__fastcall *)(__int64, _QWORD, _QWORD))v2;
  v14 = 0xACD4ADAF;
  v15 = 0x809BF0BE;
  v16 = 0x560FC0;
  v17 = 0xE50EE850;
  v4 = ((__int64 (__fastcall *)(ULONG *))loc_1400061CC)(&v13);
  v13 = 0x61F6CEF5;
  v5 = (__int64 (*)(void))v4;
  v14 = 0xF69CDF3F;
  v15 = 0x8AAE7D68;
  v16 = 0xC180CBD5;
  v17 = 0x5B78AF3E;
  v6 = ((__int64 (__fastcall *)(ULONG *))loc_1400061CC)(&v13);
  v11 = sub_14000A0E4(v8, v7, v9, v10, v13);
  *(_QWORD *)(v11 + 0xE40) = 0x109B948i64;
  *(_DWORD *)(v11 + 0xE48) = 0x31480000;
  *(_DWORD *)(v11 + 0xE4C) = 0x448948C0;
  *(_DWORD *)(v11 + 0xE50) = 0xB8482024;
  *(_QWORD *)(v11 + 0xE54) = v6;
  *(_DWORD *)(v11 + 0xE5C) = 0xE0FF006A;
  v1(v11 + 0xE00, v11 + 0xE40, 0i64);
  v3(v11 + 0xE00, 0i64, 0i64);
  return v5();
}
// 14000D67B: variable 'v8' is possibly undefined
// 14000D67B: variable 'v7' is possibly undefined
// 14000D67B: variable 'v9' is possibly undefined
// 14000D67B: variable 'v10' is possibly undefined

//----- (000000014000D730) ----------------------------------------------------
_DWORD *__fastcall sub_14000D730(__int64 a1, _DWORD *a2)
{
  unsigned __int64 v3; // rsi
  __int64 v4; // rdi
  _DWORD *i; // rbx
  char v7[256]; // [rsp+20h] [rbp-108h] BYREF

  if ( !a1 )
    return 0i64;
  if ( !*(_QWORD *)(a1 + 8) )
    return 0i64;
  if ( !*(_WORD *)a1 )
    return 0i64;
  if ( !*(_WORD *)(a1 + 2) )
    return 0i64;
  if ( !a2 )
    return 0i64;
  if ( !sub_1400074D4((__int64)v7, 0x100i64, (unsigned __int16 *)a1) )
    return 0i64;
  v3 = (unsigned int)*a2;
  v4 = 0i64;
  if ( !*a2 )
    return 0i64;
  for ( i = a2 + 2;
        !sub_140007538(
           (__int64)v7,
           (_BYTE *)i + *((unsigned __int16 *)i + 0x13) + 0x28,
           0x100i64 - *((unsigned __int16 *)i + 0x13));
        i += 0x4A )
  {
    if ( ++v4 >= v3 )
      return 0i64;
  }
  return i;
}

//----- (000000014000D7DC) ----------------------------------------------------
char __fastcall sub_14000D7DC(__int64 a1, unsigned __int64 a2)
{
  char v2; // r8
  unsigned __int64 v3; // r9
  __int64 v4; // rax

  v2 = 0;
  if ( !a1 )
    return 0;
  v3 = *(_QWORD *)(a1 + 0x10);
  if ( !v3 )
    return 0;
  v4 = *(unsigned int *)(a1 + 0x18);
  if ( !(_DWORD)v4 || !a2 )
    return 0;
  if ( a2 >= v3 && a2 < v3 + v4 )
    v2 = 1;
  return v2;
}

//----- (000000014000DB00) ----------------------------------------------------
char __fastcall sub_14000DB00(__int64 a1, unsigned __int64 a2, _QWORD *a3, unsigned __int64 *a4)
{
  unsigned __int64 v7; // rbx
  void *v8; // r8
  unsigned __int64 v9; // rdx
  __int16 v10; // cx
  __int16 v11; // di
  unsigned __int64 v12; // rax
  char result; // al

  if ( !a1 || a2 < 4 || !a3 || !a4 )
    return 0;
  v7 = a2 >> 1;
  v8 = (void *)sub_140051084(a2 >> 1);
  v9 = 0i64;
  memset(v8, 0, v7);
  if ( v7 >= 2 )
  {
    do
    {
      v10 = *(_WORD *)(a1 + 2 * v9);
      if ( (unsigned __int16)(v10 - 0x61) > 5u )
      {
        if ( (unsigned __int16)(v10 - 0x30) > 9u )
          goto LABEL_14;
      }
      else
      {
        LOBYTE(v10) = v10 - 0x57;
      }
      v11 = *(_WORD *)(a1 + 2 * v9 + 2);
      if ( (unsigned __int16)(v11 - 0x61) > 5u )
      {
        if ( (unsigned __int16)(v11 - 0x30) > 9u )
        {
LABEL_14:
          sub_140051220((__int64)v8);
          *a3 = 0i64;
          *a4 = 0i64;
          return 0;
        }
      }
      else
      {
        LOBYTE(v11) = v11 - 0x57;
      }
      v12 = v9 >> 1;
      v9 += 2i64;
      *((_BYTE *)v8 + v12) = v11 & 0xF | (0x10 * v10);
    }
    while ( v7 - v9 >= 2 );
  }
  result = 1;
  *a4 = v9 >> 1;
  *a3 = v8;
  return result;
}

//----- (000000014000DC04) ----------------------------------------------------
char __fastcall sub_14000DC04(HANDLE FileHandle, __int64 a2)
{
  char v2; // bl
  unsigned int *v5; // rax
  unsigned int *v6; // rdi
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+30h] [rbp-18h] BYREF

  v2 = 0;
  if ( !a2 || KeGetCurrentIrql() || (unsigned __int8)sub_14000ECDC() )
    return 0;
  v5 = (unsigned int *)sub_140051084(0x202ui64);
  v6 = v5;
  if ( v5 )
  {
    if ( ZwQueryInformationFile(FileHandle, &IoStatusBlock, v5, 0x200u, FileNameInformation) >= 0 )
    {
      *((_WORD *)v6 + ((unsigned __int64)*v6 >> 1) + 2) = 0;
      v2 = sub_1400070E0(a2, (__int64)(v6 + 1));
    }
    sub_140051220((__int64)v6);
  }
  return v2;
}

//----- (000000014000DCA8) ----------------------------------------------------
PVOID __fastcall sub_14000DCA8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  __int64 v5; // rax
  __int64 v6; // rbx
  unsigned int v7; // esi
  unsigned int v8; // edi
  __int64 *v9; // r14

  Object = 0i64;
  v5 = sub_140051084(0x1F40ui64);
  v6 = v5;
  if ( v5 )
  {
    v7 = sub_140014308(v5, 0x3E8i64);
    if ( v7 )
    {
      v8 = 0;
      v9 = (__int64 *)v6;
      do
      {
        if ( (int)sub_1400488FC(*v9, (__int64)&Object) >= 0 )
        {
          if ( (unsigned __int8)((__int64 (__fastcall *)(PVOID))loc_14000C638)(Object) )
            break;
          ObfDereferenceObject(Object);
          Object = 0i64;
        }
        ++v8;
        ++v9;
      }
      while ( v8 < v7 );
    }
    sub_140051220(v6);
  }
  return Object;
}
// 14000DCEB: conditional instruction was optimized away because of 'eax.4!=0'
// 140014308: using guessed type __int64 __fastcall sub_140014308(_QWORD, _QWORD);

//----- (000000014000DE34) ----------------------------------------------------
char __fastcall sub_14000DE34(_DWORD *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, PVOID Object, int *a7, __int64 *a8)
{
  __int64 v9; // rsi
  __int64 v10; // rax
  __int64 v11; // rax
  unsigned __int64 v12; // rdi
  int v13; // edx
  char v14; // r8
  char v15; // dl
  int v16; // edx
  unsigned __int64 v17; // rdi
  unsigned int v18; // edx
  unsigned __int64 v19; // rdi
  unsigned int v20; // edx
  unsigned __int64 v21; // rdi
  unsigned __int64 v22; // rdi
  char v23; // cl
  unsigned int v24; // edx
  unsigned __int64 v25; // rdi
  unsigned __int64 v26; // rdi
  char v27; // cl
  __int64 v28; // rdx
  __int64 v29; // r8
  __int64 v30; // r9
  unsigned int v32[3]; // [rsp+20h] [rbp-59h] BYREF
  char v33; // [rsp+2Ch] [rbp-4Dh]
  int v34[3]; // [rsp+2Dh] [rbp-4Ch] BYREF
  __int16 v35; // [rsp+39h] [rbp-40h]
  int v36[3]; // [rsp+3Bh] [rbp-3Eh] BYREF
  __int16 v37; // [rsp+47h] [rbp-32h]
  char v38; // [rsp+49h] [rbp-30h]
  int v39[3]; // [rsp+4Ah] [rbp-2Fh] BYREF
  int v40[4]; // [rsp+56h] [rbp-23h] BYREF
  __int64 v41; // [rsp+68h] [rbp-11h] BYREF
  int v42; // [rsp+70h] [rbp-9h]
  __int16 v43; // [rsp+74h] [rbp-5h]
  _BYTE v44[15]; // [rsp+78h] [rbp-1h] BYREF
  _BYTE v45[14]; // [rsp+87h] [rbp+Eh] BYREF
  _BYTE v46[13]; // [rsp+95h] [rbp+1Ch] BYREF
  _BYTE v47[12]; // [rsp+A2h] [rbp+29h] BYREF
  __int64 v48[4]; // [rsp+AEh] [rbp+35h] BYREF

  LODWORD(Object) = 0;
  v9 = sub_140048808();
  v10 = sub_14004888C(v9);
  LOBYTE(v11) = sub_14002FC18(v10);
  if ( (_BYTE)v11 )
    return v11;
  LOBYTE(v11) = sub_1400144E4(v9, &v41);
  if ( !(_BYTE)v11 )
    return v11;
  v39[0] = 0x93E215D3;
  v48[0] = 0i64;
  v12 = 0i64;
  LODWORD(v48[1]) = 0;
  v13 = 0xED8DB8EB;
  v39[1] = 0xCEC249B4;
  v39[2] = 0xAC7D7EE2;
  a7 = v39;
  a8 = v48;
  do
  {
    v13 = ~(0x41C64E6D * v13 + 0x3039);
    *(_DWORD *)((char *)a8 + v12 * 4) = a7[v12] ^ v13;
    ++v12;
  }
  while ( v12 < 3 );
  v14 = 1;
  v15 = 1;
  if ( v41 != v48[0] || (_WORD)v42 != LOWORD(v48[1]) || BYTE2(v42) != BYTE2(v48[1]) )
  {
    v40[0] = 0x5D464A92;
    *(_QWORD *)v47 = 0i64;
    v16 = 0x17E25D27;
    *(_DWORD *)&v47[8] = 0;
    v17 = 0i64;
    v40[1] = 0x5F108BE8;
    v40[2] = 0x485B1E62;
    a7 = v40;
    a8 = (__int64 *)v47;
    do
    {
      v16 = __ROR4__(
              ((v16 ^ (unsigned int)(v16 << 0xD)) >> 0x11) ^ v16 ^ (v16 << 0xD) ^ (0x20
                                                                                 * (((v16 ^ (unsigned int)(v16 << 0xD)) >> 0x11) ^ v16 ^ (v16 << 0xD))),
              2);
      *(_DWORD *)((char *)a8 + v17 * 4) = a7[v17] ^ v16;
      ++v17;
    }
    while ( v17 < 3 );
    v15 = 3;
    if ( v41 != *(_QWORD *)v47 || (_WORD)v42 != *(_WORD *)&v47[8] || BYTE2(v42) != v47[0xA] )
    {
      v32[0] = 0x2759C314;
      *(_QWORD *)v46 = 0i64;
      v18 = 0x4C2AA260;
      *(_DWORD *)&v46[8] = 0;
      v19 = 0i64;
      v46[0xC] = 0;
      v32[1] = 0xEA6C038F;
      v32[2] = 0x52BE6A42;
      v33 = 0xCB;
      a7 = (int *)v32;
      a8 = (__int64 *)v46;
      do
      {
        *(_DWORD *)((char *)a8 + v19 * 4) = a7[v19] ^ v18;
        ++v19;
        v18 = 0xFFFFCFC7 - 0x41C64E6D * v18;
      }
      while ( v19 < 3 );
      a7 = (int *)v32;
      a8 = (__int64 *)v46;
      v46[0xC] = v33 ^ v18;
      v15 = 7;
      if ( v41 != *(_QWORD *)v46 || v42 != *(_DWORD *)&v46[8] )
      {
        v36[0] = 0x4DA6DF91;
        *(_QWORD *)v44 = 0i64;
        v20 = 0x26D5BEE5;
        *(_DWORD *)&v44[8] = 0;
        v21 = 0i64;
        *(_WORD *)&v44[0xC] = 0;
        v44[0xE] = 0;
        v36[1] = 0x3BAF0AD6;
        v36[2] = 0x34C2C2F1;
        v37 = 0xFA2C;
        v38 = 0x8A;
        a7 = v36;
        a8 = (__int64 *)v44;
        do
        {
          *(_DWORD *)((char *)a8 + v21 * 4) = a7[v21] ^ v20;
          ++v21;
          v20 = ~(((v20 ^ (v20 << 0xD)) >> 0x11) ^ v20 ^ (v20 << 0xD) ^ (0x20
                                                                       * (((v20 ^ (v20 << 0xD)) >> 0x11) ^ v20 ^ (v20 << 0xD))));
        }
        while ( v21 < 3 );
        v22 = 0xCi64;
        a7 = v36;
        a8 = (__int64 *)v44;
        do
        {
          v23 = v20;
          v20 >>= 8;
          *((_BYTE *)a8 + v22) = *((_BYTE *)a7 + v22) ^ v23;
          ++v22;
        }
        while ( v22 < 0xF );
        v15 = 0xF;
        if ( v41 != *(_QWORD *)v44 || v42 != *(_DWORD *)&v44[8] || v43 != *(_WORD *)&v44[0xC] )
        {
          v34[0] = 0x7E65EC73;
          *(_QWORD *)v45 = 0i64;
          v24 = 0x15168D07;
          *(_DWORD *)&v45[8] = 0;
          v25 = 0i64;
          *(_WORD *)&v45[0xC] = 0;
          v34[1] = 0x3870CEA3;
          v34[2] = 0xA1433C20;
          v35 = 0x7EDE;
          a7 = v34;
          a8 = (__int64 *)v45;
          do
          {
            *(_DWORD *)((char *)a8 + v25 * 4) = a7[v25] ^ v24;
            ++v25;
            v24 = 0xFFFFCFC6 - 0x41C64E6D * v24;
          }
          while ( v25 < 3 );
          v26 = 0xCi64;
          a7 = v34;
          a8 = (__int64 *)v45;
          do
          {
            v27 = v24;
            v24 >>= 8;
            *((_BYTE *)a8 + v26) = *((_BYTE *)a7 + v26) ^ v27;
            ++v26;
          }
          while ( v26 < 0xE );
          v15 = 0x1F;
          if ( v41 != *(_QWORD *)v45 || v42 != *(_DWORD *)&v45[8] || (_BYTE)v43 != v45[0xC] )
          {
            v14 = 0;
LABEL_34:
            v15 &= 0xEFu;
            memset(v45, 0, sizeof(v45));
            goto LABEL_35;
          }
        }
      }
    }
  }
  if ( (v15 & 0x10) != 0 )
    goto LABEL_34;
LABEL_35:
  if ( (v15 & 8) != 0 )
  {
    v15 &= 0xF7u;
    memset(v44, 0, sizeof(v44));
  }
  if ( (v15 & 4) != 0 )
    memset(v46, 0, sizeof(v46));
  if ( (v15 & 2) != 0 )
    memset(v47, 0, sizeof(v47));
  LOBYTE(v11) = 0;
  memset(v48, 0, 0xCui64);
  if ( v14 )
  {
    *a1 |= 0x2000u;
    v11 = sub_14001449C(v9);
    if ( v11 && (LODWORD(v11) = sub_1400488FC(v11, (__int64)&Object), (int)v11 >= 0) )
    {
      if ( !sub_14000C2F4((__int64)Object, v28, v29, v30, v32[0]) )
        *a1 |= 0x4000u;
      LOBYTE(v11) = ObfDereferenceObject(Object);
    }
    else
    {
      *a1 |= 0x4000u;
    }
  }
  return v11;
}
// 14000E230: variable 'v28' is possibly undefined
// 14000E230: variable 'v29' is possibly undefined
// 14000E230: variable 'v30' is possibly undefined

//----- (000000014000E6C4) ----------------------------------------------------
void __fastcall sub_14000E6C4(__int64 a1)
{
  __int64 v2; // rcx
  __int64 i; // rdi
  __int64 v4; // rcx

  if ( a1 )
  {
    v2 = *(_QWORD *)a1;
    if ( v2 )
      sub_140051220(v2);
    if ( *(_BYTE *)(a1 + 0x10) )
      sub_14000724C(a1 + 0x18);
    for ( i = 0i64; (unsigned int)i < *(_DWORD *)(a1 + 0x28); i = (unsigned int)(i + 1) )
    {
      v4 = *(_QWORD *)(a1 + 0x18 * i + 0x38);
      if ( v4 )
        sub_140051220(v4);
    }
    sub_140051220(a1);
  }
}

//----- (000000014000EC40) ----------------------------------------------------
__int64 sub_14000EC40()
{
  __int64 (__fastcall *v0)(__int64); // r8
  __int64 result; // rax

  v0 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400D86E8,
                                          &qword_1400D86E8,
                                          0i64);
  result = 0i64;
  if ( v0 )
    result = v0(0xFFFFi64);
  return result;
}
// 1400D86E8: using guessed type __int64 qword_1400D86E8;

//----- (000000014000EC74) ----------------------------------------------------
__int64 sub_14000EC74()
{
  __int64 (__fastcall *v0)(_QWORD); // r8
  __int64 result; // rax

  v0 = (__int64 (__fastcall *)(_QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                         qword_1400D86F0,
                                         &qword_1400D86F0,
                                         0i64);
  result = 0i64;
  if ( v0 )
    result = v0(0i64);
  return result;
}
// 1400D86F0: using guessed type __int64 qword_1400D86F0;

//----- (000000014000ECA4) ----------------------------------------------------
__int64 __fastcall sub_14000ECA4(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400D86F8,
                                          &qword_1400D86F8,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400D86F8: using guessed type __int64 qword_1400D86F8;

//----- (000000014000ECDC) ----------------------------------------------------
__int64 sub_14000ECDC()
{
  __int64 (*v0)(void); // r8
  __int64 result; // rax

  v0 = (__int64 (*)(void))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                            qword_1400D86C8,
                            &qword_1400D86C8,
                            0i64);
  result = 0i64;
  if ( v0 )
    result = v0();
  return result;
}
// 1400D86C8: using guessed type __int64 qword_1400D86C8;

//----- (000000014000ED08) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14000ED08(__int64 a1, __int64 a2))(__int64, __int64)
{
  __int64 (__fastcall *result)(__int64, __int64); // rax

  result = (__int64 (__fastcall *)(__int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                       qword_1400D86D0,
                                                       &qword_1400D86D0,
                                                       0i64);
  if ( result )
    result = (__int64 (__fastcall *)(__int64, __int64))result(a1, a2);
  return result;
}
// 1400D86D0: using guessed type __int64 qword_1400D86D0;

//----- (000000014000ED48) ----------------------------------------------------
__int64 __fastcall sub_14000ED48(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64, _QWORD, __int64, _QWORD); // rax
  __int64 v3; // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                   qword_1400D8710,
                                                                   &qword_1400D8710,
                                                                   0i64);
  if ( v2 )
    result = v2(a1, 0i64, v3, 0i64);
  else
    result = 0xC0000002i64;
  return result;
}
// 14000ED7E: variable 'v3' is possibly undefined
// 1400D8710: using guessed type __int64 qword_1400D8710;

//----- (000000014000ED8C) ----------------------------------------------------
__int64 __fastcall sub_14000ED8C(__int64 a1, __int64 a2)
{
  __int64 (__fastcall *v4)(__int64, __int64); // r8
  __int64 result; // rax

  v4 = (__int64 (__fastcall *)(__int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                   qword_1400D8740,
                                                   &qword_1400D8740,
                                                   0i64);
  result = 0i64;
  if ( v4 )
    result = v4(a1, a2);
  return result;
}
// 1400D8740: using guessed type __int64 qword_1400D8740;

//----- (000000014000F914) ----------------------------------------------------
void __fastcall sub_14000F914(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  int v5; // edx
  __int64 v6; // rdi
  __int64 v7; // [rsp+20h] [rbp-78h]
  __int64 v8; // [rsp+28h] [rbp-70h]
  __int64 v9; // [rsp+30h] [rbp-68h]
  __int64 v10; // [rsp+38h] [rbp-60h]
  unsigned __int64 v11; // [rsp+40h] [rbp-58h] BYREF
  int v12; // [rsp+48h] [rbp-50h]
  int v13; // [rsp+4Ch] [rbp-4Ch]

  if ( a1 && a2 )
  {
    v5 = *(_DWORD *)(a2 + 0xC);
    if ( (v5 & 0xC0000000) == 0xC0000000 )
    {
      if ( (*(_DWORD *)(a1 + 0xA8) & 0xC0000000) == 0xC0000000 )
        return;
      *(_DWORD *)(a1 + 0xA8) = v5;
    }
    if ( qword_1400D82F8 )
    {
      if ( qword_1400D8308 )
      {
        if ( qword_1400D8310 )
        {
          v6 = sub_14002FD08(qword_1400D82F8, *(_DWORD *)a2, 0i64, a4, v7, v8, v9, v10);
          if ( v6 )
          {
            *(_QWORD *)(a2 + 4) = qword_1400D8318;
            sub_14005CF68((__int64)&v11);
            v12 = qword_1400D82F8 ^ 0x326787BA;
            v11 = v6 ^ 0xF4DF582E70BD87E4ui64;
            v13 = 0x8044DC0E;
            if ( !(unsigned __int8)((__int64 (__fastcall *)(__int64, __int64, __int64, __int64))loc_14000F7F8)(
                                     qword_1400D82F8,
                                     qword_1400D8308,
                                     qword_1400D8310,
                                     a2) )
            {
              if ( qword_1400D82F8 )
                sub_140014CAC(qword_1400D82F8, v6);
            }
          }
        }
      }
    }
  }
}
// 14000F992: variable 'v7' is possibly undefined
// 14000F992: variable 'v8' is possibly undefined
// 14000F992: variable 'v9' is possibly undefined
// 14000F992: variable 'v10' is possibly undefined
// 140014CAC: using guessed type __int64 __fastcall sub_140014CAC(_QWORD, _QWORD);
// 1400D82F8: using guessed type __int64 qword_1400D82F8;
// 1400D8308: using guessed type __int64 qword_1400D8308;
// 1400D8310: using guessed type __int64 qword_1400D8310;
// 1400D8318: using guessed type __int64 qword_1400D8318;

//----- (000000014000FA44) ----------------------------------------------------
void __fastcall sub_14000FA44(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  int v4; // eax
  int v5[10]; // [rsp+20h] [rbp-28h] BYREF

  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 0x10) )
    {
      v4 = *(_DWORD *)(a1 + 0x10);
      v5[3] = a2;
      v5[0] = 0x18;
      v5[5] = v4;
      sub_14000F914(a1, (__int64)v5, a3, a4);
    }
  }
}

//----- (000000014000FD64) ----------------------------------------------------
void __fastcall sub_14000FD64(__int64 a1, unsigned int *a2)
{
  unsigned int v4; // er12
  struct _FAST_MUTEX *v5; // r15
  __int64 v6; // r9
  __int64 v7; // r14
  char v8; // si
  __int64 v9; // rcx
  __int64 v10; // [rsp+20h] [rbp-68h]
  __int64 v11; // [rsp+28h] [rbp-60h]
  __int64 v12[11]; // [rsp+30h] [rbp-58h] BYREF

  if ( a1 )
  {
    if ( a2 )
    {
      v4 = *a2;
      if ( *a2 )
      {
        if ( a2[3] && KeGetCurrentIrql() <= 1u )
        {
          v5 = (struct _FAST_MUTEX *)(a1 + 0x1C8);
          v11 = a1 + 0x1C8;
          ExAcquireFastMutex((PFAST_MUTEX)(a1 + 0x1C8));
          v7 = sub_14002FD08(*(_QWORD *)(a1 + 0x10), v4, 0i64, v6, v10, v11, v12[0], v12[1]);
          ((void (__fastcall *)(unsigned int *, __int64, _QWORD, __int64))loc_14005CFA8)(
            a2,
            a1 + 0x1B8,
            *(_QWORD *)(a1 + 0x10),
            v7);
          if ( v7 )
          {
            v8 = 0;
            if ( sub_140015378(*(_QWORD *)(a1 + 8), (__int64)v12) )
            {
              ((void (__fastcall *)(__int64, unsigned int *, _QWORD))loc_14006F000)(v7, a2, v4);
              *(_QWORD *)(*(_QWORD *)(a1 + 0x1B0) + 8i64 * (unsigned int)(**(_DWORD **)(a1 + 0x1B0))++ + 8) = v7 - 0xFFFF010000i64;
              v8 = 1;
              ((void (__fastcall *)(_QWORD, __int64 *))loc_140015528)(*(_QWORD *)(a1 + 8), v12);
            }
            if ( !v8 )
            {
              v9 = *(_QWORD *)(a1 + 0x10);
              if ( v9 )
                sub_140014CAC(v9, v7);
            }
          }
          ExReleaseFastMutex(v5);
        }
      }
    }
  }
}
// 14000FDD3: variable 'v6' is possibly undefined
// 14000FDD3: variable 'v10' is possibly undefined
// 140014CAC: using guessed type __int64 __fastcall sub_140014CAC(_QWORD, _QWORD);

//----- (0000000140010198) ----------------------------------------------------
bool __fastcall sub_140010198(_BYTE *a1)
{
  _BYTE *v1; // rdx
  unsigned __int8 v3; // al
  unsigned __int8 v4; // cl
  int v5; // ecx
  bool v6; // zf
  int v7; // ecx
  int v8; // ecx
  int v9; // ecx
  bool v11; // zf
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  int v15; // ecx
  char v16; // cl

  v1 = a1;
  if ( !a1 )
    return 0;
  v3 = *a1;
  v4 = v3;
  if ( v3 >= 0x40u && v3 <= 0x4Fu )
    v4 = *++v1;
  if ( v4 > 0x7Au )
  {
    if ( v4 > 0xE3u )
    {
      v13 = v4 - 0xE9;
      if ( !v13 )
        return 1;
      v14 = v13 - 1;
      if ( !v14 )
        return 1;
      v15 = v14 - 1;
      if ( !v15 )
        return 1;
      if ( v15 != 0x14 )
        return 0;
      v16 = v1[1];
      if ( ((v16 - 0x25) & 0xF7) != 0 )
      {
        if ( ((v16 - 0x24) & 0xF7) != 0 )
          return 0;
        return ((v1[2] + 0x1B) & 0x3F) == 0;
      }
      return 1;
    }
    if ( v4 == 0xE3 )
      return 1;
    v12 = v4 - 0x7B;
    v11 = v12 == 0;
  }
  else
  {
    if ( v4 == 0x7A )
      return 1;
    if ( v4 <= 0x74u )
    {
      if ( v4 != 0x74 )
      {
        v5 = v4 - 0xF;
        if ( !v5 )
          return (unsigned __int8)(v1[1] + 0x80) <= 0xFu;
        v7 = v5 - 0x61;
        v6 = v7 == 0;
        goto LABEL_12;
      }
      return 1;
    }
    v12 = v4 - 0x75;
    v11 = v12 == 0;
  }
  if ( !v11 )
  {
    v7 = v12 - 1;
    v6 = v7 == 0;
LABEL_12:
    if ( v6 )
      return 1;
    v8 = v7 - 1;
    if ( !v8 )
      return 1;
    v9 = v8 - 1;
    if ( !v9 )
      return 1;
    return v9 == 1;
  }
  return 1;
}

//----- (0000000140010244) ----------------------------------------------------
__int64 __fastcall sub_140010244(__int16 *a1, __int64 a2, _QWORD *a3)
{
  __int64 v5; // rax
  int v6; // eax
  __int64 v7; // r8
  __int64 v8; // r9
  unsigned int v9; // er13
  char v10; // r12
  unsigned __int8 v12; // bl
  unsigned __int8 v13; // di
  unsigned __int64 v14; // rbp
  __int16 *v15; // rsi
  int v16; // er15
  int v17; // eax
  int v18; // eax
  int v19; // eax
  bool v20; // zf
  __int16 *v21; // rcx
  __int16 v22; // ax
  __int64 v23[3]; // [rsp+20h] [rbp-88h] BYREF
  __int64 v24; // [rsp+38h] [rbp-70h]
  int v25; // [rsp+40h] [rbp-68h]
  int v26; // [rsp+48h] [rbp-60h]
  int v27; // [rsp+50h] [rbp-58h]
  int v28; // [rsp+58h] [rbp-50h]
  _BYTE v29[5]; // [rsp+60h] [rbp-48h]
  __int64 v30; // [rsp+68h] [rbp-40h]
  __int64 v31; // [rsp+70h] [rbp-38h]

  v5 = sub_140048808();
  v6 = sub_140013EF0(v5);
  v9 = 0;
  v10 = 0;
  if ( !a1 )
    return 0i64;
  v12 = 0;
  v13 = 0;
  v14 = (unsigned __int64)a1 + a2;
  v15 = a1;
  v16 = v6;
  while ( (unsigned __int64)v15 < v14 )
  {
    if ( v16 != 0x40 )
    {
      if ( v16 != 0x20 )
        goto LABEL_28;
      sub_140023CA0(
        (__int64)v15,
        (__int64)v23,
        v7,
        v8,
        v23[0],
        v23[1],
        v23[2],
        v24,
        v25,
        v26,
        v27,
        v28,
        *(int *)v29,
        v30,
        v31);
      if ( !v19 )
        break;
      v18 = v24;
      if ( _bittest(&v18, 0xCu) )
        break;
      v13 = v23[0];
      if ( !_bittest(&v18, 9u) )
        goto LABEL_21;
      if ( (v24 & 4) != 0 )
        goto LABEL_22;
      if ( (v24 & 8) != 0 )
        goto LABEL_24;
      v20 = (v24 & 0x10) == 0;
LABEL_26:
      v12 = v13;
      if ( v20 )
        goto LABEL_28;
      goto LABEL_27;
    }
    sub_14001B640();
    if ( v17 )
    {
      v18 = *(_DWORD *)&v29[1];
      if ( !_bittest(&v18, 0xCu) )
      {
        v13 = v25;
        if ( _bittest(&v18, 9u) )
        {
          if ( (v29[1] & 4) == 0 )
          {
            if ( (v29[1] & 8) == 0 )
            {
              if ( (v29[1] & 0x10) == 0 )
              {
                v12 = v25;
                if ( (v29[1] & 0x20) != 0 )
                  v12 = v25 - 8;
LABEL_28:
                if ( v12 )
                  v9 = sub_14000512C(v15, v12, v9);
                if ( !sub_140010198(v15) )
                {
                  v21 = v15;
                  if ( !v15 )
                    goto LABEL_39;
                  if ( (unsigned __int8)(*(_BYTE *)v15 - 0x40) <= 0xFu )
                    v21 = (__int16 *)((char *)v15 + 1);
                  v22 = *v21;
                  if ( *v21 != 0x70F
                    && v22 != 0x350F
                    && (unsigned __int8)(v22 + 0x3E) > 1u
                    && (unsigned __int8)(v22 + 0x36) > 5u )
                  {
                    goto LABEL_39;
                  }
                }
                goto LABEL_38;
              }
LABEL_27:
              v12 = v13 - 4;
              goto LABEL_28;
            }
LABEL_24:
            v12 = v13 - 2;
            goto LABEL_28;
          }
LABEL_22:
          v12 = v13 - 1;
          goto LABEL_28;
        }
LABEL_21:
        if ( (v18 & 0x40) != 0 )
          goto LABEL_22;
        if ( (char)v18 < 0 )
          goto LABEL_24;
        v20 = (v18 & 0x100) == 0;
        goto LABEL_26;
      }
    }
LABEL_38:
    v10 = 1;
LABEL_39:
    v15 = (__int16 *)((char *)v15 + v13);
    if ( v10 )
      break;
  }
  if ( a3 )
    *a3 = (char *)v15 - (char *)a1;
  return v9;
}
// 1400102AE: variable 'v17' is possibly undefined
// 1400102F3: variable 'v7' is possibly undefined
// 1400102F3: variable 'v8' is possibly undefined
// 1400102FA: variable 'v19' is possibly undefined

//----- (000000014001055C) ----------------------------------------------------
void __fastcall sub_14001055C(unsigned int a1, __int64 a2, __int64 a3, unsigned int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int64 v9; // rbx
  __int64 v11; // rsi
  __int64 v13; // r13
  char v14; // bp
  unsigned __int64 v15; // r12
  __int64 v16; // rax
  __int64 v17; // rdi
  unsigned int v18; // er14
  unsigned __int64 v19; // rbp
  __int64 v20; // [rsp+40h] [rbp-48h]
  char v21[24]; // [rsp+48h] [rbp-40h] BYREF

  if ( a1 )
  {
    v9 = 0i64;
    v11 = a3;
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          v13 = a9;
          if ( a9 )
          {
            v14 = sub_140015854(0xFFFFFFFFFFFFFFFFui64, *(_QWORD *)(a2 + 8), (__int64)v21);
            v15 = 0x8000i64;
            v16 = sub_140055ECC(*(_QWORD *)(a2 + 8), 0x1000, 0x8000ui64, 2);
            v17 = v16;
            if ( v16 )
            {
              *(_QWORD *)(v16 + 0xE) = *(_QWORD *)a2;
              *(_DWORD *)(v16 + 0x16) = *(_DWORD *)(a2 + 0x18);
            }
            if ( v14 )
              sub_14000724C((__int64)v21);
            if ( v17 )
            {
              v18 = 0;
              if ( a4 )
              {
                do
                {
                  v19 = (unsigned int)(*(_DWORD *)(v11 + 0xC) + 1);
                  if ( v19 > v15 )
                    break;
                  ((void (__fastcall *)(__int64, _QWORD, _QWORD))loc_14006F000)(
                    v9 + v20,
                    *(_QWORD *)v11,
                    (unsigned int)v19);
                  v9 += v19;
                  v15 -= v19;
                  ++v18;
                  v11 += 0x18i64;
                }
                while ( v18 < a4 );
                v13 = a9;
              }
              ((void (__fastcall *)(__int64, _QWORD, __int64, __int64))loc_1400103E4)(v13, a1, v17, v9);
              sub_140051220(v17);
            }
          }
        }
      }
    }
  }
}
// 14001065B: variable 'v20' is possibly undefined

//----- (00000001400106BC) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_1400106BC()
{
  JUMPOUT(0x1400106DBi64);
}
// 140010BC6: positive sp value 28 has been found
// 1400106D4: control flows out of bounds to 1400106DB

//----- (00000001400115F4) ----------------------------------------------------
__int64 __fastcall sub_1400115F4(__int64 a1, __int64 a2)
{
  int v4; // er8
  unsigned __int64 i; // rdx
  __int64 result; // rax

  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x44i64);
  v4 = 0x1677BC45;
  for ( i = 0i64; i < 0x44; i += 4i64 )
  {
    v4 = __ROR4__(0x41C64E6D * v4 + 0x3039, 3);
    result = a2;
    *(_DWORD *)(a2 + i) = *(_DWORD *)(a1 + i) ^ v4;
  }
  return result;
}

//----- (0000000140011660) ----------------------------------------------------
__int64 __fastcall sub_140011660(__int64 a1)
{
  __int64 (__fastcall *v2)(char *, __int64, __int64, _QWORD); // rax
  __int64 v3; // r8
  char v5[24]; // [rsp+40h] [rbp-18h] BYREF

  if ( !sub_140069584()
    || !a1
    || !*(_QWORD *)(a1 + 8)
    || !*(_WORD *)a1
    || !*(_WORD *)(a1 + 2)
    || !sub_140007178((__int64)v5, (unsigned __int16 *)a1, *(_WORD *)a1) )
  {
    return 0i64;
  }
  v2 = (__int64 (__fastcall *)(char *, __int64, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                   qword_1400DAD00,
                                                                   &qword_1400DAD00,
                                                                   0i64);
  if ( v2 )
    v2(v5, 0x240i64, v3, 0i64);
  sub_14000724C((__int64)v5);
  return 0i64;
}
// 1400116FB: variable 'v3' is possibly undefined
// 1400DAD00: using guessed type __int64 qword_1400DAD00;

//----- (000000014001172C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_14001172C()
{
  JUMPOUT(0x140011751i64);
}
// 1400119D5: positive sp value B8 has been found
// 14001174A: control flows out of bounds to 140011751

//----- (0000000140012654) ----------------------------------------------------
__int64 sub_140012654()
{
  char v0; // si
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rdi
  __int64 v5; // rax
  __int64 v6; // rcx
  __int64 v7; // r8
  char v8; // dl
  __int64 v10; // [rsp+20h] [rbp-68h] BYREF
  int v11; // [rsp+28h] [rbp-60h]
  char v12[12]; // [rsp+2Ch] [rbp-5Ch] BYREF
  int v13[6]; // [rsp+38h] [rbp-50h] BYREF
  __int16 v14; // [rsp+50h] [rbp-38h]
  char v15[30]; // [rsp+52h] [rbp-36h] BYREF

  v0 = 0;
  v1 = 0i64;
  v2 = sub_140048808();
  if ( !(unsigned int)sub_140013EF0(v2) )
    goto LABEL_6;
  v13[0] = 0xC69EDB81;
  v13[1] = 0xF2CF9F85;
  v13[2] = 0x152F0BCD;
  v13[3] = 0xD3DF81E;
  v13[4] = 0x4CD5FBF6;
  v13[5] = 0xF5017A0F;
  v14 = 0x26ED;
  v3 = ((__int64 (__fastcall *)(int *, char *))loc_1400127F4)(v13, v15);
  v4 = sub_140052728(v3);
  v0 = 1;
  if ( !v4 )
    goto LABEL_6;
  v10 = 0xCB184F0EC9622911ui64;
  v11 = 0x9536CAA6;
  v5 = sub_140012888((__int64)&v10, (__int64)v12);
  v0 = 3;
  if ( sub_1400529D4(v4, v5) && (v1 = sub_140014BD0(v6, 0x1000i64, v7, 0x40i64, v10)) != 0 )
    v8 = 1;
  else
LABEL_6:
    v8 = 0;
  if ( (v0 & 2) != 0 )
  {
    v0 &= 0xFDu;
    memset(v12, 0, sizeof(v12));
  }
  if ( (v0 & 1) != 0 )
    memset(v15, 0, 0x1Aui64);
  if ( v8 )
  {
    sub_140052288(v1, 0x1000i64);
    JUMPOUT(0x140012799i64);
  }
  return v1;
}
// 140012795: control flows out of bounds to 140012799
// 140012739: variable 'v6' is possibly undefined
// 140012739: variable 'v7' is possibly undefined

//----- (0000000140012888) ----------------------------------------------------
__int64 __fastcall sub_140012888(__int64 a1, __int64 a2)
{
  int v2; // er8
  unsigned __int64 v3; // r9
  __int64 result; // rax

  v2 = 0x6A81337;
  *(_QWORD *)a2 = 0i64;
  v3 = 0i64;
  *(_DWORD *)(a2 + 8) = 0;
  do
  {
    v2 = __ROR4__(0x43FD43FD * v2 + 0xC39EC3, 2);
    result = a2;
    *(_DWORD *)(a2 + v3) = *(_DWORD *)(a1 + v3) ^ v2;
    v3 += 4i64;
  }
  while ( v3 < 0xC );
  return result;
}

//----- (000000014001298C) ----------------------------------------------------
__int64 __fastcall sub_14001298C(__int64 a1, __int64 (__fastcall *a2)(__int64), __int64 a3)
{
  __int64 result; // rax

  if ( a2 )
  {
    if ( a3 )
      result = a2(a3);
  }
  return result;
}

//----- (0000000140012A14) ----------------------------------------------------
char __fastcall sub_140012A14(HANDLE a1, __int64 a2, __int64 a3, int a4, PVOID Object, __int64 a6, __int64 a7, __int64 a8, char a9)
{
  char v9; // bl
  __int64 v14; // rax
  __int64 v15; // rbx
  __int64 v17; // rax
  __int64 v18; // rdi
  PVOID v19; // rbx
  void (__fastcall *v20)(__int64, PVOID, __int64, __int64 *); // rax
  __int64 v21; // r8
  __int64 (__fastcall *v22)(__int64, __int64, __int64, _QWORD); // rax
  PVOID v23; // rdi
  void (__fastcall *v24)(PVOID, _QWORD); // rax
  void (__fastcall *v25)(__int64); // rax
  __int64 v26; // rcx

  v9 = 0;
  if ( !a1 || !a2 )
    return 0;
  if ( a4 == 1 && PsGetCurrentThreadId() != a1 )
  {
    v14 = sub_140051084((unsigned int)(a4 + 0x1F));
    v15 = v14;
    if ( v14 )
    {
      *(_QWORD *)v14 = a1;
      *(_QWORD *)(v14 + 8) = a2;
      *(_QWORD *)(v14 + 0x10) = a3;
      *(_BYTE *)(v14 + 0x18) = a9;
      if ( (unsigned __int8)sub_140012A14((_DWORD)a1, (unsigned int)&dword_1400129CC, v14, 0, 0) )
        return a4;
      sub_140051220(v15);
    }
    return 0;
  }
  if ( KeGetCurrentIrql() > 1u || !byte_1400D83A2 )
    return 0;
  ExAcquireFastMutex(&stru_1400D8688);
  if ( !byte_1400D83A3 && (int)sub_1400489AC((__int64)a1, (__int64)&Object) >= 0 )
  {
    v17 = sub_140051084(0x58ui64);
    v18 = v17;
    if ( v17 )
    {
      ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(v17, 0i64, 0x58i64);
      v19 = Object;
      v20 = (void (__fastcall *)(__int64, PVOID, __int64, __int64 *))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                       qword_1400D8718,
                                                                       &qword_1400D8718,
                                                                       0i64);
      if ( v20 )
        v20(v18, v19, v21, qword_1400128D8);
      v22 = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                         qword_1400D8720,
                                                                         &qword_1400D8720,
                                                                         0i64);
      if ( v22 )
      {
        v9 = v22(v18, a2, a3, 0i64);
        if ( v9 )
        {
          _InterlockedIncrement(&dword_1400D8684);
          if ( a9 )
          {
            if ( a4 == 1 )
            {
              v25 = (void (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                    qword_1400D8728,
                                                    &qword_1400D8728,
                                                    0i64);
              if ( v25 )
              {
                LOBYTE(v26) = 1;
                v25(v26);
              }
            }
            else
            {
              v23 = Object;
              v24 = (void (__fastcall *)(PVOID, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                          qword_1400D8730,
                                                          &qword_1400D8730,
                                                          0i64);
              if ( v24 )
                v24(v23, 0i64);
            }
          }
          goto LABEL_27;
        }
      }
      else
      {
        v9 = 0;
      }
      sub_140051220(v18);
    }
LABEL_27:
    ObfDereferenceObject(Object);
  }
  ExReleaseFastMutex(&stru_1400D8688);
  return v9;
}
// 140012B94: variable 'v21' is possibly undefined
// 140012C1E: variable 'v26' is possibly undefined
// 1400128D8: using guessed type __int64 qword_1400128D8[22];
// 1400129CC: using guessed type int dword_1400129CC;
// 1400D83A2: using guessed type char byte_1400D83A2;
// 1400D83A3: using guessed type char byte_1400D83A3;
// 1400D8684: using guessed type int dword_1400D8684;
// 1400D8718: using guessed type __int64 qword_1400D8718;
// 1400D8720: using guessed type __int64 qword_1400D8720;
// 1400D8728: using guessed type __int64 qword_1400D8728;
// 1400D8730: using guessed type __int64 qword_1400D8730;

//----- (0000000140012C4C) ----------------------------------------------------
void sub_140012C4C()
{
  stru_1400D8688.Owner = 0i64;
  stru_1400D8688.Contention = 0;
  stru_1400D8688.Count = 1;
  KeInitializeEvent(&stru_1400D8688.Event, SynchronizationEvent, 0);
  byte_1400D83A2 = 1;
}
// 1400D83A2: using guessed type char byte_1400D83A2;

//----- (0000000140012C8C) ----------------------------------------------------
#error "140012CC8: call analysis failed (funcsize=18)"

//----- (000000014001354C) ----------------------------------------------------
__int64 __fastcall sub_14001354C(__int64 a1, unsigned __int64 a2)
{
  __int64 v2; // r9
  unsigned __int64 v5; // r11
  unsigned __int64 v6; // rcx
  __int64 v7; // rdx
  unsigned __int64 v8; // r8

  v2 = 0i64;
  v5 = (unsigned int)(*(_DWORD *)a1 - 1);
  if ( !*(_DWORD *)a1 || a1 == 0xFFFFFFFFFFFFFFF8ui64 )
    return 0i64;
  if ( *(_DWORD *)a1 == 1 )
  {
LABEL_9:
    if ( a2 >= *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8i64) )
      JUMPOUT(0x1400135C8i64);
  }
  else
  {
    while ( 1 )
    {
      v6 = v5 >> 1;
      v7 = *(_QWORD *)(a1 + 8 * (v5 >> 1) + 0x10);
      v8 = *(_QWORD *)(v7 + 8);
      if ( a2 >= v8 )
        break;
      v5 >>= 1;
      if ( !v6 )
        goto LABEL_9;
    }
    if ( a2 >= v8 + *(unsigned int *)(v7 + 0x10) )
      JUMPOUT(0x1400135A8i64);
    v2 = *(_QWORD *)(a1 + 8 * v6 + 0x10);
  }
  return v2;
}
// 1400135A5: control flows out of bounds to 1400135A8
// 1400135C5: control flows out of bounds to 1400135C8

//----- (00000001400135E4) ----------------------------------------------------
char __fastcall sub_1400135E4(__int64 a1, int a2, int a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  char v12; // bl
  __int64 v13; // rax
  unsigned int v14; // er10
  unsigned __int64 v15; // rdx

  v12 = 0;
  v13 = sub_14001354C(a1, a4);
  if ( v13 )
  {
    v14 = 0;
    if ( *(_WORD *)(v13 + 0x116) )
    {
      while ( 1 )
      {
        if ( (a2 & *(_DWORD *)(v13 + 0x28 * (v14 + 7i64) + 0x24)) == a2
          && (*(_DWORD *)(v13 + 0x28 * (v14 + 7i64) + 0x24) & a3) == 0 )
        {
          v15 = *(_QWORD *)(v13 + 8) + *(unsigned int *)(v13 + 0x28 * (v14 + 7i64) + 0xC);
          if ( a4 >= v15 && a4 + a9 > a4 && a4 + a9 <= v15 + *(unsigned int *)(v13 + 0x28 * (v14 + 7i64) + 8) )
            break;
        }
        if ( ++v14 >= *(unsigned __int16 *)(v13 + 0x116) )
          return v12;
      }
      v12 = 1;
    }
  }
  return v12;
}

//----- (0000000140013698) ----------------------------------------------------
__int64 __fastcall sub_140013698(__int64 *a1, unsigned __int64 a2, __int64 a3, char a4, __int64 a5)
{
  unsigned __int64 v6; // rax
  unsigned __int64 v8; // rsi
  __int64 *i; // rdi
  __int64 v10; // r15
  __int64 v11; // r14
  __int64 v12; // r9
  __int64 result; // rax
  __int64 *v14; // rbx
  __int64 v15; // rbp
  __int64 v16; // r14
  __int64 *v17; // r8
  unsigned __int64 v18; // r9
  __int64 j; // r14
  __int64 *v20; // rsi
  __int64 *v21; // rcx
  __int64 v22; // rdx
  __int64 v23; // [rsp+30h] [rbp-28h] BYREF
  __int64 v24; // [rsp+38h] [rbp-20h]

  v6 = a2 - (_QWORD)a1;
  v8 = a2;
  for ( i = a1; ; v6 = v8 - (_QWORD)i )
  {
    result = v6 & 0xFFFFFFFFFFFFFFF8ui64;
    if ( result <= 0x100 )
    {
      if ( i != (__int64 *)v8 )
      {
        v14 = i + 1;
        if ( i + 1 != (__int64 *)v8 )
        {
          v15 = 1i64;
          do
          {
            v16 = *v14;
            v17 = v14;
            result = *i;
            v18 = *(_QWORD *)(*v14 + 8);
            if ( v18 >= *(_QWORD *)(*i + 8) )
            {
              v21 = &i[v15 - 1];
              v22 = *v21;
              if ( v18 < *(_QWORD *)(*v21 + 8) )
              {
                do
                {
                  *v17 = v22;
                  v17 = v21;
                  v21 += 0xFFFFFFFF;
                  v22 = *v21;
                  result = *(_QWORD *)(*v21 + 8);
                }
                while ( *(_QWORD *)(v16 + 8) < (unsigned __int64)result );
              }
              *v17 = v16;
            }
            else
            {
              result = ((__int64 (__fastcall *)(__int64 *, __int64 *, __int64))loc_14006F000)(i + 1, i, v15 * 8);
              *i = v16;
            }
            ++v14;
            ++v15;
          }
          while ( v14 != (__int64 *)v8 );
        }
      }
      return result;
    }
    if ( a3 <= 0 )
      break;
    sub_14001387C(&v23, i, v8);
    v10 = v23;
    v11 = v24;
    a3 = (a3 >> 2) + (a3 >> 1);
    LOBYTE(v12) = a4;
    if ( (__int64)((v23 - (_QWORD)i) & 0xFFFFFFFFFFFFFFF8ui64) >= (__int64)((v8 - v24) & 0xFFFFFFFFFFFFFFF8ui64) )
    {
      sub_140013698(v24, v8, a3, v12);
      v8 = v10;
    }
    else
    {
      sub_140013698(i, v23, a3, v12);
      i = (__int64 *)v11;
    }
  }
  for ( j = (__int64)(v8 - (_QWORD)i) >> 4;
        j > 0;
        result = sub_140013B84((__int64)i, j, (__int64)(v8 - (_QWORD)i) >> 3, &a5) )
  {
    a5 = i[--j];
  }
  if ( (__int64)(v8 - (_QWORD)i) >> 3 >= 2 )
  {
    v20 = (__int64 *)(v8 - 8);
    do
    {
      a5 = *v20;
      *v20 = *i;
      sub_140013B84((__int64)i, 0i64, v20 - i, &a5);
      v20 += 0xFFFFFFFF;
      result = ((unsigned __int64)v20 + 8i64 - (_QWORD)i) & 0xFFFFFFFFFFFFFFF8ui64;
    }
    while ( result >= 0x10 );
  }
  return result;
}
// 14001371C: variable 'v12' is possibly undefined

//----- (000000014001387C) ----------------------------------------------------
_QWORD *__fastcall sub_14001387C(_QWORD *a1, _QWORD *a2, unsigned __int64 a3)
{
  __int64 *v3; // r11
  _QWORD *v7; // r9
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // r14
  __int64 v11; // rcx
  __int64 v12; // r8
  __int64 v13; // rdx
  __int64 v14; // rdx
  __int64 v15; // r8
  _QWORD *v16; // rdx
  __int64 v17; // rbx
  __int64 v18; // rbx
  __int64 *v19; // rdi
  __int64 *v20; // rdx
  __int64 v21; // r8
  __int64 v22; // rbx
  __int64 v23; // r8
  __int64 v24; // r11
  __int64 v25; // r8
  __int64 v26; // r11
  __int64 v27; // rdx
  __int64 v28; // rdx
  __int64 v29; // rcx
  __int64 v30; // rdx
  _QWORD *v31; // rdx
  __int64 v32; // rax
  _QWORD *v33; // r11
  __int64 v34; // rbx
  unsigned __int64 v35; // rcx
  unsigned __int64 v36; // r8
  _QWORD *v37; // r8
  _QWORD *v38; // r11
  unsigned __int64 v39; // rcx
  __int64 v40; // rax
  bool v41; // zf
  _QWORD *v42; // rcx
  unsigned __int64 v43; // rax
  __int64 v44; // rax
  __int64 v45; // rcx
  __int64 v46; // rcx
  __int64 v47; // rcx
  __int64 v48; // rcx
  _QWORD *result; // rax

  v3 = (__int64 *)(a3 - 8);
  v7 = &a2[(__int64)(a3 - (_QWORD)a2) >> 4];
  v8 = (__int64)(a3 - 8 - (_QWORD)a2) >> 3;
  if ( v8 <= 0x28 )
  {
    v28 = *a2;
    v29 = *v7;
    if ( *(_QWORD *)(*v7 + 8i64) < *(_QWORD *)(v28 + 8) )
    {
      *v7 = v28;
      *a2 = v29;
      v29 = *v7;
    }
    v30 = *v3;
    if ( *(_QWORD *)(*v3 + 8) < *(_QWORD *)(v29 + 8) )
    {
      *v3 = v29;
      *v7 = v30;
      if ( *(_QWORD *)(v30 + 8) < *(_QWORD *)(*a2 + 8i64) )
      {
        *v7 = *a2;
        *a2 = v30;
      }
    }
  }
  else
  {
    v9 = (v8 + 1) >> 3;
    v10 = 0x10 * v9;
    v11 = 8 * v9;
    v12 = a2[v9];
    v13 = *a2;
    if ( *(_QWORD *)(v12 + 8) < *(_QWORD *)(v13 + 8) )
    {
      a2[(unsigned __int64)v11 / 8] = v13;
      *a2 = v12;
      v12 = a2[(unsigned __int64)v11 / 8];
    }
    v14 = a2[(unsigned __int64)v10 / 8];
    if ( *(_QWORD *)(v14 + 8) < *(_QWORD *)(v12 + 8) )
    {
      a2[(unsigned __int64)v10 / 8] = v12;
      a2[(unsigned __int64)v11 / 8] = v14;
      if ( *(_QWORD *)(v14 + 8) < *(_QWORD *)(*a2 + 8i64) )
      {
        a2[(unsigned __int64)v11 / 8] = *a2;
        *a2 = v14;
      }
    }
    v15 = *v7;
    v16 = &v7[v11 / 0xFFFFFFFFFFFFFFF8ui64];
    v17 = v7[-v9];
    if ( *(_QWORD *)(*v7 + 8i64) < *(_QWORD *)(v17 + 8) )
    {
      *v7 = v17;
      *v16 = v15;
      v15 = *v7;
    }
    v18 = v7[(unsigned __int64)v11 / 8];
    if ( *(_QWORD *)(v18 + 8) < *(_QWORD *)(v15 + 8) )
    {
      v7[(unsigned __int64)v11 / 8] = v15;
      *v7 = v18;
      if ( *(_QWORD *)(v18 + 8) < *(_QWORD *)(*v16 + 8i64) )
      {
        *v7 = *v16;
        *v16 = v18;
      }
    }
    v19 = &v3[v10 / 0xFFFFFFFFFFFFFFF8ui64];
    v20 = &v3[v11 / 0xFFFFFFFFFFFFFFF8ui64];
    v21 = v3[0xFFFFFFFE * v9];
    v22 = v3[-v9];
    if ( *(_QWORD *)(v22 + 8) < *(_QWORD *)(v21 + 8) )
    {
      *v20 = v21;
      *v19 = v22;
      v22 = *v20;
    }
    v23 = *v3;
    if ( *(_QWORD *)(*v3 + 8) < *(_QWORD *)(v22 + 8) )
    {
      *v3 = v22;
      *v20 = v23;
      if ( *(_QWORD *)(v23 + 8) < *(_QWORD *)(*v19 + 8) )
      {
        *v20 = *v19;
        *v19 = v23;
      }
    }
    v24 = a2[(unsigned __int64)v11 / 8];
    v25 = *v7;
    if ( *(_QWORD *)(*v7 + 8i64) < *(_QWORD *)(v24 + 8) )
    {
      *v7 = v24;
      a2[(unsigned __int64)v11 / 8] = v25;
      v25 = *v7;
    }
    v26 = *v20;
    if ( *(_QWORD *)(*v20 + 8) < *(_QWORD *)(v25 + 8) )
    {
      *v20 = v25;
      *v7 = v26;
      v27 = a2[(unsigned __int64)v11 / 8];
      if ( *(_QWORD *)(v26 + 8) < *(_QWORD *)(v27 + 8) )
      {
        *v7 = v27;
        a2[(unsigned __int64)v11 / 8] = v26;
      }
    }
  }
  v31 = v7 + 1;
  if ( a2 < v7 )
  {
    v32 = *v7;
    do
    {
      v33 = v7 + 0xFFFFFFFF;
      v34 = v7[0xFFFFFFFF];
      v35 = *(_QWORD *)(v34 + 8);
      if ( v35 < *(_QWORD *)(v32 + 8) )
        break;
      if ( v35 > *(_QWORD *)(v32 + 8) )
        break;
      v7 += 0xFFFFFFFF;
      v32 = v34;
    }
    while ( a2 < v33 );
  }
  if ( (unsigned __int64)v31 < a3 )
  {
    v36 = *(_QWORD *)(*v7 + 8i64);
    do
    {
      if ( *(_QWORD *)(*v31 + 8i64) < v36 )
        break;
      if ( *(_QWORD *)(*v31 + 8i64) > v36 )
        break;
      ++v31;
    }
    while ( (unsigned __int64)v31 < a3 );
  }
  v37 = v31;
  v38 = v7;
  while ( 1 )
  {
    while ( (unsigned __int64)v37 < a3 )
    {
      v39 = *(_QWORD *)(*v7 + 8i64);
      if ( v39 < *(_QWORD *)(*v37 + 8i64) )
        goto LABEL_43;
      if ( v39 > *(_QWORD *)(*v37 + 8i64) )
        break;
      if ( v31 != v37 )
      {
        v40 = *v31;
        *v31 = *v37;
        *v37 = v40;
      }
      ++v31;
LABEL_43:
      ++v37;
    }
    v41 = v38 == a2;
    if ( v38 > a2 )
    {
      v42 = v38 + 0xFFFFFFFF;
      do
      {
        v43 = *(_QWORD *)(*v7 + 8i64);
        if ( *(_QWORD *)(*v42 + 8i64) >= v43 )
        {
          if ( *(_QWORD *)(*v42 + 8i64) > v43 )
            break;
          v7 += 0xFFFFFFFF;
          if ( v7 != v42 )
          {
            v44 = *v7;
            *v7 = *v42;
            *v42 = v44;
          }
        }
        v38 += 0xFFFFFFFF;
        v42 += 0xFFFFFFFF;
      }
      while ( a2 < v38 );
      v41 = v38 == a2;
    }
    if ( v41 )
      break;
    v38 += 0xFFFFFFFF;
    if ( v37 != (_QWORD *)a3 )
    {
      v48 = *v37;
      *v37 = *v38;
      *v38 = v48;
      goto LABEL_43;
    }
    v7 += 0xFFFFFFFF;
    if ( v38 == v7 )
    {
      v47 = *v7;
    }
    else
    {
      v47 = *v38;
      *v38 = *v7;
      *v7 = v47;
    }
    v31 += 0xFFFFFFFF;
    *v7 = *v31;
    *v31 = v47;
  }
  if ( v37 != (_QWORD *)a3 )
  {
    if ( v31 != v37 )
    {
      v45 = *v7;
      *v7 = *v31;
      *v31 = v45;
    }
    v46 = *v7;
    ++v31;
    *v7++ = *v37;
    *v37 = v46;
    goto LABEL_43;
  }
  result = a1;
  *a1 = v7;
  a1[1] = v31;
  return result;
}

//----- (0000000140013B84) ----------------------------------------------------
__int64 __fastcall sub_140013B84(__int64 a1, __int64 a2, __int64 a3, __int64 *a4)
{
  __int64 v5; // rbx
  __int64 v6; // r10
  __int64 v7; // rsi
  __int64 i; // rcx
  __int64 v9; // rdx
  __int64 v10; // r8
  __int64 result; // rax

  v5 = (a3 - 1) >> 1;
  v6 = a2;
  v7 = a2;
  for ( i = a2; i < v5; v6 = i )
  {
    i = 2 * i
      + 2i64
      - (*(_QWORD *)(*(_QWORD *)(a1 + 0x10 * i + 0x10) + 8i64) < *(_QWORD *)(*(_QWORD *)(a1 + 0x10 * i + 8) + 8i64));
    *(_QWORD *)(a1 + 8 * v6) = *(_QWORD *)(a1 + 8 * i);
  }
  if ( i == v5 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * v6) = *(_QWORD *)(a1 + 8 * a3 - 8);
    v6 = a3 - 1;
  }
  if ( a2 < v6 )
  {
    do
    {
      v9 = (v6 - 1) >> 1;
      v10 = *(_QWORD *)(a1 + 8 * v9);
      if ( *(_QWORD *)(v10 + 8) >= *(_QWORD *)(*a4 + 8) )
        break;
      *(_QWORD *)(a1 + 8 * v6) = v10;
      v6 = (v6 - 1) >> 1;
    }
    while ( v7 < v9 );
  }
  result = *a4;
  *(_QWORD *)(a1 + 8 * v6) = *a4;
  return result;
}

//----- (0000000140013C40) ----------------------------------------------------
char __fastcall sub_140013C40(int a1)
{
  unsigned int v1; // er9
  int v2; // er11
  unsigned int v3; // ebp
  int v4; // er15
  unsigned __int64 v5; // rdx
  unsigned __int64 v6; // r10
  _WORD *v7; // rsi
  int v8; // edi
  unsigned __int64 v9; // rcx

  v1 = 0;
  v2 = a1 - 0x40000000;
  v3 = *(_DWORD *)(MEMORY[0x14000003C] + 0x1400000B4i64);
  if ( v3 )
  {
    v4 = *(_DWORD *)(MEMORY[0x14000003C] + 0x1400000B0i64);
    v5 = v2 & 0xFFFFF000;
    do
    {
      v6 = *(unsigned int *)(v4 + v1 + 0x140000000i64);
      if ( v6 > v5 )
        break;
      if ( (_DWORD)v6 + 0x1000 == v5 || v6 == v5 )
      {
        v7 = (_WORD *)(v4 + v1 + 0x140000008i64);
        v8 = 0;
        v9 = ((unsigned __int64)*(unsigned int *)(v4 + v1 + 0x140000004i64) - 8) >> 1;
        if ( v9 )
        {
          while ( (*v7 & 0xF000) != 0xA000
               || (_DWORD)v6 + (*v7 & 0xFF8) != v2 && v6 + (((*v7 & 0xFFF) + 8i64) & 0xFFFFFFFFFFFFFFF8ui64) != v2 )
          {
            ++v8;
            ++v7;
            if ( v8 >= v9 )
              goto LABEL_11;
          }
          return 1;
        }
      }
LABEL_11:
      v1 += *(_DWORD *)(v4 + v1 + 0x140000004i64);
    }
    while ( v1 < v3 );
  }
  return 0;
}

//----- (0000000140013D4C) ----------------------------------------------------
char __fastcall sub_140013D4C(__int64 a1)
{
  char v1; // bl
  unsigned __int8 (__fastcall *v3)(__int64); // rax

  v1 = 0;
  if ( a1 )
  {
    v3 = (unsigned __int8 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                    qword_1400DAE60,
                                                    &qword_1400DAE60,
                                                    0i64);
    if ( !v3 || !v3(a1) )
      v1 = 1;
  }
  return v1;
}
// 1400DAE60: using guessed type __int64 qword_1400DAE60;

//----- (0000000140013D94) ----------------------------------------------------
bool __fastcall sub_140013D94(__int64 a1, void *a2, __int64 a3, __int64 a4, __int16 a5, __int64 a6, PVOID Object)
{
  bool v7; // bl
  __int64 (__fastcall *v10)(void *); // rax
  char v11; // bp
  __int64 v12; // rdx
  char v14[72]; // [rsp+20h] [rbp-48h] BYREF

  v7 = 0;
  if ( !a1 || !a2 || !qword_1400D8248 )
    return 0;
  v10 = (__int64 (__fastcall *)(void *))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAD18,
                                          &qword_1400DAD18,
                                          0i64);
  if ( v10 )
    v11 = v10(a2);
  else
    v11 = 0;
  if ( (int)sub_1400488FC(a1, (__int64)&Object) >= 0 )
  {
    if ( sub_140015378((__int64)Object, (__int64)v14) )
    {
      a5 = 0;
      sub_1400615A4((__int64)a2, v12, (__int64)&a5);
      v7 = ObCloseHandle(a2, v11 == 0) >= 0;
      ((void (__fastcall *)(PVOID, char *))loc_140015528)(Object, v14);
    }
    ObfDereferenceObject(Object);
  }
  return v7;
}
// 140013E26: variable 'v12' is possibly undefined
// 1400D8248: using guessed type __int64 qword_1400D8248;
// 1400DAD18: using guessed type __int64 qword_1400DAD18;

//----- (0000000140013E74) ----------------------------------------------------
bool __fastcall sub_140013E74(__int64 a1, __int64 *a2)
{
  bool v2; // bl
  __int64 (__fastcall *v5)(__int64); // rax
  __int64 v6; // rax

  v2 = 0;
  if ( a1 && a2 )
  {
    v5 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                            qword_1400DAE50,
                                            &qword_1400DAE50,
                                            0i64);
    if ( v5 )
      v6 = v5(a1);
    else
      v6 = 0i64;
    *a2 = v6;
    v2 = v6 != 0;
  }
  return v2;
}
// 1400DAE50: using guessed type __int64 qword_1400DAE50;

//----- (0000000140013ED8) ----------------------------------------------------
__int64 sub_140013ED8()
{
  __int64 v0; // rax

  v0 = sub_140048808();
  return sub_140013EF0(v0);
}

//----- (0000000140013EF0) ----------------------------------------------------
__int64 __fastcall sub_140013EF0(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 v3; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAE98,
                                          &qword_1400DAE98,
                                          0i64);
  v3 = 0i64;
  if ( v2 )
    v3 = v2(a1);
  return v3 != 0 ? 0x20 : 0x40;
}
// 1400DAE98: using guessed type __int64 qword_1400DAE98;

//----- (0000000140014038) ----------------------------------------------------
void sub_140014038()
{
  JUMPOUT(0x140014054i64);
}
// 140014052: control flows out of bounds to 140014054

//----- (0000000140014260) ----------------------------------------------------
__int64 __fastcall sub_140014260(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAE88,
                                          &qword_1400DAE88,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAE88: using guessed type __int64 qword_1400DAE88;

//----- (0000000140014298) ----------------------------------------------------
__int64 __fastcall sub_140014298(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAE98,
                                          &qword_1400DAE98,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAE98: using guessed type __int64 qword_1400DAE98;

//----- (00000001400142D0) ----------------------------------------------------
__int64 __fastcall sub_1400142D0(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAE90,
                                          &qword_1400DAE90,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAE90: using guessed type __int64 qword_1400DAE90;

//----- (0000000140014308) ----------------------------------------------------
#error "140014338: call analysis failed (funcsize=41)"

//----- (0000000140014384) ----------------------------------------------------
__int64 __fastcall sub_140014384(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  __int64 v5; // rsi
  unsigned __int64 v7; // rbx
  struct _KTHREAD *v8; // rdi
  unsigned int v9; // eax
  struct _FAST_MUTEX *v10; // rdi
  char *v11; // rbp
  int v12; // eax
  __int64 v13; // rbp
  void (__fastcall *v14)(__int64); // rax

  v5 = 0i64;
  v7 = 4i64;
  if ( a1 )
  {
    v8 = KeGetCurrentThread();
    v9 = sub_1400650C0();
    if ( v8 )
    {
      if ( v9 )
      {
        if ( *(_QWORD *)((char *)v8 + v9) )
        {
          v10 = (struct _FAST_MUTEX *)sub_14001F828(1);
          if ( v10 )
          {
            do
            {
              if ( (unsigned int)v5 >= 0x200 )
                break;
              if ( (int)sub_1400489AC(v7, (__int64)&Object) >= 0 )
              {
                v11 = (char *)Object;
                v12 = sub_1400650C0();
                if ( v11 && v12 )
                  v13 = *(_QWORD *)&v11[v12];
                else
                  v13 = 0i64;
                if ( !sub_14001FAD4(v10, v13) )
                {
                  v14 = (void (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                        qword_1400DACF0,
                                                        &qword_1400DACF0,
                                                        0i64);
                  v14(v13);
                  *(_QWORD *)(a1 + 8 * v5) = v13;
                  v5 = (unsigned int)(v5 + 1);
                  sub_14001F904(v10, v13, 0i64, 0);
                }
                ObfDereferenceObject(Object);
              }
              v7 += 4i64;
            }
            while ( v7 < 0x10000 );
            sub_14001FBDC(v10);
          }
        }
      }
    }
  }
  return (unsigned int)v5;
}
// 1400DACF0: using guessed type __int64 qword_1400DACF0;

//----- (000000014001449C) ----------------------------------------------------
__int64 __fastcall sub_14001449C(__int64 a1)
{
  __int64 v1; // rbx
  __int64 (__fastcall *v3)(__int64); // rax

  v1 = 0i64;
  if ( a1 )
  {
    v3 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                            qword_1400DAE80,
                                            &qword_1400DAE80,
                                            0i64);
    if ( v3 )
      v1 = v3(a1);
  }
  return v1;
}
// 1400DAE80: using guessed type __int64 qword_1400DAE80;

//----- (00000001400144E4) ----------------------------------------------------
char __fastcall sub_1400144E4(__int64 a1, _BYTE *a2)
{
  _BYTE *v2; // rbx
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // r8
  char result; // al
  char v7; // cl

  v2 = a2;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v3 = sub_1400488C4(a1);
  if ( !v3 )
    return 0;
  v4 = 0x10i64;
  v5 = v3 - (_QWORD)v2;
  result = 1;
  while ( v4 != 0xFFFFFFFF80000012ui64 )
  {
    v7 = v2[v5];
    if ( v7 )
    {
      *v2++ = v7;
      if ( --v4 )
        continue;
    }
    if ( !v4 )
    {
      v2[0xFFFFFFFF] = 0;
      return result;
    }
    break;
  }
  *v2 = 0;
  return result;
}

//----- (0000000140014544) ----------------------------------------------------
char __fastcall sub_140014544(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v4; // rsi
  __int64 v6; // [rsp+20h] [rbp-28h]
  __int64 v7; // [rsp+28h] [rbp-20h]
  void *v8; // [rsp+30h] [rbp-18h]

  if ( !a1 || !a2 )
    return 0;
  v4 = sub_140014914(a1, 0x1000u, a3, a4, v6, v7, v8);
  if ( v4 )
  {
    sub_140061AA4(v4, 0x1Bu, 0i64, 0);
    sub_1400612D4(v4);
  }
  return 0;
}
// 140014576: variable 'v6' is possibly undefined
// 140014576: variable 'v7' is possibly undefined
// 140014576: variable 'v8' is possibly undefined

//----- (0000000140014648) ----------------------------------------------------
char __fastcall sub_140014648(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rax
  __int64 v5; // rsi
  char v7[56]; // [rsp+38h] [rbp-50h] BYREF

  if ( !a1 || !a3 )
    return 0;
  if ( sub_140015378(a1, (__int64)v7) )
  {
    v4 = sub_140014260(a1);
    if ( v4 )
    {
      v5 = *(_QWORD *)(v4 + 0x20);
      if ( v5 )
      {
        sub_14005221C(*(_QWORD *)(v4 + 0x20), 0x80i64, 1);
        if ( *(_DWORD *)(v5 + 4) >= 0x80u )
          JUMPOUT(0x1400146CEi64);
      }
    }
    ((void (__fastcall *)(__int64, char *))loc_140015528)(a1, v7);
  }
  return 0;
}
// 1400146CB: control flows out of bounds to 1400146CE

//----- (0000000140014760) ----------------------------------------------------
char __fastcall sub_140014760(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned __int64 a5)
{
  char v5; // bl
  __int64 v8; // rbp
  __int64 v9; // r8

  v5 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = sub_1400142D0(a1);
      if ( v8 )
      {
        if ( (int)sub_1400384B8(a1, 0x200u, v9, 0x1000u) >= 0 )
        {
          v5 = sub_140015854(a5, v8, a2);
          sub_1400612D4(a5);
        }
      }
    }
  }
  return v5;
}
// 1400147BE: variable 'v9' is possibly undefined

//----- (00000001400147FC) ----------------------------------------------------
char __fastcall sub_1400147FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  char v5; // bl
  int (__fastcall *v8)(__int64, PVOID *); // rax
  __int64 v9; // r8
  __int64 v10; // r9
  struct _OBJECT_NAME_INFORMATION *v12; // [rsp+20h] [rbp-8h]

  v5 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      v8 = (int (__fastcall *)(__int64, PVOID *))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                   qword_1400DAED0,
                                                   &qword_1400DAED0,
                                                   0i64);
      if ( v8 )
      {
        if ( v8(a1, &Object) >= 0 )
        {
          v5 = sub_14000ACA0((struct _FILE_OBJECT *)Object, a2, v9, v10, v12);
          ObfDereferenceObject(Object);
        }
      }
    }
  }
  return v5;
}
// 14001484E: variable 'v9' is possibly undefined
// 14001484E: variable 'v10' is possibly undefined
// 14001484E: variable 'v12' is possibly undefined
// 1400DAED0: using guessed type __int64 qword_1400DAED0;

//----- (0000000140014874) ----------------------------------------------------
bool __fastcall sub_140014874(unsigned __int16 *a1, __int64 a2, __int64 a3, __int64 a4)
{
  bool v4; // bl
  char v5; // si
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // rdi
  __int64 v12; // rcx
  bool v13; // zf
  __int64 v14; // rcx
  unsigned __int64 v15; // rax
  unsigned int v16; // [rsp+20h] [rbp-18h] BYREF
  __int64 v17; // [rsp+28h] [rbp-10h]

  v4 = 0;
  v5 = a2;
  if ( !a1 )
    return 0;
  v8 = sub_14002D72C((__int64)a1, a2, a3, a4, v16);
  v11 = v8;
  if ( v8 )
  {
    v12 = v8 + 8;
    if ( !v5 )
      v12 += *(unsigned __int16 *)(v8 + 0x2E);
    v13 = v12 == 0xFFFFFFFFFFFFFFD8ui64;
    v14 = v12 + 0x28;
    v17 = v14;
    if ( v13 )
    {
      v16 = 0;
    }
    else
    {
      v15 = 0xFFFFFFFFFFFFFFFFui64;
      do
        ++v15;
      while ( *(_BYTE *)(v14 + v15) );
      LOWORD(v16) = v15;
      HIWORD(v16) = v15 + 1;
    }
    v4 = (int)sub_140007274(a1, (unsigned __int16 *)&v16, v9, v10, v16) >= 0;
    sub_140051220(v11);
  }
  return v4;
}
// 1400148E8: variable 'v9' is possibly undefined
// 1400148E8: variable 'v10' is possibly undefined

//----- (0000000140014914) ----------------------------------------------------
unsigned __int64 __fastcall sub_140014914(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, PVOID Object)
{
  __int64 v9; // rax
  __int64 v11; // r8

  v9 = sub_140048808();
  if ( a1 == sub_14004888C(v9) )
    return 0xFFFFFFFFFFFFFFFFui64;
  if ( a1 && (int)sub_1400488FC(a1, (__int64)&Object) >= 0 )
  {
    sub_1400384B8((__int64)Object, 0x200u, v11, a2);
    JUMPOUT(0x140014994i64);
  }
  return 0i64;
}
// 140014992: control flows out of bounds to 140014994
// 140014988: variable 'v11' is possibly undefined

//----- (00000001400149C0) ----------------------------------------------------
char __fastcall sub_1400149C0(__int64 a1, ULONG64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  char v8; // bl
  char v10[56]; // [rsp+28h] [rbp-40h] BYREF

  v8 = 0;
  if ( !a1 || !a2 || !a3 || !a4 )
    return 0;
  if ( (int)sub_1400488FC(a1, (__int64)&Object) >= 0 )
  {
    if ( sub_140015378((__int64)Object, (__int64)v10) )
    {
      sub_14005221C(a2, a4, 1);
      ((void (__fastcall *)(__int64, ULONG64, __int64))loc_14006F000)(a3, a2, a4);
      v8 = 1;
      ((void (__fastcall *)(PVOID, char *))loc_140015528)(Object, v10);
    }
    ObfDereferenceObject(Object);
  }
  return v8;
}

//----- (0000000140014A78) ----------------------------------------------------
char __fastcall sub_140014A78(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  char v8; // bl
  char v10[56]; // [rsp+28h] [rbp-40h] BYREF

  v8 = 0;
  if ( !a1 || !a2 || !a3 || !a4 )
    return 0;
  if ( (int)sub_1400488FC(a1, (__int64)&Object) >= 0 )
  {
    if ( sub_140015378((__int64)Object, (__int64)v10) )
    {
      sub_140052288(a2, a4);
      ((void (__fastcall *)(unsigned __int64, __int64, __int64))loc_14006F000)(a2, a3, a4);
      v8 = 1;
      ((void (__fastcall *)(PVOID, char *))loc_140015528)(Object, v10);
    }
    ObfDereferenceObject(Object);
  }
  return v8;
}

//----- (0000000140014B2C) ----------------------------------------------------
char __fastcall sub_140014B2C(__int64 a1, ULONG64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  char v7; // bl
  char v9[56]; // [rsp+28h] [rbp-40h] BYREF

  v7 = 0;
  if ( !a1 || !a2 || !a3 )
    return 0;
  if ( (int)sub_1400488FC(a1, (__int64)&Object) >= 0 )
  {
    if ( sub_140015378((__int64)Object, (__int64)v9) )
    {
      sub_14005221C(a2, a3, 1);
      ((void (__fastcall *)(ULONG64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, a3);
      v7 = 1;
      ((void (__fastcall *)(PVOID, char *))loc_140015528)(Object, v9);
    }
    ObfDereferenceObject(Object);
  }
  return v7;
}

//----- (0000000140014BD0) ----------------------------------------------------
__int64 __fastcall sub_140014BD0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v6[3]; // [rsp+30h] [rbp-18h] BYREF

  a5 = a2;
  v6[0] = 0i64;
  if ( a2 )
  {
    sub_1400616FC(0xFFFFFFFFFFFFFFFFui64, (__int64)v6, 0i64, (__int64)&a5);
    JUMPOUT(0x140014C0Ci64);
  }
  return 0i64;
}
// 140014C0A: control flows out of bounds to 140014C0C

//----- (0000000140014C20) ----------------------------------------------------
bool __fastcall sub_140014C20(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6)
{
  bool result; // al

  a5 = a1;
  a6 = a2;
  if ( a1 && a2 && a3 && a4 )
    result = (int)sub_140061928(0xFFFFFFFFFFFFFFFFui64, (__int64)&a5, (__int64)&a6, a3) >= 0;
  else
    result = 0;
  return result;
}

//----- (0000000140014C6C) ----------------------------------------------------
bool __fastcall sub_140014C6C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  bool result; // al

  a5 = a1;
  a6 = 0i64;
  if ( a1 )
    result = (int)sub_140061870(0xFFFFFFFFFFFFFFFFui64, (__int64)&a5, (__int64)&a6, 0x8000u) >= 0;
  else
    result = 0;
  return result;
}

//----- (0000000140014CAC) ----------------------------------------------------
#error "140014CCF: call analysis failed (funcsize=32)"

//----- (0000000140014E50) ----------------------------------------------------
char __fastcall sub_140014E50(__int64 a1, char a2, __int64 *a3)
{
  __int64 v5; // rax
  _QWORD *v6; // r14
  __int64 v7; // rax
  _DWORD *v8; // rbx
  __int64 *v9; // r13
  __int64 v10; // rbx
  unsigned __int64 v11; // rax
  unsigned __int64 v12; // rax
  bool v13; // zf
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rax
  unsigned __int64 v18; // rax
  unsigned __int64 v19; // rax
  __int64 v21; // [rsp+138h] [rbp+67h]

  if ( !a3 )
    return 0;
  *a3 = 0i64;
  v5 = sub_140051084(0x100000ui64);
  v6 = (_QWORD *)v5;
  if ( v5 )
  {
    if ( (unsigned __int8)((__int64 (__fastcall *)(unsigned __int64, _QWORD, __int64, __int64))loc_140014D18)(
                            0xFFFFFFFFFFFFFFFFui64,
                            0i64,
                            1i64,
                            v5) )
    {
      v7 = sub_140051084(0x800ui64);
      v8 = (_DWORD *)v7;
      if ( v7 )
      {
        ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(v7 + 8, 0i64, 0x7F8i64);
        v21 = 0i64;
        *v8 = 0x10;
        v8[1] = 0x800;
        v13 = *v6 == 0i64;
        *a3 = (__int64)v8;
        if ( !v13 )
        {
          v9 = v6 + 1;
          while ( 1 )
          {
            v11 = *v9 & 0x1F;
            if ( v11 > 0x12 )
              break;
            if ( v11 != 0x12 )
            {
              v12 = v11 - 2;
              if ( v12 )
              {
                v14 = v12 - 1;
                v13 = v14 == 0;
                goto LABEL_12;
              }
            }
LABEL_19:
            if ( a2 )
            {
              v10 = *v9;
              if ( !_bittest64(&v10, 8u) )
                JUMPOUT(0x140014F78i64);
            }
LABEL_23:
            ++v9;
            if ( (unsigned __int64)++v21 >= *v6 )
              goto LABEL_24;
          }
          v14 = v11 - 0x13;
          v13 = v14 == 0;
LABEL_12:
          if ( !v13 )
          {
            v15 = v14 - 3;
            if ( !v15 )
              goto LABEL_22;
            v16 = v15 - 1;
            if ( v16 )
            {
              v17 = v16 - 3;
              if ( v17 )
              {
                v18 = v17 - 1;
                if ( v18 )
                {
                  v19 = v18 - 3;
                  if ( !v19 )
LABEL_22:
                    JUMPOUT(0x14001505Di64);
                  if ( v19 != 1 )
                    goto LABEL_23;
                }
              }
            }
          }
          goto LABEL_19;
        }
LABEL_24:
        sub_140051220(*a3);
        *a3 = 0i64;
      }
      else
      {
        *a3 = 0i64;
      }
    }
    sub_140051220((__int64)v6);
  }
  return 0;
}
// 140014F75: control flows out of bounds to 140014F78
// 14001505A: control flows out of bounds to 14001505D

//----- (00000001400151F8) ----------------------------------------------------
#error "14001520E: call analysis failed (funcsize=20)"

//----- (0000000140015378) ----------------------------------------------------
char __fastcall sub_140015378(__int64 a1, __int64 a2)
{
  char v2; // bl
  int (__fastcall *v5)(__int64); // rax

  v2 = 0;
  if ( a1 && a2 )
  {
    if ( sub_140048808() == a1 )
    {
      *(_QWORD *)(a2 + 0x20) = 1i64;
      v2 = 1;
    }
    else
    {
      v5 = (int (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAE30,
                                          &qword_1400DAE30,
                                          0i64);
      if ( v5 )
      {
        if ( v5(a1) >= 0 )
        {
          sub_14000ED08(a1, a2);
          v2 = 1;
          if ( sub_140048808() != a1 )
            sub_14000D5A4();
        }
      }
    }
  }
  return v2;
}
// 1400DAE30: using guessed type __int64 qword_1400DAE30;

//----- (00000001400157F4) ----------------------------------------------------
char __fastcall sub_1400157F4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  char v4; // bl
  __int64 v7; // r8
  __int64 v8; // r9
  void *v10; // [rsp+20h] [rbp-8h]
  unsigned __int64 v11; // [rsp+20h] [rbp-8h]

  v4 = 0;
  if ( a1
    && a2
    && (sub_1400147FC(a1, a2, a3, a4, v10) || sub_140014760(a1, a2, v7, v8, v11) || sub_140014648(a1, 0i64, a2)) )
  {
    v4 = 1;
  }
  return v4;
}
// 140015815: variable 'v10' is possibly undefined
// 140015824: variable 'v7' is possibly undefined
// 140015824: variable 'v8' is possibly undefined
// 140015824: variable 'v11' is possibly undefined

//----- (0000000140015854) ----------------------------------------------------
char __fastcall sub_140015854(__int64 a1, __int64 a2, __int64 a3)
{
  char v3; // bl
  __int64 v7; // rax
  unsigned __int16 *v8; // rdi

  v3 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        v7 = sub_140051084(0x212ui64);
        v8 = (unsigned __int16 *)v7;
        if ( v7 )
        {
          *(_DWORD *)v7 = 0x2000000;
          *(_QWORD *)(v7 + 8) = v7 + 0x10;
          if ( (unsigned __int8)((__int64 (__fastcall *)(__int64, __int64, __int64, __int64))loc_140014D18)(
                                  a1,
                                  a2,
                                  2i64,
                                  v7) )
          {
            *(_WORD *)(*((_QWORD *)v8 + 1) + 2 * ((unsigned __int64)*v8 >> 1)) = 0;
            v3 = sub_1400070E0(a3, *((_QWORD *)v8 + 1));
          }
          sub_140051220((__int64)v8);
        }
      }
    }
  }
  return v3;
}

//----- (0000000140015A8C) ----------------------------------------------------
__int64 __fastcall sub_140015A8C(ULONG64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  if ( a4 + 0x14 <= (unsigned __int64)(a9 - 6) && sub_140030674(a1) && a2 )
    sub_1400307A8((__int64)a1);
  return a4;
}
// 140015B01: conditional instruction was optimized away because of '%var_10.4==0'

//----- (0000000140015C14) ----------------------------------------------------
char __fastcall sub_140015C14(__int64 a1, unsigned int *a2, __int64 a3, __int64 a4, __int64 a5, int a6, unsigned __int64 a7)
{
  void **v7; // rax
  int v10; // edx
  __int64 v11; // rcx
  __int64 v12; // r14
  struct _FAST_MUTEX *v13; // rcx
  __int64 v14; // rsi
  unsigned __int64 v15; // rbx
  unsigned __int64 v16; // rdx
  unsigned __int64 v17; // rcx
  void *retaddr; // [rsp+38h] [rbp+0h] BYREF

  v7 = &retaddr;
  if ( a2[0xA] < 0x20 )
  {
    LOBYTE(v7) = sub_1400451F0(a1, &a6, &a7);
    if ( (_BYTE)v7 )
    {
      v10 = a6;
      if ( a6 != 0x4AE709D7 || (v7 = *(void ***)a2, (*(_DWORD *)(*(_QWORD *)a2 + 0x1Ai64) & 0x200) == 0) )
      {
        v11 = a2[0xA];
        v12 = 3 * (v11 + 2);
        a2[0xA] = v11 + 1;
        a2[2 * v12 + 4] = 0;
        a2[2 * v12] = v10;
        if ( v10 == 0x3384201A )
        {
          v13 = qword_1400D8370;
          LODWORD(v14) = 0x14;
          *(_DWORD *)(*(_QWORD *)a2 + 0x1Ai64) |= 0x100u;
          sub_14001F904(v13, *(unsigned __int16 *)(*(_QWORD *)a2 + 0x220i64), 0i64, 0);
          v15 = a7;
        }
        else
        {
          v14 = *(unsigned int *)(a1 + 8);
          v16 = *(_QWORD *)a1;
          v17 = *(_QWORD *)a1 + v14;
          if ( (unsigned int)v14 < 0x8000 || (LODWORD(v14) = 0x8000, v15 = a7 - 0x4000, a7 - 0x4000 < v16) || v15 > v17 )
          {
            v15 = v16;
          }
          else if ( v15 + 0x8000 > v17 )
          {
            v15 = v17 - 0x8000;
          }
        }
        v7 = (void **)sub_140051084((unsigned int)v14);
        *(_QWORD *)&a2[2 * v12 + 2] = v7;
        if ( v7 )
        {
          a2[2 * v12 + 4] = v14;
          LOBYTE(v7) = ((__int64 (__fastcall *)(void **, unsigned __int64, _QWORD))loc_14006F000)(
                         v7,
                         v15,
                         (unsigned int)v14);
        }
      }
    }
  }
  return (char)v7;
}

//----- (0000000140015EE4) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140015EE4()
{
  JUMPOUT(0x140015F2Fi64);
}
// 140016103: positive sp value 190 has been found
// 140015F2C: control flows out of bounds to 140015F2F

//----- (0000000140016104) ----------------------------------------------------
void __fastcall sub_140016104(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x140016127i64);
}
// 140016124: control flows out of bounds to 140016127

//----- (00000001400167AC) ----------------------------------------------------
char __fastcall sub_1400167AC(ULONG64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  char v6; // bl
  __int64 v8; // r14
  ULONG64 v9; // rdi
  unsigned __int16 i; // si

  v6 = 0;
  if ( !a1 )
    return 0;
  sub_14005221C(a1, 0x1000i64, 1);
  if ( sub_14005240C(a1, 0x1000ui64, 0i64, &a5) )
  {
    v8 = a5;
    v9 = *(unsigned __int16 *)(a5 + 0x14) + a5 + 0x18;
    for ( i = 0; i < *(_WORD *)(v8 + 6); ++i )
    {
      sub_14005221C(v9, 0x28i64, 1);
      if ( *(_DWORD *)(v9 + 1) == 0x30706D76 )
        return 1;
      v9 += 0x28i64;
    }
  }
  return v6;
}

//----- (0000000140016B18) ----------------------------------------------------
char __fastcall sub_140016B18(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 8) && *(_WORD *)a1 && *(_WORD *)(a1 + 2) )
    JUMPOUT(0x140016B84i64);
  return 0;
}
// 140016B80: control flows out of bounds to 140016B84

//----- (0000000140016F8C) ----------------------------------------------------
char __fastcall sub_140016F8C(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 8) && *(_WORD *)a1 && *(_WORD *)(a1 + 2) )
    JUMPOUT(0x140016FF2i64);
  return 0;
}
// 140016FEE: control flows out of bounds to 140016FF2

//----- (00000001400172C0) ----------------------------------------------------
char __fastcall sub_1400172C0(ULONG64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v7; // bl
  int v8; // eax

  v7 = 0;
  if ( a1 )
  {
    sub_14005221C(a1, 0x1000i64, 1);
    if ( sub_14005240C(a1, 0x1000ui64, 0i64, &a6) )
    {
      if ( *(_WORD *)(a6 + 0x16) == 0x10F && *(_WORD *)(a6 + 6) == 5 )
      {
        v8 = *(_DWORD *)(a6 + 8);
        if ( v8 == 0x4EA2A728 || v8 == 0x503F67EC || v8 == 0x512C56A2 || v8 == 0x55EAA341 )
          v7 = 1;
      }
    }
  }
  return v7;
}

//----- (0000000140017608) ----------------------------------------------------
__int64 __fastcall sub_140017608(__int64 a1, _DWORD *a2, _DWORD *a3, _DWORD *a4)
{
  *a2 = 0;
  *a3 = 0;
  *a4 = 0;
  if ( sub_140051084(0x200ui64) )
    JUMPOUT(0x140017653i64);
  return 0i64;
}
// 14001764F: control flows out of bounds to 140017653

//----- (00000001400176F0) ----------------------------------------------------
unsigned __int8 __fastcall sub_1400176F0(unsigned __int8 *a1, unsigned int a2, __int64 a3)
{
  unsigned __int8 v3; // si
  unsigned int v6; // edi
  unsigned __int8 *v7; // rbp
  __int64 v8; // r10
  __int64 v9; // r9
  __int64 v10; // r8
  __int64 v11; // r11
  __int64 v12; // rbx
  __int64 v13; // rax
  __int64 v14; // rax
  __int64 v15; // rax
  __int64 v16; // rax
  __int64 v17; // rax
  __int64 v18; // rdx

  v3 = 0;
  v6 = 0;
  if ( a2 )
  {
    v7 = a1;
    do
    {
      if ( v6 >= 4 )
      {
        v8 = *v7;
        v9 = a1[v6 - 1];
        v10 = a1[v6 - 2];
        v11 = a1[v6 - 3];
        v12 = a1[v6 - 4];
        v3 = byte_1400BCE40[v3 ^ (unsigned __int64)byte_1400BCE40[v9 ^ byte_1400BCE40[v8 ^ 1]]];
        v13 = byte_1400BCE40[v10 ^ byte_1400BCE40[v9 ^ byte_1400BCE40[v8 ^ 0x31]]];
        ++*(_DWORD *)(a3 + 4 * v13);
        v14 = byte_1400BCE40[v11 ^ byte_1400BCE40[v9 ^ byte_1400BCE40[(unsigned int)v8 ^ 0xCi64]]];
        ++*(_DWORD *)(a3 + 4 * v14);
        v15 = byte_1400BCE40[v11 ^ byte_1400BCE40[v10 ^ byte_1400BCE40[(unsigned int)v8 ^ 0xB2i64]]];
        ++*(_DWORD *)(a3 + 4 * v15);
        v16 = byte_1400BCE40[v12 ^ byte_1400BCE40[v10 ^ byte_1400BCE40[(unsigned int)v8 ^ 0xA6i64]]];
        ++*(_DWORD *)(a3 + 4 * v16);
        v17 = byte_1400BCE40[v12 ^ byte_1400BCE40[v9 ^ byte_1400BCE40[(unsigned int)v8 ^ 0x54i64]]];
        v18 = v12 ^ byte_1400BCE40[v11 ^ byte_1400BCE40[v8 ^ 0xE6]];
        ++*(_DWORD *)(a3 + 4 * v17);
        ++*(_DWORD *)(a3 + 4i64 * byte_1400BCE40[v18]);
      }
      ++v6;
      ++v7;
    }
    while ( v6 < a2 );
  }
  return v3;
}

//----- (000000014001786C) ----------------------------------------------------
char __fastcall sub_14001786C(__int64 a1, unsigned int a2, __int64 a3)
{
  if ( a1 && a2 >= 0x100 && a3 && a2 <= 0xFBC96A80 )
    JUMPOUT(0x1400178B0i64);
  return 0;
}
// 1400178AA: control flows out of bounds to 1400178B0

//----- (0000000140017A60) ----------------------------------------------------
__int64 __fastcall sub_140017A60(char *a1, unsigned int *a2, __int64 a3, char a4)
{
  signed __int64 v5; // rax
  unsigned int *v7; // rsi
  char *i; // rdi
  __int64 v9; // r9
  __int64 result; // rax
  unsigned int *j; // rbx
  __int64 v12; // rdx
  __int64 v13; // rcx
  __int64 v14; // r10
  __int64 v15; // r9
  __int64 v16; // r8
  unsigned int k; // er11
  __int64 l; // rax
  unsigned int v19; // er8
  char *v20; // rsi
  unsigned int v21; // er11
  __int64 v22; // r8
  __int64 v23; // rcx
  __int64 v24; // rdx
  __int64 v25; // r9
  __int64 m; // rax
  unsigned int v27; // edx
  __int64 v28; // rax
  unsigned int v29; // ebp
  _DWORD *v30; // rdx
  char *v31; // [rsp+20h] [rbp-18h] BYREF
  char *v32; // [rsp+28h] [rbp-10h]

  v5 = (char *)a2 - a1;
  v7 = a2;
  for ( i = a1; ; v5 = (char *)v7 - i )
  {
    result = v5 & 0xFFFFFFFFFFFFFFFCui64;
    if ( result <= 0x80 )
    {
      if ( i != (char *)v7 )
      {
        for ( j = (unsigned int *)(i + 4); j != v7; ++j )
        {
          v29 = *j;
          v30 = j;
          if ( *j >= *(_DWORD *)i )
          {
            for ( result = (__int64)(j + 0xFFFFFFFF); v29 < *(_DWORD *)result; result -= 4i64 )
            {
              *v30 = *(_DWORD *)result;
              v30 = (_DWORD *)result;
            }
            *v30 = v29;
          }
          else
          {
            result = ((__int64 (__fastcall *)(char *, char *))loc_14006F000)(i + 4, i);
            *(_DWORD *)i = v29;
          }
        }
      }
      return result;
    }
    if ( a3 <= 0 )
      break;
    sub_140017CBC(&v31, i, v7);
    a3 = (a3 >> 2) + (a3 >> 1);
    LOBYTE(v9) = a4;
    if ( (__int64)((v31 - i) & 0xFFFFFFFFFFFFFFFCui64) >= (__int64)(((char *)v7 - v32) & 0xFFFFFFFFFFFFFFFCui64) )
    {
      sub_140017A60(v32, v7, a3, v9);
      v7 = (unsigned int *)v31;
    }
    else
    {
      sub_140017A60(i, v31, a3, v9);
      i = v32;
    }
  }
  v12 = ((char *)v7 - i) >> 2;
  v13 = ((char *)v7 - i) >> 3;
  if ( v13 > 0 )
  {
    v14 = (v12 - 1) >> 1;
    do
    {
      v15 = --v13;
      v16 = v13;
      for ( k = *(_DWORD *)&i[4 * v13]; v16 < v14; v15 = v16 )
      {
        v16 = 2 * v16 + 2;
        if ( *(_DWORD *)&i[4 * v16] < *(_DWORD *)&i[4 * v16 - 4] )
          --v16;
        *(_DWORD *)&i[4 * v15] = *(_DWORD *)&i[4 * v16];
      }
      if ( v16 == v14 && (v12 & 1) == 0 )
      {
        *(_DWORD *)&i[4 * v15] = *(_DWORD *)&i[4 * v12 - 4];
        v15 = v12 - 1;
      }
      for ( l = v15 - 1; ; l = result - 1 )
      {
        result = l >> 1;
        if ( v13 >= v15 )
          break;
        v19 = *(_DWORD *)&i[4 * result];
        if ( v19 >= k )
          break;
        *(_DWORD *)&i[4 * v15] = v19;
        v15 = result;
      }
      *(_DWORD *)&i[4 * v15] = k;
    }
    while ( v13 > 0 );
  }
  if ( v12 >= 2 )
  {
    v20 = (char *)(v7 + 0xFFFFFFFF);
    do
    {
      v21 = *(_DWORD *)v20;
      v22 = (v20 - i) >> 2;
      v23 = 0i64;
      v24 = 0i64;
      *(_DWORD *)v20 = *(_DWORD *)i;
      v25 = (v22 - 1) >> 1;
      if ( v25 > 0 )
      {
        do
        {
          v24 = 2 * v24 + 2;
          if ( *(_DWORD *)&i[4 * v24] < *(_DWORD *)&i[4 * v24 - 4] )
            --v24;
          *(_DWORD *)&i[4 * v23] = *(_DWORD *)&i[4 * v24];
          v23 = v24;
        }
        while ( v24 < v25 );
      }
      if ( v24 == v25 && (v22 & 1) == 0 )
      {
        *(_DWORD *)&i[4 * v23] = *(_DWORD *)&i[4 * v22 - 4];
        v23 = v22 - 1;
      }
      for ( m = v23 - 1; ; m = v28 - 1 )
      {
        v28 = m >> 1;
        if ( v23 <= 0 )
          break;
        v27 = *(_DWORD *)&i[4 * v28];
        if ( v27 >= v21 )
          break;
        *(_DWORD *)&i[4 * v23] = v27;
        v23 = v28;
      }
      v20 += 0xFFFFFFFC;
      *(_DWORD *)&i[4 * v23] = v21;
      result = (unsigned __int64)&v20[4i64 - (_QWORD)i] & 0xFFFFFFFFFFFFFFFCui64;
    }
    while ( result >= 8 );
  }
  return result;
}
// 140017ADC: variable 'v9' is possibly undefined

//----- (0000000140017CBC) ----------------------------------------------------
char **__fastcall sub_140017CBC(char **a1, char *a2, unsigned int *a3)
{
  unsigned int *v3; // r11
  char *v7; // r9
  __int64 v8; // rax
  unsigned int v9; // ecx
  __int64 v10; // rax
  __int64 v11; // rsi
  __int64 v12; // rax
  unsigned int v13; // edx
  unsigned int v14; // ecx
  unsigned int v15; // edx
  unsigned int *v16; // rcx
  unsigned int v17; // er8
  unsigned int v18; // er8
  unsigned int *v19; // rcx
  unsigned int *v20; // rbx
  unsigned int v21; // er8
  unsigned int v22; // edx
  unsigned int v23; // edx
  unsigned int v24; // edx
  unsigned int v25; // er8
  unsigned int v26; // er8
  unsigned int v27; // ecx
  unsigned int v28; // eax
  unsigned int v29; // ecx
  unsigned int *v30; // rdx
  unsigned int v31; // eax
  char *v32; // r8
  unsigned int v33; // ecx
  unsigned int v34; // ecx
  unsigned int *v35; // r8
  char *v36; // r11
  unsigned int v37; // ecx
  unsigned int v38; // eax
  bool v39; // zf
  char *v40; // rcx
  unsigned int v41; // ebx
  unsigned int v42; // eax
  unsigned int v43; // ecx
  unsigned int v44; // ecx
  unsigned int v45; // ecx
  unsigned int v46; // ecx
  char **result; // rax

  v3 = a3 + 0xFFFFFFFF;
  v7 = &a2[4 * (((char *)a3 - a2) >> 3)];
  v8 = ((char *)(a3 + 0xFFFFFFFF) - a2) >> 2;
  if ( v8 <= 0x28 )
  {
    v28 = *(_DWORD *)v7;
    if ( *(_DWORD *)v7 < *(_DWORD *)a2 )
    {
      *(_DWORD *)v7 = *(_DWORD *)a2;
      *(_DWORD *)a2 = v28;
      v28 = *(_DWORD *)v7;
    }
    v29 = *v3;
    if ( *v3 < v28 )
    {
      *v3 = v28;
      *(_DWORD *)v7 = v29;
      if ( v29 < *(_DWORD *)a2 )
      {
        *(_DWORD *)v7 = *(_DWORD *)a2;
        *(_DWORD *)a2 = v29;
      }
    }
  }
  else
  {
    v9 = *(_DWORD *)a2;
    v10 = (v8 + 1) >> 3;
    v11 = 8 * v10;
    v12 = 4 * v10;
    v13 = *(_DWORD *)&a2[v12];
    if ( v13 < v9 )
    {
      *(_DWORD *)&a2[v12] = v9;
      *(_DWORD *)a2 = v13;
      v13 = *(_DWORD *)&a2[v12];
    }
    v14 = *(_DWORD *)&a2[v11];
    if ( v14 < v13 )
    {
      *(_DWORD *)&a2[v11] = v13;
      *(_DWORD *)&a2[v12] = v14;
      if ( v14 < *(_DWORD *)a2 )
      {
        *(_DWORD *)&a2[v12] = *(_DWORD *)a2;
        *(_DWORD *)a2 = v14;
      }
    }
    v15 = *(_DWORD *)v7;
    v16 = (unsigned int *)&v7[-v12];
    v17 = *(_DWORD *)&v7[-v12];
    if ( *(_DWORD *)v7 < v17 )
    {
      *(_DWORD *)v7 = v17;
      *v16 = v15;
      v15 = *(_DWORD *)v7;
    }
    v18 = *(_DWORD *)&v7[v12];
    if ( v18 < v15 )
    {
      *(_DWORD *)&v7[v12] = v15;
      *(_DWORD *)v7 = v18;
      if ( v18 < *v16 )
      {
        *(_DWORD *)v7 = *v16;
        *v16 = v18;
      }
    }
    v19 = &v3[v12 / 0xFFFFFFFFFFFFFFFCui64];
    v20 = &v3[v11 / 0xFFFFFFFFFFFFFFFCui64];
    v21 = v3[v12 / 0xFFFFFFFFFFFFFFFCui64];
    v22 = v3[v11 / 0xFFFFFFFFFFFFFFFCui64];
    if ( v21 < v22 )
    {
      *v19 = v22;
      *v20 = v21;
      v21 = *v19;
    }
    v23 = *v3;
    if ( *v3 < v21 )
    {
      *v3 = v21;
      *v19 = v23;
      if ( v23 < *v20 )
      {
        *v19 = *v20;
        *v20 = v23;
      }
    }
    v24 = *(_DWORD *)v7;
    v25 = *(_DWORD *)&a2[v12];
    if ( *(_DWORD *)v7 < v25 )
    {
      *(_DWORD *)v7 = v25;
      *(_DWORD *)&a2[v12] = v24;
      v24 = *(_DWORD *)v7;
    }
    v26 = *v19;
    if ( *v19 < v24 )
    {
      *v19 = v24;
      *(_DWORD *)v7 = v26;
      v27 = *(_DWORD *)&a2[v12];
      if ( v26 < v27 )
      {
        *(_DWORD *)v7 = v27;
        *(_DWORD *)&a2[v12] = v26;
      }
    }
  }
  v30 = (unsigned int *)(v7 + 4);
  if ( a2 < v7 )
  {
    v31 = *(_DWORD *)v7;
    do
    {
      v32 = v7 + 0xFFFFFFFC;
      v33 = *((_DWORD *)v7 + 0xFFFFFFFF);
      if ( v33 < v31 )
        break;
      if ( v33 > v31 )
        break;
      v7 += 0xFFFFFFFC;
      v31 = v33;
    }
    while ( a2 < v32 );
  }
  if ( v30 < a3 )
  {
    v34 = *(_DWORD *)v7;
    do
    {
      if ( *v30 < v34 )
        break;
      if ( *v30 > v34 )
        break;
      ++v30;
    }
    while ( v30 < a3 );
  }
  v35 = v30;
  v36 = v7;
  while ( 1 )
  {
    while ( v35 < a3 )
    {
      v37 = *v35;
      if ( *(_DWORD *)v7 < *v35 )
        goto LABEL_43;
      if ( *(_DWORD *)v7 > v37 )
        break;
      if ( v30 != v35 )
      {
        v38 = *v30;
        *v30 = v37;
        *v35 = v38;
      }
      ++v30;
LABEL_43:
      ++v35;
    }
    v39 = v36 == a2;
    if ( v36 > a2 )
    {
      v40 = v36 + 0xFFFFFFFC;
      do
      {
        v41 = *(_DWORD *)v40;
        if ( *(_DWORD *)v40 >= *(_DWORD *)v7 )
        {
          if ( v41 > *(_DWORD *)v7 )
            break;
          v7 += 0xFFFFFFFC;
          if ( v7 != v40 )
          {
            v42 = *(_DWORD *)v7;
            *(_DWORD *)v7 = v41;
            *(_DWORD *)v40 = v42;
          }
        }
        v36 += 0xFFFFFFFC;
        v40 += 0xFFFFFFFC;
      }
      while ( a2 < v36 );
      v39 = v36 == a2;
    }
    if ( v39 )
      break;
    v36 += 0xFFFFFFFC;
    if ( v35 != a3 )
    {
      v46 = *v35;
      *v35 = *(_DWORD *)v36;
      *(_DWORD *)v36 = v46;
      goto LABEL_43;
    }
    v7 += 0xFFFFFFFC;
    if ( v36 == v7 )
    {
      v45 = *(_DWORD *)v7;
    }
    else
    {
      v45 = *(_DWORD *)v36;
      *(_DWORD *)v36 = *(_DWORD *)v7;
      *(_DWORD *)v7 = v45;
    }
    v30 += 0xFFFFFFFF;
    *(_DWORD *)v7 = *v30;
    *v30 = v45;
  }
  if ( v35 != a3 )
  {
    if ( v30 != v35 )
    {
      v43 = *(_DWORD *)v7;
      *(_DWORD *)v7 = *v30;
      *v30 = v43;
    }
    v44 = *(_DWORD *)v7;
    ++v30;
    *(_DWORD *)v7 = *v35;
    v7 += 4;
    *v35 = v44;
    goto LABEL_43;
  }
  result = a1;
  *a1 = v7;
  a1[1] = (char *)v30;
  return result;
}

//----- (0000000140017F34) ----------------------------------------------------
__int64 __fastcall sub_140017F34(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // rax
  __int64 v9; // r8
  unsigned int v10; // eax
  int v11; // er11
  __int64 result; // rax
  unsigned int v13; // [rsp+20h] [rbp-20h] BYREF
  int v14; // [rsp+24h] [rbp-1Ch]
  int v15; // [rsp+28h] [rbp-18h]
  int v16; // [rsp+2Ch] [rbp-14h]
  int v17; // [rsp+30h] [rbp-10h]

  dword_1400D8750 = sub_14000A930(a1, a2, a3, a4, v13);
  v13 = 0xF3702543;
  v14 = 0x81D42030;
  v15 = 0xB432DE04;
  v16 = 0x6C3E7609;
  v17 = 0x55A1C72B;
  v4 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v13);
  LOBYTE(v5) = 1;
  qword_1400D8758 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v4, &qword_1400D8758, v5);
  v13 = 0xA5FC90E0;
  v14 = 0x29CB2AB;
  v15 = 0x6B95C138;
  v16 = 0x3BDA756E;
  v17 = 0x64E9FCDA;
  v6 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v13);
  LOBYTE(v7) = 1;
  qword_1400D8760 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v6, &qword_1400D8760, v7);
  v13 = 0x335DCBDE;
  v14 = 0xEEDE46BD;
  v15 = 0x86C75609;
  v16 = 0xB4DDF5BC;
  v17 = 0xF47DD483;
  v8 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v13);
  LOBYTE(v9) = 1;
  qword_1400D8768 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v8, &qword_1400D8768, v9);
  v10 = sub_140025404(&dword_1400D8750, 0x20u);
  result = 0x29AA10B2 * (v11 ^ v10);
  dword_1400D8770 = result;
  return result;
}
// 140017F81: variable 'v5' is possibly undefined
// 140017FC6: variable 'v7' is possibly undefined
// 14001800B: variable 'v9' is possibly undefined
// 14001802B: variable 'v11' is possibly undefined
// 1400D8750: using guessed type int dword_1400D8750;
// 1400D8758: using guessed type __int64 qword_1400D8758;
// 1400D8760: using guessed type __int64 qword_1400D8760;
// 1400D8768: using guessed type __int64 qword_1400D8768;
// 1400D8770: using guessed type int dword_1400D8770;

//----- (0000000140018084) ----------------------------------------------------
char __fastcall sub_140018084(__int64 a1)
{
  char v2[40]; // [rsp+20h] [rbp-28h] BYREF

  if ( a1 && (int)sub_140061B64(0x5Au, (__int64)v2, 0x14u, 0i64) >= 0 )
    JUMPOUT(0x1400180B0i64);
  return 0;
}
// 1400180AE: control flows out of bounds to 1400180B0

//----- (00000001400180C8) ----------------------------------------------------
char __fastcall sub_1400180C8(unsigned __int8 *a1, __int64 a2)
{
  char v2; // r8
  unsigned __int8 *v4; // r10
  char *v5; // rdx
  __int64 v6; // r11
  __int64 v7; // rax
  __int64 v8; // r11
  unsigned __int8 *v9; // rdx
  char *v10; // r10
  __int64 v11; // rax
  unsigned __int8 *v12; // rdx
  char *v13; // r10
  __int64 v14; // r11
  __int64 v15; // rax
  unsigned __int8 *v16; // rdx
  char *v17; // r10
  __int64 v18; // r11
  __int64 v19; // rax
  char *v20; // rdx
  unsigned __int8 *v21; // r9
  __int64 v22; // r10
  __int64 v23; // rax
  char *v24; // rcx
  __int64 v25; // r8
  __int16 v27; // [rsp+20h] [rbp-50h] BYREF
  char v28[16]; // [rsp+22h] [rbp-4Eh] BYREF
  __int16 v29; // [rsp+32h] [rbp-3Eh]
  char v30; // [rsp+34h] [rbp-3Ch] BYREF
  __int16 v31; // [rsp+3Ch] [rbp-34h]
  char v32; // [rsp+3Eh] [rbp-32h] BYREF
  __int16 v33; // [rsp+46h] [rbp-2Ah]
  char v34; // [rsp+48h] [rbp-28h] BYREF
  __int16 v35; // [rsp+50h] [rbp-20h]
  char v36; // [rsp+52h] [rbp-1Eh] BYREF
  int v37; // [rsp+6Ah] [rbp-6h]

  v2 = 0;
  if ( a1 && a2 )
  {
    v27 = 0x7B;
    v4 = a1 + 3;
    v5 = v28;
    v6 = 4i64;
    do
    {
      v7 = *v4--;
      *(_DWORD *)v5 = *(_DWORD *)off_1400BC4B0[v7];
      v5 += 4;
      --v6;
    }
    while ( v6 );
    v29 = 0x2D;
    v8 = 2i64;
    v9 = a1 + 5;
    v10 = &v30;
    do
    {
      v11 = *v9--;
      *(_DWORD *)v10 = *(_DWORD *)off_1400BC4B0[v11];
      v10 += 4;
      --v8;
    }
    while ( v8 );
    v31 = 0x2D;
    v12 = a1 + 7;
    v13 = &v32;
    v14 = 2i64;
    do
    {
      v15 = *v12--;
      *(_DWORD *)v13 = *(_DWORD *)off_1400BC4B0[v15];
      v13 += 4;
      --v14;
    }
    while ( v14 );
    v33 = 0x2D;
    v16 = a1 + 8;
    v17 = &v34;
    v18 = 2i64;
    do
    {
      v19 = *v16++;
      *(_DWORD *)v17 = *(_DWORD *)off_1400BC4B0[v19];
      v17 += 4;
      --v18;
    }
    while ( v18 );
    v35 = 0x2D;
    v20 = &v36;
    v21 = a1 + 0xA;
    v22 = 6i64;
    do
    {
      v23 = *v21++;
      *(_DWORD *)v20 = *(_DWORD *)off_1400BC4B0[v23];
      v20 += 4;
      --v22;
    }
    while ( v22 );
    v37 = 0x7D;
    v24 = v28;
    v25 = 0x24i64;
    do
    {
      if ( (unsigned __int16)(*(_WORD *)v24 - 0x41) <= 0x19u )
        *(_WORD *)v24 |= 0x20u;
      v24 += 2;
      --v25;
    }
    while ( v25 );
    v2 = sub_1400070E0(a2, (__int64)&v27);
  }
  return v2;
}
// 1400BC4B0: using guessed type wchar_t *off_1400BC4B0[256];

//----- (00000001400189F8) ----------------------------------------------------
__int64 __fastcall sub_1400189F8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 result; // rax
  __int64 v11; // r12
  __int64 v12; // rax
  __int64 v13; // r13
  int v14[44]; // [rsp+98h] [rbp-B0h] BYREF

  result = sub_140048808();
  v11 = result;
  a8 = result;
  if ( a1 )
  {
    if ( a2 )
    {
      result = *(_QWORD *)(a1 + 0x210);
      if ( !result || !*(_BYTE *)(result + 0x20) )
      {
        v12 = sub_1400142D0(v11);
        v13 = v12;
        if ( v12 )
        {
          sub_14005221C(v12, 0x1000i64, 8);
          if ( sub_14005240C(v13, 0x1000ui64, 0i64, &a7) )
            sub_140013ED8();
        }
        sub_1400144E4(v11, v14);
        JUMPOUT(0x140018B13i64);
      }
    }
  }
  return result;
}
// 140018B11: control flows out of bounds to 140018B13

//----- (0000000140018C5C) ----------------------------------------------------
__int64 __fastcall sub_140018C5C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rdx
  unsigned int v5; // er8
  unsigned __int64 v6; // r9
  char v7; // cl
  __int64 result; // rax

  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x46i64);
  v4 = 0i64;
  v5 = 0xF2FFAFA5;
  v6 = 0x44i64;
  do
  {
    *(_DWORD *)(a2 + v4) = *(_DWORD *)(a1 + v4) ^ v5;
    v4 += 4i64;
    v5 = ~(((v5 ^ (v5 >> 7)) << 9) ^ v5 ^ (v5 >> 7) ^ ((((v5 ^ (v5 >> 7)) << 9) ^ v5 ^ (v5 >> 7)) >> 0xD));
  }
  while ( v4 < 0x44 );
  do
  {
    v7 = v5;
    v5 >>= 8;
    result = a2;
    *(_BYTE *)(a2 + v6) = *(_BYTE *)(a1 + v6) ^ v7;
    ++v6;
  }
  while ( v6 < 0x46 );
  return result;
}

//----- (0000000140018D00) ----------------------------------------------------
void __fastcall sub_140018D00(__int64 a1, __int64 a2, ULONG64 a3, __int64 a4)
{
  __int64 v4; // rax
  int v5[96]; // [rsp+C0h] [rbp-40h] BYREF

  if ( a1 )
  {
    if ( a2 )
    {
      if ( *(_QWORD *)(a2 + 8) )
      {
        if ( *(_WORD *)a2 )
        {
          if ( *(_WORD *)(a2 + 2) )
          {
            if ( a3 )
            {
              if ( a4 )
              {
                v4 = *(_QWORD *)(a1 + 0x210);
                if ( !v4 || !*(_BYTE *)(v4 + 0x20) )
                {
                  sub_140053740(a3, (__int64)v5);
                  JUMPOUT(0x140018DA7i64);
                }
              }
            }
          }
        }
      }
    }
  }
}
// 140018DA3: control flows out of bounds to 140018DA7

//----- (0000000140018F4C) ----------------------------------------------------
void **__fastcall sub_140018F4C(__int64 a1, __int64 a2, unsigned __int64 a3, unsigned __int64 a4, int *a5)
{
  void **result; // rax
  unsigned __int64 v6; // rdi
  int v10; // er15
  int v11; // er12
  int v12; // er13
  unsigned int v13; // edx
  unsigned __int64 v14; // r8
  char v15; // cl
  __int64 v16; // [rsp+28h] [rbp-A9h]
  __int64 v17; // [rsp+30h] [rbp-A1h]
  __int64 v18; // [rsp+38h] [rbp-99h]
  __int64 v19; // [rsp+40h] [rbp-91h]
  int v20[21]; // [rsp+48h] [rbp-89h] BYREF
  __int16 v21; // [rsp+9Ch] [rbp-35h]
  char *v22; // [rsp+A0h] [rbp-31h]
  int *v23; // [rsp+A8h] [rbp-29h]
  char v24[88]; // [rsp+B0h] [rbp-21h] BYREF
  void *retaddr; // [rsp+130h] [rbp+5Fh] BYREF

  result = &retaddr;
  v6 = 0i64;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          result = *(void ***)(a1 + 0x210);
          if ( !result || !*((_BYTE *)result + 0x20) )
          {
            if ( a3 > (unsigned __int64)MmSystemRangeStart && sub_14005240C(a3, a4, 0i64, (__int64 *)&a5) )
            {
              v10 = a5[0x16];
              v11 = a5[0xA];
              v12 = a5[2];
            }
            v20[0] = 0xB44D9440;
            v20[1] = 0x4AA9D273;
            v20[2] = 0xFC372D05;
            v20[3] = 0xD1FDEEF7;
            v20[4] = 0x51D1314E;
            v20[5] = 0xD34F354A;
            v20[6] = 0x3C4BACBB;
            v20[7] = 0xE72F2C5B;
            v20[8] = 0xAD4556FA;
            v20[9] = 0xBBED63;
            v20[0xA] = 0xAA667025;
            v20[0xB] = 0x133E1A47;
            v20[0xC] = 0x27A385E4;
            v20[0xD] = 0x40F91E23;
            v20[0xE] = 0x93EA77BB;
            v20[0xF] = 0x85B2E546;
            v20[0x10] = 0x35428B3;
            v20[0x11] = 0xBA0684FA;
            v20[0x12] = 0x6E1368B3;
            v20[0x13] = 0x98A495C2;
            v20[0x14] = 0xB0819154;
            v21 = 0xAD29;
            ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v24, 0i64, 0x56i64);
            v13 = 0xB41E941B;
            v23 = v20;
            v14 = 0x54i64;
            v22 = v24;
            do
            {
              *(_DWORD *)&v22[v6 * 4] = v23[v6] ^ v13;
              ++v6;
              v13 = ~(((v13 ^ (v13 << 0xD)) >> 0x11) ^ v13 ^ (v13 << 0xD) ^ (0x20
                                                                           * (((v13 ^ (v13 << 0xD)) >> 0x11) ^ v13 ^ (v13 << 0xD))));
            }
            while ( v6 < 0x15 );
            a5 = v20;
            v22 = v24;
            do
            {
              v15 = v13;
              v13 >>= 8;
              v22[v14] = *((_BYTE *)a5 + v14) ^ v15;
              ++v14;
            }
            while ( v14 < 0x56 );
            LODWORD(v18) = v11;
            LODWORD(v17) = v10;
            LODWORD(v16) = v12;
            sub_140046248(*(_QWORD *)(a1 + 0x210), (__int64)v24, a2, a4, v16, v17, v18, v19);
            result = 0i64;
            memset(v24, 0, 0x56ui64);
          }
        }
      }
    }
  }
  return result;
}
// 14001913B: variable 'v16' is possibly undefined
// 14001913B: variable 'v17' is possibly undefined
// 14001913B: variable 'v18' is possibly undefined
// 14001913B: variable 'v19' is possibly undefined

//----- (000000014001916C) ----------------------------------------------------
char __fastcall sub_14001916C(__int64 a1)
{
  if ( a1 )
    JUMPOUT(0x14001919Ei64);
  return 0;
}
// 140019197: control flows out of bounds to 14001919E

//----- (0000000140019684) ----------------------------------------------------
__int64 *__fastcall sub_140019684(__int64 **a1)
{
  __int64 *result; // rax
  __int64 v3; // rdx

  for ( result = *a1; *a1 != (__int64 *)a1; result = *a1 )
  {
    v3 = *result;
    if ( (__int64 **)result[1] != a1 || *(__int64 **)(v3 + 8) != result )
      __fastfail(3u);
    *a1 = (__int64 *)v3;
    *(_QWORD *)(v3 + 8) = a1;
    sub_140051220((__int64)result);
  }
  return result;
}

//----- (00000001400197A0) ----------------------------------------------------
char sub_1400197A0()
{
  if ( MEMORY[0xFFFFF7800000026C] == 6 && MEMORY[0xFFFFF78000000270] == 1 )
  {
    if ( !byte_1400D81F2 )
      JUMPOUT(0x1400197FCi64);
    JUMPOUT(0x1400198C5i64);
  }
  return 0;
}
// 1400197F8: control flows out of bounds to 1400197FC
// 1400198C3: control flows out of bounds to 1400198C5
// 1400D81F2: using guessed type char byte_1400D81F2;

//----- (0000000140019E44) ----------------------------------------------------
__int64 __fastcall sub_140019E44(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, char a4)
{
  unsigned __int64 v5; // rax
  unsigned __int64 v7; // rdi
  unsigned __int64 i; // rsi
  unsigned __int64 v9; // r15
  __int64 v10; // r14
  __int64 v11; // r9
  __int64 result; // rax
  unsigned __int64 v13; // [rsp+30h] [rbp-138h] BYREF
  __int64 v14; // [rsp+38h] [rbp-130h]

  v5 = a2 - a1;
  v7 = a2;
  for ( i = a1; ; v5 = v7 - i )
  {
    result = v5 & 0xFFFFFFFFFFFFFF00ui64;
    if ( result <= 0x2000 )
      return sub_14001A0D8(i, v7);
    if ( a3 <= 0 )
      break;
    sub_14001A338(&v13, i, v7);
    v9 = v13;
    v10 = v14;
    a3 = (a3 >> 2) + (a3 >> 1);
    LOBYTE(v11) = a4;
    if ( (__int64)((v13 - i) & 0xFFFFFFFFFFFFFF00ui64) >= (__int64)((v7 - v14) & 0xFFFFFFFFFFFFFF00ui64) )
    {
      sub_140019E44(v14, v7, a3, v11);
      v7 = v9;
    }
    else
    {
      sub_140019E44(i, v13, a3, v11);
      i = v10;
    }
  }
  if ( (__int64)(v7 - i) >> 9 > 0 )
    JUMPOUT(0x140019F6Fi64);
  if ( (__int64)(v7 - i) >> 8 >= 2 )
    JUMPOUT(0x140019FFAi64);
  return result;
}
// 140019F6C: control flows out of bounds to 140019F6F
// 140019FF7: control flows out of bounds to 140019FFA
// 140019EDA: variable 'v11' is possibly undefined

//----- (000000014001A0D8) ----------------------------------------------------
__int64 __fastcall sub_14001A0D8(__int64 a1, __int64 a2)
{
  if ( a1 != a2 && a1 + 0x100 != a2 )
    JUMPOUT(0x14001A13Ai64);
  return a2;
}
// 14001A137: control flows out of bounds to 14001A13A

//----- (000000014001A338) ----------------------------------------------------
unsigned __int64 *__fastcall sub_14001A338(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // r12
  unsigned __int64 *v4; // rsi
  unsigned __int64 v5; // r15
  __int64 v6; // rdi
  unsigned __int64 v7; // rbx
  __int64 v9; // rsi
  __int64 v10; // rdi
  __int64 v11; // r14
  unsigned __int64 v12; // rcx
  _BYTE *v13; // r9
  unsigned __int64 i; // rdx
  int v15; // er8
  unsigned __int64 j; // rdx
  int v17; // er8
  unsigned __int64 k; // rdx
  int v19; // er8
  unsigned __int64 l; // rdx
  int v21; // er8
  unsigned __int64 v22; // rdx
  unsigned __int64 v23; // r11
  unsigned __int64 m; // r8
  int v25; // er9
  unsigned __int64 n; // r8
  int v27; // er9
  bool v28; // zf
  _BYTE *v29; // r9
  _BYTE *v30; // rbx
  unsigned __int64 v31; // r8
  int v32; // er10
  unsigned __int64 ii; // r8
  int v34; // er10
  unsigned __int64 v35; // r11
  unsigned __int64 *result; // rax
  unsigned __int64 *v37; // [rsp+768h] [rbp+660h]
  unsigned __int64 v38; // [rsp+778h] [rbp+670h]

  v38 = a3;
  v37 = a1;
  v3 = a3 - 0x100;
  v4 = a1;
  v5 = a2 + ((__int64)(a3 - a2) >> 9 << 8);
  v6 = (__int64)(a3 - 0x100 - a2) >> 8;
  v7 = a3;
  if ( v6 <= 0x28 )
  {
    sub_14001B0F8(a2, v5, a3 - 0x100);
  }
  else
  {
    v9 = (v6 + 1) >> 3;
    v10 = v9 << 8;
    v9 <<= 9;
    v11 = v10 + a2;
    sub_14001B0F8(a2, v10 + a2, v9 + a2);
    sub_14001B0F8(v5 - v10, v5, v10 + v5);
    sub_14001B0F8(v3 - v9, v3 - v10, v3);
    sub_14001B0F8(v11, v5, v3 - v10);
    v7 = v38;
    v4 = v37;
  }
  v12 = v5 + 0x100;
  while ( a2 < v5 )
  {
    v13 = (_BYTE *)(v5 - 0x100);
    for ( i = 0i64; i < 0x100; ++i )
    {
      v15 = ((char)*v13 | 0x20) - (*(char *)(i + v5) | 0x20);
      if ( v15 )
        break;
      if ( !*v13 )
        goto LABEL_10;
      ++v13;
    }
    if ( v15 < 0 )
      break;
LABEL_10:
    for ( j = 0i64; j < 0x100; ++j )
    {
      v17 = (*(char *)(j + v5) | 0x20) - (*(char *)(v5 - 0x100 + j) | 0x20);
      if ( v17 )
        break;
      if ( !*(_BYTE *)(j + v5) )
        goto LABEL_15;
    }
    if ( v17 < 0 )
      break;
LABEL_15:
    v5 -= 0x100i64;
  }
  while ( v12 < v7 )
  {
    for ( k = 0i64; k < 0x100; ++k )
    {
      v19 = (*(char *)(k + v12) | 0x20) - (*(char *)(k + v5) | 0x20);
      if ( v19 )
        break;
      if ( !*(_BYTE *)(k + v12) )
        goto LABEL_23;
    }
    if ( v19 < 0 )
      break;
LABEL_23:
    for ( l = 0i64; l < 0x100; ++l )
    {
      v21 = (*(char *)(l + v5) | 0x20) - (*(char *)(l + v12) | 0x20);
      if ( v21 )
        break;
      if ( !*(_BYTE *)(l + v5) )
        goto LABEL_28;
    }
    if ( v21 < 0 )
      break;
LABEL_28:
    v12 += 0x100i64;
  }
  v22 = v12;
  v23 = v5;
  while ( v22 < v7 )
  {
    for ( m = 0i64; m < 0x100; ++m )
    {
      v25 = (*(char *)(m + v5) | 0x20) - (*(char *)(m + v22) | 0x20);
      if ( v25 )
        break;
      if ( !*(_BYTE *)(m + v5) )
        goto LABEL_36;
    }
    if ( v25 < 0 )
      goto LABEL_44;
LABEL_36:
    for ( n = 0i64; n < 0x100; ++n )
    {
      v27 = (*(char *)(n + v22) | 0x20) - (*(char *)(n + v5) | 0x20);
      if ( v27 )
        break;
      if ( !*(_BYTE *)(n + v22) )
        goto LABEL_41;
    }
    if ( v27 < 0 )
      break;
LABEL_41:
    if ( v12 != v22 )
      JUMPOUT(0x14001A583i64);
    v12 += 0x100i64;
LABEL_44:
    v22 += 0x100i64;
  }
  v28 = v5 == a2;
  if ( v5 > a2 )
  {
    v29 = (_BYTE *)(v5 - 0x100);
    do
    {
      v30 = v29;
      v31 = (unsigned __int64)&v29[-v23 + 0x100];
      do
      {
        v32 = ((char)*v30 | 0x20) - (*(char *)(v31 + v5) | 0x20);
        if ( v32 )
          break;
        if ( !*v30 )
          goto LABEL_53;
        ++v30;
        ++v31;
      }
      while ( v31 < 0x100 );
      if ( v32 < 0 )
        goto LABEL_60;
LABEL_53:
      for ( ii = 0i64; ii < 0x100; ++ii )
      {
        v34 = (*(char *)(ii + v5) | 0x20) - ((char)v29[ii] | 0x20);
        if ( v34 )
          break;
        if ( !*(_BYTE *)(ii + v5) )
          goto LABEL_58;
      }
      if ( v34 < 0 )
        break;
LABEL_58:
      v5 -= 0x100i64;
      if ( (_BYTE *)v5 != v29 )
        JUMPOUT(0x14001A721i64);
LABEL_60:
      v23 -= 0x100i64;
      v29 += 0xFFFFFF00;
    }
    while ( a2 < v23 );
    v7 = v38;
    v28 = v23 == a2;
  }
  if ( !v28 )
  {
    v35 = v23 - 0x100;
    if ( v22 == v7 )
    {
      if ( v35 != v5 - 0x100 )
        JUMPOUT(0x14001AAC6i64);
      JUMPOUT(0x14001ABE2i64);
    }
    JUMPOUT(0x14001AD00i64);
  }
  if ( v22 != v7 )
  {
    if ( v12 != v22 )
      JUMPOUT(0x14001A86Di64);
    JUMPOUT(0x14001A989i64);
  }
  result = v4;
  *v4 = v5;
  v4[1] = v12;
  return result;
}
// 14001A580: control flows out of bounds to 14001A583
// 14001A71E: control flows out of bounds to 14001A721
// 14001A86A: control flows out of bounds to 14001A86D
// 14001A986: control flows out of bounds to 14001A989
// 14001AAC3: control flows out of bounds to 14001AAC6
// 14001ABDF: control flows out of bounds to 14001ABE2
// 14001ACFD: control flows out of bounds to 14001AD00

//----- (000000014001AE38) ----------------------------------------------------
void __fastcall sub_14001AE38(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx
  _BYTE *v4; // rdi
  __int64 v5; // r15
  unsigned __int64 i; // rcx

  v3 = (a3 - 1) >> 1;
  if ( a2 < v3 )
  {
    v4 = (_BYTE *)((a2 << 9) + a1 + 0x200);
    v5 = (a2 << 9) + a1;
    for ( i = 0i64; i < 0x100; ++i )
    {
      if ( ((char)*v4 | 0x20) != (*(char *)(v5 + i + 0x100) | 0x20) )
        break;
      if ( !*v4 )
        break;
      ++v4;
    }
    JUMPOUT(0x14001AEFAi64);
  }
  if ( a2 == v3 && (a3 & 1) == 0 )
    JUMPOUT(0x14001AF74i64);
  JUMPOUT(0x14001B089i64);
}
// 14001AEF7: control flows out of bounds to 14001AEFA
// 14001AF71: control flows out of bounds to 14001AF74
// 14001B01F: control flows out of bounds to 14001B023
// 14001B085: control flows out of bounds to 14001B089

//----- (000000014001B0F8) ----------------------------------------------------
__int64 __fastcall sub_14001B0F8(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 i; // r10
  int v5; // er8
  unsigned __int64 j; // r8
  __int64 result; // rax
  int v8; // er10

  for ( i = 0i64; i < 0x100; ++i )
  {
    v5 = (*(char *)(i + a2) | 0x20) - (*(char *)(i + a1) | 0x20);
    if ( v5 )
      break;
    if ( !*(_BYTE *)(i + a2) )
      goto LABEL_7;
  }
  if ( v5 < 0 )
    JUMPOUT(0x14001B15Ai64);
LABEL_7:
  for ( j = 0i64; j < 0x100; ++j )
  {
    result = *(char *)(j + a2) | 0x20u;
    v8 = (*(char *)(j + a3) | 0x20) - result;
    if ( v8 )
      break;
    if ( !*(_BYTE *)(j + a3) )
      return result;
  }
  if ( v8 < 0 )
    JUMPOUT(0x14001B2A2i64);
  return result;
}
// 14001B157: control flows out of bounds to 14001B15A
// 14001B29F: control flows out of bounds to 14001B2A2

//----- (000000014001B640) ----------------------------------------------------
void sub_14001B640()
{
  JUMPOUT(0x14001B662i64);
}
// 14001B65F: control flows out of bounds to 14001B662

//----- (000000014001D168) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_14001D168()
{
  JUMPOUT(0x14001D196i64);
}
// 14001D2B3: positive sp value 18 has been found
// 14001D192: control flows out of bounds to 14001D196

//----- (000000014001F828) ----------------------------------------------------
struct _KEVENT *__fastcall sub_14001F828(char a1)
{
  POOL_TYPE v2; // edi
  struct _KEVENT *v3; // rax
  struct _KEVENT *v4; // rbx
  struct _LIST_ENTRY *v5; // rax

  if ( MEMORY[0xFFFFF7800000026C] > 6u
    || MEMORY[0xFFFFF7800000026C] == 6 && (unsigned int)(MEMORY[0xFFFFF78000000270] - 2) <= 1 )
  {
    v2 = 0x200;
  }
  else
  {
    v2 = NonPagedPool;
  }
  v3 = (struct _KEVENT *)ExAllocatePoolWithTag(v2, 0x50ui64, 0x70614D48u);
  v4 = v3;
  if ( v3 )
  {
    v3[3].Header.LockNV = 0;
    LOBYTE(v3[2].Header.WaitListHead.Flink) = a1;
    HIDWORD(v3[2].Header.WaitListHead.Flink) = 0x1000;
    v5 = (struct _LIST_ENTRY *)ExAllocatePoolWithTag(v2, 0x8000ui64, 0x70614D48u);
    v4[2].Header.WaitListHead.Blink = v5;
    if ( v5 )
    {
      ((void (__fastcall *)(struct _LIST_ENTRY *, _QWORD, __int64))loc_14006F2C0)(
        v5,
        0i64,
        8i64 * HIDWORD(v4[2].Header.WaitListHead.Flink));
      v4->Header.WaitListHead.Flink = 0i64;
      LODWORD(v4->Header.WaitListHead.Blink) = 0;
      v4->Header.LockNV = 1;
      KeInitializeEvent(v4 + 1, SynchronizationEvent, 0);
    }
    else
    {
      ExFreePoolWithTag(v4, 0x70614D48u);
      v4 = 0i64;
    }
  }
  return v4;
}

//----- (000000014001F904) ----------------------------------------------------
char __fastcall sub_14001F904(PFAST_MUTEX FastMutex, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 v5; // r14
  POOL_TYPE v8; // ecx
  __int64 v9; // rsi
  _QWORD *v10; // rax
  _QWORD *v11; // rdi
  _QWORD *v12; // rax
  _QWORD *v13; // rdx
  _QWORD *v14; // rcx
  __int64 v15; // rax

  v5 = a4;
  if ( MEMORY[0xFFFFF7800000026C] > 6u
    || MEMORY[0xFFFFF7800000026C] == 6 && (unsigned int)(MEMORY[0xFFFFF78000000270] - 2) <= 1 )
  {
    v8 = 0x200;
  }
  else
  {
    v8 = NonPagedPool;
  }
  if ( KeGetCurrentIrql() > 1u || !FastMutex || !LOBYTE(FastMutex[1].Count) && (!a3 || !a4) )
    return 0;
  v9 = (unsigned int)a2 & (*(&FastMutex[1].Count + 1) - 1);
  v10 = ExAllocatePoolWithTag(v8, a4 + 0x10i64, 0x70614D48u);
  v11 = v10;
  if ( !v10 )
    return 0;
  *v10 = 0i64;
  v10[1] = a2;
  if ( a3 && (_DWORD)v5 )
    ((void (__fastcall *)(_QWORD *, __int64, __int64))loc_14006F000)(v10 + 2, a3, v5);
  ExAcquireFastMutex(FastMutex);
  v12 = FastMutex[1].Owner;
  v13 = 0i64;
  v14 = (_QWORD *)v12[v9];
  if ( v14 )
  {
    while ( 1 )
    {
      v15 = *v14;
      if ( v14[1] == a2 )
        break;
      if ( !v15 )
      {
        *v14 = v11;
        goto LABEL_25;
      }
      v13 = v14;
      v14 = (_QWORD *)*v14;
    }
    *v11 = v15;
    if ( v13 )
      *v13 = v11;
    else
      *((_QWORD *)FastMutex[1].Owner + v9) = v11;
    ExFreePoolWithTag(v14, 0x70614D48u);
  }
  else
  {
    v12[v9] = v11;
LABEL_25:
    ++FastMutex[1].Contention;
  }
  ExReleaseFastMutex(FastMutex);
  return 1;
}

//----- (000000014001FA54) ----------------------------------------------------
_QWORD *__fastcall sub_14001FA54(PFAST_MUTEX FastMutex, __int64 a2)
{
  _QWORD *v4; // rdi
  __int64 v5; // rbx
  _QWORD *i; // rcx

  v4 = 0i64;
  if ( KeGetCurrentIrql() > 1u || !FastMutex || LOBYTE(FastMutex[1].Count) )
    return 0i64;
  v5 = (unsigned int)a2 & (*(&FastMutex[1].Count + 1) - 1);
  ExAcquireFastMutex(FastMutex);
  for ( i = (_QWORD *)*((_QWORD *)FastMutex[1].Owner + v5); i; i = (_QWORD *)*i )
  {
    if ( i[1] == a2 )
    {
      v4 = i + 2;
      break;
    }
  }
  ExReleaseFastMutex(FastMutex);
  return v4;
}

//----- (000000014001FAD4) ----------------------------------------------------
char __fastcall sub_14001FAD4(PFAST_MUTEX FastMutex, __int64 a2)
{
  char v4; // di
  __int64 v5; // rbx
  _QWORD *i; // rcx

  v4 = 0;
  if ( KeGetCurrentIrql() > 1u || !FastMutex )
    return 0;
  v5 = (unsigned int)a2 & (*(&FastMutex[1].Count + 1) - 1);
  ExAcquireFastMutex(FastMutex);
  for ( i = (_QWORD *)*((_QWORD *)FastMutex[1].Owner + v5); i; i = (_QWORD *)*i )
  {
    if ( i[1] == a2 )
    {
      v4 = 1;
      break;
    }
  }
  ExReleaseFastMutex(FastMutex);
  return v4;
}

//----- (000000014001FB50) ----------------------------------------------------
void __fastcall sub_14001FB50(PFAST_MUTEX FastMutex, __int64 a2)
{
  __int64 v4; // rdi
  _QWORD *v5; // r8
  _QWORD *v6; // rdx
  _QWORD *v7; // rcx
  __int64 v8; // rax

  if ( KeGetCurrentIrql() <= 1u && FastMutex )
  {
    v4 = (unsigned int)a2 & (*(&FastMutex[1].Count + 1) - 1);
    ExAcquireFastMutex(FastMutex);
    v5 = FastMutex[1].Owner;
    v6 = 0i64;
    v7 = (_QWORD *)v5[v4];
    if ( v7 )
    {
      while ( 1 )
      {
        v8 = *v7;
        if ( v7[1] == a2 )
          break;
        v6 = v7;
        v7 = (_QWORD *)*v7;
        if ( !v8 )
          goto LABEL_11;
      }
      if ( v6 )
        *v6 = v8;
      else
        v5[v4] = v8;
      ExFreePoolWithTag(v7, 0x70614D48u);
      --FastMutex[1].Contention;
    }
LABEL_11:
    ExReleaseFastMutex(FastMutex);
  }
}

//----- (000000014001FBDC) ----------------------------------------------------
void __fastcall sub_14001FBDC(PVOID P)
{
  __int64 i; // rdi
  __int64 v3; // rax
  _QWORD *v4; // rsi
  void *v5; // rcx

  if ( P )
  {
    if ( KeGetCurrentIrql() <= 1u )
    {
      ExAcquireFastMutex((PFAST_MUTEX)P);
      for ( i = 0i64; (unsigned int)i < *((_DWORD *)P + 0xF); i = (unsigned int)(i + 1) )
      {
        v3 = *((_QWORD *)P + 8);
        v4 = *(_QWORD **)(v3 + 8 * i);
        if ( v4 )
        {
          do
          {
            v5 = v4;
            v4 = (_QWORD *)*v4;
            --*((_DWORD *)P + 0x12);
            ExFreePoolWithTag(v5, 0x70614D48u);
          }
          while ( v4 );
          v3 = *((_QWORD *)P + 8);
        }
        *(_QWORD *)(v3 + 8 * i) = 0i64;
      }
      ExReleaseFastMutex((PFAST_MUTEX)P);
    }
    ExFreePoolWithTag(*((PVOID *)P + 8), 0x70614D48u);
    ExFreePoolWithTag(P, 0x70614D48u);
  }
}

//----- (0000000140021868) ----------------------------------------------------
void __fastcall sub_140021868(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax

  if ( byte_1400D877D )
  {
    if ( dword_1400D8818 )
    {
      LOBYTE(a3) = 1;
      v3 = ((__int64 (__fastcall *)(void *, void *, __int64))loc_1400404E8)(&unk_1400D8820, &loc_14002D32C, a3);
      ((void (__fastcall *)(__int64, _QWORD))loc_14002D32C)(v3, (unsigned int)dword_1400D8818);
    }
    memset(&unk_1400D8820, 0, 0x2000ui64);
  }
  else
  {
    sub_140006B44(qword_1400D87C8, (__int64)sub_140021868, a2, 0x7530u);
  }
}
// 1400D877D: using guessed type char byte_1400D877D;
// 1400D87C8: using guessed type __int64 qword_1400D87C8;
// 1400D8818: using guessed type int dword_1400D8818;

//----- (00000001400218E0) ----------------------------------------------------
char __fastcall sub_1400218E0(__int64 a1)
{
  char v2; // si
  __int64 v3; // rax
  __int64 v4; // rdx
  __int64 v5; // r8
  __int64 v6; // r9
  PVOID *v7; // rbx
  unsigned int v8; // edi
  __int64 *v9; // r14
  __int64 v10; // rdi
  void *v12; // [rsp+20h] [rbp-8h]

  v2 = 0;
  v3 = sub_140051084(0x1000ui64);
  v7 = (PVOID *)v3;
  if ( v3 )
  {
    v8 = sub_140014384(v3, v4, v5, v6, v12);
    if ( v8 )
    {
      ObfDereferenceObject(*v7);
      if ( v8 > 1 )
      {
        v9 = (__int64 *)(v7 + 1);
        v10 = v8 - 1;
        do
        {
          if ( !v2 && !sub_140006E64(a1) )
            v2 = sub_140024600(*v9);
          ObfDereferenceObject((PVOID)*v9++);
          --v10;
        }
        while ( v10 );
      }
    }
    sub_140051220((__int64)v7);
  }
  return v2;
}
// 140021914: variable 'v4' is possibly undefined
// 140021914: variable 'v5' is possibly undefined
// 140021914: variable 'v6' is possibly undefined
// 140021914: variable 'v12' is possibly undefined

//----- (0000000140021988) ----------------------------------------------------
void __fastcall sub_140021988(__int64 a1)
{
  char v1; // di
  __int64 i; // rcx
  __int64 *v3; // rax
  __int64 *v4; // rbx

  v1 = sub_1400218E0(a1);
  for ( i = 0i64; ; i = (__int64)v4 )
  {
    v3 = sub_140062C9C(i);
    v4 = v3;
    if ( !v3 )
      break;
    if ( v1 )
      ((void (__fastcall *)(__int64 *, __int64))loc_14004EC1C)(v3, 0xCi64);
  }
  sub_140006B44(qword_1400D87D0, (__int64)sub_140021988, 0i64, 0x927C0u);
}
// 1400D87D0: using guessed type __int64 qword_1400D87D0;

//----- (000000014002264C) ----------------------------------------------------
__int64 sub_14002264C()
{
  __int64 result; // rax

  result = (unsigned int)_InterlockedCompareExchange(&dword_1400D881C, 1, 0);
  if ( !(_DWORD)result )
  {
    stru_1400DA928.Owner = 0i64;
    stru_1400DA928.Contention = 0;
    stru_1400DA928.Count = 1;
    KeInitializeEvent(&stru_1400DA928.Event, SynchronizationEvent, 0);
    result = ((__int64 (__fastcall *)(void *, _QWORD, __int64))loc_14006F2C0)(&unk_1400DA820, 0i64, 0x100i64);
  }
  return result;
}
// 1400D881C: using guessed type int dword_1400D881C;

//----- (00000001400226A0) ----------------------------------------------------
void sub_1400226A0()
{
  ExAcquireFastMutex(&stru_1400DA928);
  if ( qword_1400DA920 )
  {
    if ( !*((_BYTE *)&unk_1400DA828 + 0x10) )
    {
      if ( unk_1400DA828 )
        sub_140051220(unk_1400DA828);
    }
    JUMPOUT(0x1400226E6i64);
  }
  qword_1400DA920 = 0i64;
  ExReleaseFastMutex(&stru_1400DA928);
}
// 1400226DF: control flows out of bounds to 1400226E6
// 1400DA920: using guessed type __int64 qword_1400DA920;

//----- (0000000140022938) ----------------------------------------------------
char *__fastcall sub_140022938(int a1)
{
  char *v1; // rbx
  unsigned __int64 v4; // rax
  _DWORD *v5; // rcx

  v1 = 0i64;
  if ( !a1 )
    return 0i64;
  ExAcquireFastMutex(&stru_1400DA928);
  v4 = 0i64;
  if ( qword_1400DA920 )
  {
    v5 = &unk_1400DA820;
    while ( *v5 != a1 )
    {
      ++v4;
      v5 += 8;
      if ( v4 >= qword_1400DA920 )
        goto LABEL_9;
    }
    v1 = (char *)&unk_1400DA820 + 0x20 * v4;
  }
LABEL_9:
  ExReleaseFastMutex(&stru_1400DA928);
  return v1;
}
// 1400DA920: using guessed type __int64 qword_1400DA920;

//----- (00000001400229AC) ----------------------------------------------------
char __fastcall sub_1400229AC(ULONG64 a1, __int64 a2, __int64 a3)
{
  char v5; // dl

  v5 = 0;
  if ( a1 && a1 < (unsigned __int64)MmHighestUserAddress && a1 + 0x1000 < (unsigned __int64)MmHighestUserAddress && a3 )
  {
    sub_14005221C(a1, 0x1000i64, 1);
    ((void (__fastcall *)(__int64, ULONG64, __int64))loc_14006F000)(a3, a1, 0x1000i64);
    v5 = 1;
  }
  return v5;
}

//----- (0000000140022FD4) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_140022FD4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, int a11, __int64 a12, __int64 a13, __int64 a14, __int64 a15, __int64 a16)
{
  JUMPOUT(0x140023014i64);
}
// 14002308B: positive sp value 38 has been found
// 140023011: control flows out of bounds to 140023014

//----- (000000014002308C) ----------------------------------------------------
void __fastcall sub_14002308C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbp
  unsigned int v5; // eax
  __int64 v6; // rdx
  _DWORD *v7; // rbx
  unsigned int v8; // esi
  unsigned int *v9; // r15
  __int64 v10; // rdi
  _DWORD *v11; // r8
  unsigned int v12; // er9

  if ( a1 )
  {
    if ( a3 )
    {
      v4 = a2 - *(_QWORD *)(a1 + 0x30);
      if ( v4 )
      {
        if ( *(_DWORD *)(a1 + 0xB4) )
        {
          v5 = *(_DWORD *)(a1 + 0xB0);
          if ( v5 )
          {
            v7 = sub_1400524BC(v5, a1, a3);
            if ( v7 )
            {
              v8 = 0;
              do
              {
                v9 = v7 + 1;
                v10 = (unsigned int)v7[1];
                if ( !(_DWORD)v10 )
                  break;
                v11 = sub_1400524BC((unsigned int)*v7, v6, a3);
                if ( !v11 )
                  break;
                v7 += 2;
                v12 = 0;
                if ( ((v10 - 8) & 0xFFFFFFFFFFFFFFFEui64) != 0 )
                {
                  do
                  {
                    if ( (*(_WORD *)v7 & 0xF000) == 0xA000 )
                      *(_QWORD *)((char *)v11 + (*(_WORD *)v7 & 0xFFF)) += v4;
                    v10 = *v9;
                    ++v12;
                    v7 = (_DWORD *)((char *)v7 + 2);
                  }
                  while ( v12 < (unsigned __int64)(v10 - 8) >> 1 );
                }
                v8 += v10;
              }
              while ( v8 < *(_DWORD *)(v6 + 0xB4) );
            }
          }
        }
      }
    }
  }
}
// 1400230FC: conditional instruction was optimized away because of 'edi.4!=0'
// 14002310E: variable 'v6' is possibly undefined

//----- (0000000140023194) ----------------------------------------------------
char *__fastcall sub_140023194(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 v3; // rdi
  _DWORD *v6; // rax
  __int64 v7; // rdx
  _DWORD *v8; // r8
  _DWORD *v9; // rax
  __int64 v10; // rax
  unsigned __int64 v11; // r9
  char *result; // rax
  char *v13; // rdx

  v3 = a2 + a3;
  if ( !a1
    || !a2
    || !a3
    || (v6 = sub_1400524BC(*(unsigned int *)(a1 + 0xD8), a1, a2), (v8 = v6) == 0i64)
    || (unsigned __int64)v6 < a2
    || (v9 = v6 + 0x40, v9 <= v8)
    || (unsigned __int64)v9 > v3
    || (v10 = *((unsigned __int16 *)v8 + 0x72), !(_WORD)v10)
    || (v11 = a1 + *(unsigned __int16 *)(a1 + 0x14) + 8 * (v10 + 4 * v10 - 2)) == 0
    || v11 < a2
    || v11 + 0x28 <= v11
    || v11 + 0x28 > v3
    || (result = (char *)sub_1400524BC((unsigned int)(*(_DWORD *)(v11 + 0xC) + v8[0x38]), v7, a2)) == 0i64
    || (unsigned __int64)result < a2
    || result + 8 <= result
    || (unsigned __int64)(result + 8) > v3
    || (v13 = &result[*((unsigned int *)result + 1)], v13 <= result)
    || (unsigned __int64)v13 > v3 )
  {
    result = 0i64;
  }
  return result;
}
// 14002324E: variable 'v7' is possibly undefined

//----- (0000000140023294) ----------------------------------------------------
char __fastcall sub_140023294(_DWORD *a1, int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9, __int64 a10, unsigned __int64 a11, unsigned int a12)
{
  unsigned __int64 v12; // rbp
  unsigned __int64 v13; // r14
  _DWORD *v14; // rax
  _DWORD *v15; // rdx
  _DWORD *v16; // rax
  unsigned __int64 v17; // rcx

  v12 = a9 + a10;
  if ( a3 )
  {
    if ( a9 )
    {
      if ( a1 )
      {
        if ( a4 )
        {
          if ( a10 )
          {
            if ( a11 )
            {
              if ( a12 )
              {
                if ( (unsigned __int64)a1 >= a9 && a1 + 1 > a1 && (unsigned __int64)(a1 + 1) <= v12 )
                {
                  v13 = a2 + (*a1 & 0xFFFu);
                  v14 = sub_1400524BC(v13, a3, a9);
                  v15 = v14;
                  if ( v14 )
                  {
                    if ( (unsigned __int64)v14 >= a9 )
                    {
                      v16 = v14 + 3;
                      if ( v16 > v15 && (unsigned __int64)v16 <= v12 )
                      {
                        v17 = v13 + a11;
                        if ( v13 + a11 >= a11 && v17 + 0xC > v17 && v17 + 0xC <= a11 + a12 )
                          JUMPOUT(0x14002335Di64);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}
// 14002335B: control flows out of bounds to 14002335D

//----- (0000000140023388) ----------------------------------------------------
void __fastcall sub_140023388(unsigned __int64 a1, __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9, __int64 a10, int a11)
{
  unsigned __int64 v12; // r13
  unsigned __int64 v13; // rax
  int *v14; // rbx
  __int64 v15; // rax
  int *v16; // rdi
  unsigned __int64 i; // rsi
  char v18; // al
  __int64 v19; // [rsp+38h] [rbp-40h]
  unsigned __int64 v20; // [rsp+40h] [rbp-38h]
  __int64 v21; // [rsp+48h] [rbp-30h]
  unsigned __int64 v22; // [rsp+50h] [rbp-28h]
  unsigned int v23; // [rsp+58h] [rbp-20h]
  __int64 v24; // [rsp+88h] [rbp+10h]

  if ( a2 )
  {
    v24 = a2;
    v12 = a4 + a9;
    if ( a4 )
    {
      if ( a3 )
      {
        if ( a1 )
        {
          if ( a9 )
          {
            if ( a10 )
            {
              if ( a11 )
              {
                if ( a1 >= a4 )
                {
                  v13 = a1 + *(unsigned int *)(a1 + 8) + 0xCi64;
                  if ( v13 > a1 && v13 <= v12 )
                  {
                    v14 = (int *)(a1 + 0xC);
                    if ( a1 != 0xFFFFFFFFFFFFFFF4ui64 )
                    {
                      do
                      {
                        v15 = (unsigned int)v14[1];
                        if ( !(_DWORD)v15
                          || (unsigned __int64)v14 < a4
                          || (int *)((char *)v14 + v15) <= v14
                          || (unsigned __int64)v14 + v15 > v12 )
                        {
                          break;
                        }
                        v16 = v14 + 2;
                        for ( i = (unsigned __int64)(v14 + 3); v16 >= v14; i += 4i64 )
                        {
                          if ( i <= (unsigned __int64)v16 )
                            break;
                          if ( i > (unsigned __int64)v14 + (unsigned int)v14[1] )
                            break;
                          LODWORD(v19) = a11;
                          v18 = sub_140023294(v16, *v14, a2, a3, a4, a9, a10, v19, v20, v21, v22, v23);
                          a2 = v24;
                          if ( !v18 )
                            break;
                          ++v16;
                        }
                        v12 = a4 + a9;
                        v14 = (int *)((char *)v14 + (unsigned int)v14[1]);
                      }
                      while ( v14 );
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
// 140023498: variable 'v19' is possibly undefined
// 140023498: variable 'v20' is possibly undefined
// 140023498: variable 'v21' is possibly undefined
// 140023498: variable 'v22' is possibly undefined
// 140023498: variable 'v23' is possibly undefined

//----- (00000001400234DC) ----------------------------------------------------
void __fastcall sub_1400234DC(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9, unsigned int a10)
{
  unsigned __int64 v10; // r13
  unsigned __int64 v12; // rax
  char *v13; // rbx
  char *v14; // rdi
  __int64 v15; // rax
  char *v16; // rsi
  int i; // ebp
  unsigned __int16 v18; // ax
  unsigned __int64 v19; // r15
  _DWORD *v20; // rax
  unsigned __int64 v21; // rdx
  unsigned __int64 v23; // [rsp+70h] [rbp+18h]

  if ( a3 )
  {
    v10 = a3 + a4;
    v23 = a3 + a4;
    if ( a2 )
    {
      if ( a1 )
      {
        if ( a4 )
        {
          if ( a9 )
          {
            if ( a10 )
            {
              if ( a1 >= a3 )
              {
                v12 = a1 + *(unsigned int *)(a1 + 8) + 0xCi64;
                if ( v12 > a1 && v12 <= v10 )
                {
                  v13 = (char *)(a1 + 0xC);
                  if ( a1 != 0xFFFFFFFFFFFFFFF4ui64 )
                  {
                    do
                    {
                      if ( (unsigned __int64)v13 < a3 )
                        break;
                      v14 = v13 + 8;
                      if ( v13 + 8 <= v13 )
                        break;
                      if ( (unsigned __int64)v14 > v10 )
                        break;
                      v15 = *((unsigned int *)v13 + 1);
                      if ( !(_DWORD)v15 || &v13[v15] <= v13 || (unsigned __int64)&v13[v15] > v10 )
                        break;
                      v16 = v13 + 0xA;
                      for ( i = 0; v14 >= v13; ++i )
                      {
                        if ( v16 <= v14 )
                          break;
                        if ( v16 > &v13[*((unsigned int *)v13 + 1)] )
                          break;
                        v18 = *(_WORD *)v14 & 0xFFF;
                        if ( !v18 )
                        {
                          if ( i )
                            break;
                        }
                        v19 = *(_DWORD *)v13 + (unsigned int)v18;
                        if ( v19 > (unsigned __int64)*(unsigned int *)(a2 + 0x50) - 6 )
                          break;
                        v20 = sub_1400524BC((unsigned int)v19, a2, a3);
                        if ( !v20 )
                          break;
                        v21 = v19 + a9;
                        if ( v19 + a9 >= a9 && v21 + 6 > v21 && v21 + 6 <= a9 + a10 )
                        {
                          *v20 = *(_DWORD *)v21;
                          *((_WORD *)v20 + 2) = *(_WORD *)(v21 + 4);
                        }
                        v14 += 2;
                        v16 += 2;
                      }
                      v10 = v23;
                      v13 += *((unsigned int *)v13 + 1);
                    }
                    while ( v13 );
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//----- (0000000140023680) ----------------------------------------------------
void __fastcall sub_140023680(unsigned __int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned __int64 a9, unsigned int a10)
{
  unsigned __int64 v10; // r13
  unsigned __int64 v12; // rax
  char *v13; // rbx
  char *v14; // rdi
  __int64 v15; // rax
  char *v16; // rsi
  int i; // ebp
  unsigned __int64 v18; // r15
  _DWORD *v19; // r8
  _QWORD *v20; // rax
  __int64 v21; // [rsp+68h] [rbp+10h]
  unsigned __int64 v22; // [rsp+70h] [rbp+18h]

  if ( a3 )
  {
    v21 = a2;
    v10 = a3 + a4;
    v22 = a3 + a4;
    if ( a2 )
    {
      if ( a1 )
      {
        if ( a4 )
        {
          if ( a9 )
          {
            if ( a10 )
            {
              if ( a1 >= a3 )
              {
                v12 = a1 + *(unsigned int *)(a1 + 8) + 0xCi64;
                if ( v12 > a1 && v12 <= v10 )
                {
                  v13 = (char *)(a1 + 0xC);
                  if ( a1 != 0xFFFFFFFFFFFFFFF4ui64 )
                  {
                    do
                    {
                      if ( (unsigned __int64)v13 < a3 )
                        break;
                      v14 = v13 + 8;
                      if ( v13 + 8 <= v13 )
                        break;
                      if ( (unsigned __int64)v14 > v10 )
                        break;
                      v15 = *((unsigned int *)v13 + 1);
                      if ( !(_DWORD)v15 || &v13[v15] <= v13 || (unsigned __int64)&v13[v15] > v10 )
                        break;
                      v16 = v13 + 0xA;
                      for ( i = 0;
                            v14 >= v13 && v16 > v14 && v16 <= &v13[*((unsigned int *)v13 + 1)] && (!i || *(_WORD *)v14);
                            ++i )
                      {
                        v18 = *(_DWORD *)v13 + (unsigned int)*(unsigned __int16 *)v14;
                        if ( v18 > (unsigned __int64)*(unsigned int *)(a2 + 0x50) - 8 )
                          break;
                        v19 = sub_1400524BC((unsigned int)v18, a2, a3);
                        if ( !v19 )
                          break;
                        v20 = (_QWORD *)(v18 + a9);
                        if ( v18 + a9 >= a9 )
                        {
                          if ( v20 + 1 <= v20 )
                          {
                            a2 = v21;
                          }
                          else
                          {
                            a2 = v21;
                            if ( (unsigned __int64)(v20 + 1) <= a9 + a10 )
                              *(_QWORD *)v19 = *v20;
                          }
                        }
                        v14 += 2;
                        v16 += 2;
                      }
                      v10 = v22;
                      v13 += *((unsigned int *)v13 + 1);
                    }
                    while ( v13 );
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}
// 14002378B: variable 'a2' is possibly undefined

//----- (0000000140023818) ----------------------------------------------------
void __fastcall sub_140023818(unsigned int *a1, __int64 a2, unsigned __int64 a3, __int64 a4)
{
  __int64 v5; // r10
  __int64 v7; // rax
  unsigned int *v8; // rbp
  unsigned __int64 v9; // rcx
  unsigned int *v10; // rbx
  __int64 v11; // rdx
  unsigned int *v12; // r12
  int v13; // er13
  unsigned int *v14; // rsi
  __int64 v15; // rax
  char *v16; // r14
  unsigned __int64 v17; // rcx
  _DWORD *v18; // rax
  __int64 v19; // [rsp+58h] [rbp+10h]

  if ( a3 )
  {
    v19 = a2;
    v5 = a2;
    if ( a2 )
    {
      if ( a1 )
      {
        if ( a4 )
        {
          v7 = a1[2];
          if ( (unsigned __int64)a1 >= a3 )
          {
            v8 = (unsigned int *)((char *)a1 + v7);
            v9 = (unsigned __int64)a1 + v7 + 0xC;
            if ( v9 > (unsigned __int64)a1 && v9 <= a3 + a4 && a1 + 3 >= a1 )
            {
              v10 = a1 + 0xA;
              if ( a1 + 0xA > a1 + 3 && v10 <= v8 && a1 != (unsigned int *)0xFFFFFFFFFFFFFFF4i64 )
              {
                v11 = a1[7];
                if ( (_DWORD)v11 )
                {
                  v12 = (unsigned int *)((char *)v10 + v11);
                  v13 = a1[9] - a1[4];
                  while ( v10 >= a1 )
                  {
                    v14 = v10 + 2;
                    if ( v10 + 2 <= v10 )
                      break;
                    if ( v14 > v8 )
                      break;
                    v15 = v10[1];
                    v16 = (char *)v10 + v15;
                    if ( (unsigned int *)((char *)v10 + v15) <= v10 )
                      break;
                    if ( v16 > (char *)v8 )
                      break;
                    if ( v10 >= v12 )
                      break;
                    v17 = *v10;
                    if ( !(_DWORD)v17 )
                      break;
                    if ( !(_DWORD)v15 )
                      break;
                    v18 = sub_1400524BC(v17, v5, a3);
                    if ( !v18 )
                      break;
                    while ( v14 < (unsigned int *)v16 && *(_WORD *)v14 )
                    {
                      if ( *(unsigned __int16 *)v14 >> 0xC == 1 )
                        *(_DWORD *)((char *)v18 + (*(_WORD *)v14 & 0xFFF)) += v13;
                      v14 = (unsigned int *)((char *)v14 + 2);
                    }
                    v5 = v19;
                    v10 = (unsigned int *)((char *)v10 + v10[1]);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

//----- (000000014002394C) ----------------------------------------------------
void __fastcall sub_14002394C(__int64 a1, unsigned __int64 a2, unsigned __int64 a3, __int64 a4, int a5, __int64 a6, __int64 a7, __int64 a8)
{
  char *v12; // rax
  char *v13; // rsi
  __int64 v14; // rax
  unsigned __int64 v15; // rax
  __int64 v16; // r9
  unsigned int *v17; // rbx
  __int64 v18; // r15
  int v19; // er13
  char *v20; // rcx
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // rcx
  __int64 v23; // [rsp+20h] [rbp-68h]
  __int64 v24; // [rsp+28h] [rbp-60h]
  __int64 v25; // [rsp+28h] [rbp-60h]
  __int64 v26; // [rsp+30h] [rbp-58h]
  __int64 v27; // [rsp+30h] [rbp-58h]
  __int64 v28; // [rsp+38h] [rbp-50h]
  __int64 v29; // [rsp+38h] [rbp-50h]
  unsigned __int64 v30; // [rsp+40h] [rbp-48h]
  __int64 v31; // [rsp+48h] [rbp-40h]
  int v32; // [rsp+50h] [rbp-38h]

  if ( a1 )
  {
    if ( a3 )
    {
      if ( a2 )
      {
        if ( a4 )
        {
          v12 = sub_140023194(a1, a3, a4);
          v13 = v12;
          if ( v12 )
          {
            if ( *(_DWORD *)v12 == 1 )
            {
              v14 = (unsigned int)((__int64 (*)(void))loc_1400455A0)() >> 0xE;
              LOBYTE(v14) = v14 & 1;
              a8 = v14;
              v15 = (unsigned int)((__int64 (*)(void))loc_1400455A0)() >> 0xF;
              LOBYTE(v15) = v15 & 1;
              v30 = v15;
              if ( sub_1400302C0(a2, &a7, &a5, v16, v23, v24, v26, v28) )
              {
                v17 = (unsigned int *)(v13 + 8);
                v18 = a7;
                if ( v13 + 8 < &v13[*((unsigned int *)v13 + 1)] )
                {
                  v19 = a5;
                  while ( 1 )
                  {
                    if ( (unsigned __int64)v17 < a3 )
                      goto LABEL_25;
                    v20 = (char *)v17 + v17[2];
                    if ( v20 <= (char *)v17 || (unsigned __int64)v20 > a3 + a4 )
                      goto LABEL_25;
                    v21 = *(_QWORD *)v17;
                    if ( *(_QWORD *)v17 == 7i64 )
                    {
                      sub_140023818(v17, a1, a3, a4);
                      v21 = *(_QWORD *)v17;
                    }
                    v22 = v21;
                    if ( (_BYTE)a8 )
                      break;
                    if ( (_BYTE)v30 )
                      goto LABEL_20;
LABEL_22:
                    if ( v21 > 0xFFFF )
                    {
                      LODWORD(v25) = v19;
                      sub_140023680((unsigned __int64)v17, a1, a3, a4, v18, v25, v27, v29, v30, v31);
                    }
                    v17 = (unsigned int *)((char *)v17 + v17[2] + 0xC);
                    if ( v17 >= (unsigned int *)&v13[*((unsigned int *)v13 + 1)] )
                      goto LABEL_25;
                  }
                  if ( v21 == 4 || v21 == 5 )
                  {
                    LODWORD(v25) = v19;
                    sub_1400234DC((unsigned __int64)v17, a1, a3, a4, v18, v25, v27, v29, v30, v31);
                    v22 = *(_QWORD *)v17;
                  }
LABEL_20:
                  v21 = v22;
                  if ( v22 == 3 )
                  {
                    LODWORD(v27) = v19;
                    sub_140023388((unsigned __int64)v17, a1, a2, a3, a4, v18, v27, v29, v30, v31, v32);
                    v21 = *(_QWORD *)v17;
                  }
                  goto LABEL_22;
                }
LABEL_25:
                sub_140051220(v18);
              }
            }
          }
        }
      }
    }
  }
}
// 1400239E4: variable 'v16' is possibly undefined
// 1400239E4: variable 'v23' is possibly undefined
// 1400239E4: variable 'v24' is possibly undefined
// 1400239E4: variable 'v26' is possibly undefined
// 1400239E4: variable 'v28' is possibly undefined
// 140023A85: variable 'v25' is possibly undefined
// 140023A85: variable 'v27' is possibly undefined
// 140023A85: variable 'v29' is possibly undefined
// 140023A85: variable 'v30' is possibly undefined
// 140023A85: variable 'v31' is possibly undefined
// 140023ABA: variable 'v32' is possibly undefined

//----- (0000000140023B20) ----------------------------------------------------
#error "140023BD4: call analysis failed (funcsize=71)"

//----- (0000000140023BFC) ----------------------------------------------------
__int64 __fastcall sub_140023BFC(__int64 a1, int a2, int a3, char a4, int a5)
{
  __int64 v8; // rdi
  __int64 v9; // rbx
  char v11; // [rsp+20h] [rbp-38h]
  __int64 v12[5]; // [rsp+30h] [rbp-28h] BYREF

  v8 = 0i64;
  if ( !a1 || !*(_QWORD *)(a1 + 8) || !*(_WORD *)a1 || !*(_WORD *)(a1 + 2) )
    return 0i64;
  if ( sub_1400593BC(a1, v12, &a5) )
  {
    v11 = a4;
    v9 = v12[0];
    v8 = sub_140023B20(v12[0], a5, a2, a3, v11);
    if ( v9 )
      sub_140051220(v9);
  }
  return v8;
}
// 140023B20: using guessed type __int64 __fastcall sub_140023B20(_DWORD, _DWORD, _DWORD, _DWORD, char);

//----- (0000000140023C8C) ----------------------------------------------------
void __fastcall sub_140023C8C(__int64 a1)
{
  if ( a1 )
    sub_140051220(a1);
}

//----- (0000000140023CA0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_140023CA0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, int a11, int a12, int a13, __int64 a14, __int64 a15)
{
  JUMPOUT(0x140023CCAi64);
}
// 14002428D: positive sp value 38 has been found
// 140023CC8: control flows out of bounds to 140023CCA

//----- (00000001400242A8) ----------------------------------------------------
unsigned __int64 __fastcall sub_1400242A8(__int64 a1, __int64 a2, __int64 *a3)
{
  unsigned __int64 v6; // r15
  unsigned __int64 v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rdi
  __int64 v10; // rdx
  __int64 v11; // r8
  __int64 v12; // r9
  unsigned __int64 v13; // rbx
  __int64 v14; // rax
  __int64 v16; // [rsp+20h] [rbp-60h] BYREF
  __int64 v17; // [rsp+28h] [rbp-58h]
  __int64 v18; // [rsp+30h] [rbp-50h]
  unsigned int v19; // [rsp+38h] [rbp-48h]
  __int64 v20; // [rsp+48h] [rbp-38h]
  void (__fastcall *v21)(__int64); // [rsp+58h] [rbp-28h]
  __int64 v22; // [rsp+60h] [rbp-20h]

  v6 = 0i64;
  ((void (__fastcall *)(__int64 *, _QWORD, __int64))loc_14006F2C0)(&v16, 0i64, 0x58i64);
  if ( !a1 || (unsigned __int64)(a2 - 1) > 0x63FFF || !a3 )
    return 0i64;
  *a3 = 0i64;
  v7 = 0x1E * a2;
  v8 = sub_140051084(0x1E * a2);
  v9 = v8;
  if ( v8 )
  {
    v16 = a1;
    LODWORD(v17) = a2;
    v18 = v8;
    v19 = 0x1E * a2;
    if ( !(unsigned int)sub_14003E9D8((__int64)&v16) )
    {
      if ( (unsigned int)sub_14003EAA0(&v16, v10, v11, v12, v16, v17, v18) == 1 && !(_DWORD)v17 )
      {
        if ( v19 )
        {
          v13 = v7 - v19;
          if ( v13 < v7 )
          {
            v14 = sub_140051084(v7 - v19);
            *a3 = v14;
            if ( v14 )
            {
              ((void (__fastcall *)(__int64, __int64, unsigned __int64))loc_14006F000)(v14, v9, v13);
              v6 = v13;
            }
          }
        }
      }
      if ( v20 )
        v21(v22);
    }
    sub_140051220(v9);
  }
  return v6;
}
// 14002433D: variable 'v10' is possibly undefined
// 14002433D: variable 'v11' is possibly undefined
// 14002433D: variable 'v12' is possibly undefined

//----- (0000000140024600) ----------------------------------------------------
char __fastcall sub_140024600(__int64 a1)
{
  char v2[56]; // [rsp+238h] [rbp+138h] BYREF

  if ( sub_140015378(a1, (__int64)v2) )
    JUMPOUT(0x140024662i64);
  return 0;
}
// 14002465F: control flows out of bounds to 140024662

//----- (0000000140024F34) ----------------------------------------------------
char __fastcall sub_140024F34(unsigned __int64 a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  char v11; // si
  unsigned __int64 v12; // rax
  __int64 v13; // rbx
  unsigned __int64 v14; // rdi
  __int64 v15; // rax
  __int64 v16; // r8
  char v17; // dl
  char v18; // cl
  __int64 v19; // r10
  __int64 v20; // r10
  __int64 v21; // rax
  __int64 v22; // rdx
  __int64 v23; // rcx
  __int64 v24; // r8
  __int64 v25; // r9
  __int64 v27; // [rsp+20h] [rbp-10h] BYREF
  __int64 v28; // [rsp+28h] [rbp-8h] BYREF

  v11 = 0;
  v12 = __readcr3();
  if ( sub_14003020C((v12 & 0xFFFFFFFFF000i64) + ((a1 >> 0x24) & 0xFF8), 8i64, (__int64)&v27) == 8
    && (v27 & 1) != 0
    && sub_14003020C((v27 & 0xFFFFFFFFF000i64) + ((a1 >> 0x1B) & 0xFF8), 8i64, (__int64)&a8) == 8
    && (a8 & 1) != 0
    && (char)a8 >= 0 )
  {
    v13 = (a8 & 0xFFFFFFFFF000i64) + ((a1 >> 0x12) & 0xFF8);
    if ( sub_14003020C(v13, 8i64, (__int64)&a5) == 8 && (a5 & 1) != 0 )
    {
      if ( (char)a5 < 0 )
      {
        v21 = sub_14004440C(v13);
        v22 = a5;
        v23 = a8;
        v24 = a5;
        *a2 = v21;
        v25 = (v27 | v23 | v24) ^ (v22 ^ (v27 | v23 | v24)) & 0x7FFFFFFFFFFFFFFFi64;
        *a3 = v25 ^ ((unsigned __int8)v25 ^ (unsigned __int8)(v27 & v23 & v22)) & 2;
        return 1;
      }
      v14 = a1 >> 9;
      if ( sub_14003020C((v14 & 0xFF8) + (a5 & 0xFFFFFFFFF000i64), 8i64, (__int64)&v28) == 8 )
      {
        v15 = ((__int64 (*)(void))loc_140012CDC)();
        v16 = v28;
        v17 = a5;
        v18 = a8;
        v19 = a8 | a5 | v28;
        *a2 = (v14 & 0x7FFFFFFFF8i64) + v15;
        v20 = (v27 | v19) ^ (v16 ^ (v27 | v19)) & 0x7FFFFFFFFFFFFFFFi64;
        *a3 = v20 ^ ((unsigned __int8)v20 ^ (unsigned __int8)(v27 & v18 & v17 & v16)) & 2;
        return 1;
      }
    }
  }
  return v11;
}

//----- (0000000140025134) ----------------------------------------------------
char __fastcall sub_140025134(unsigned __int64 a1, __int64 *a2, __int64 *a3)
{
  char v3; // r14
  _QWORD *v7; // rdi
  _QWORD *v8; // rsi
  __int64 v9; // rbx
  __int64 *v10; // r8
  __int64 v11; // rcx
  __int64 v12; // rdx
  __int64 v13; // rdx

  v3 = 0;
  if ( MEMORY[0xFFFFF7800000026C] >= 0xAu )
    return 0;
  v7 = (_QWORD *)(((a1 >> 0x24) & 0xFF8) - 0x90482413000i64);
  if ( (*(_BYTE *)v7 & 1) != 0 )
  {
    v8 = (_QWORD *)(((a1 >> 0x1B) & 0x1FFFF8) - 0x90482600000i64);
    if ( (*v8 & 1) != 0 && (char)*v8 >= 0 )
    {
      v9 = ((a1 >> 0x12) & 0x3FFFFFF8) - 0x904C0000000i64;
      if ( (*(_QWORD *)v9 & 1) != 0 )
      {
        if ( (char)*(_QWORD *)v9 < 0 )
        {
          *a2 = v9;
          *a3 = v9;
          v13 = (*v7 | *v8 | *(_QWORD *)v9) ^ (v9 ^ (*v7 | *v8 | *(_QWORD *)v9)) & 0x7FFFFFFFFFFFFFFFi64;
          *a3 = v13;
          *a3 = v13 | *(_DWORD *)v7 & *(_DWORD *)v8 & *(_DWORD *)v9 & 2;
          return 1;
        }
        v10 = (__int64 *)(((a1 >> 9) & 0x7FFFFFFFF8i64) + ((__int64 (*)(void))loc_140012CDC)());
        if ( (unsigned __int64)(v10 + 0x13000000000i64) <= 0x7FFFFFFFFFi64 )
        {
          *a2 = (__int64)v10;
          v11 = *v10;
          *a3 = *v10;
          v12 = (*v10 | *v7 | *v8 | *(_QWORD *)v9) ^ (v11 ^ (*v10 | *v7 | *v8 | *(_QWORD *)v9)) & 0x7FFFFFFFFFFFFFFFi64;
          *a3 = v12;
          *a3 = v12 ^ ((unsigned __int8)v12 ^ (unsigned __int8)(*(_BYTE *)v10 & *(_BYTE *)v7 & *(_BYTE *)v8 & *(_BYTE *)v9)) & 2;
          return 1;
        }
      }
    }
  }
  return v3;
}

//----- (00000001400252E0) ----------------------------------------------------
#error "140025336: call analysis failed (funcsize=35)"

//----- (0000000140025404) ----------------------------------------------------
__int64 __fastcall sub_140025404(_BYTE *a1, unsigned int a2)
{
  unsigned int v2; // er8
  __int64 v4; // r10
  __int64 v5; // rcx

  v2 = 0xFFFFFFFF;
  if ( a2 )
  {
    v4 = a2;
    do
    {
      v5 = (unsigned __int8)(v2 ^ *a1++);
      v2 = dword_1400BDD30[v5] ^ (v2 >> 8);
      --v4;
    }
    while ( v4 );
  }
  return ~v2;
}

//----- (000000014002591C) ----------------------------------------------------
char __fastcall sub_14002591C(__int64 a1, unsigned int a2, _QWORD *a3)
{
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        *a3 = 0i64;
        if ( sub_1400522E4(a1, a2) )
          JUMPOUT(0x14002597Bi64);
      }
    }
  }
  return 0;
}
// 140025978: control flows out of bounds to 14002597B

//----- (0000000140025A00) ----------------------------------------------------
char __fastcall sub_140025A00(unsigned __int64 a1, __int64 a2, __int64 *a3, __int64 a4, _DWORD *a5)
{
  char *v8; // r14
  char *v9; // rcx
  __int64 v10; // rax

  a5 = 0i64;
  if ( !a1 || !a2 || !a3 )
    return 0;
  *a3 = 0i64;
  if ( sub_14002591C(a1, a2, &a5) )
  {
    v8 = (char *)(a5 + 2);
    if ( (unsigned __int64)(a5 + 2) >= a1 )
    {
      v9 = &v8[*a5 - 8];
      if ( v9 > v8 && (unsigned __int64)v9 <= a1 + a2 )
      {
        v10 = sub_140051084(0x48ui64);
        *a3 = v10;
        if ( v10 )
          JUMPOUT(0x140025AB9i64);
      }
    }
  }
  return 0;
}
// 140025AB5: control flows out of bounds to 140025AB9

//----- (0000000140025BC0) ----------------------------------------------------
bool __fastcall sub_140025BC0(unsigned __int8 *a1, __int64 a2, _QWORD *a3, __int64 a4, __int64 a5)
{
  char v7; // r9
  unsigned __int8 *v8; // r8
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  bool v11; // zf
  unsigned int v12; // ecx
  int *v13; // r8
  __int64 v14; // rdx
  __int64 v15; // rcx
  unsigned int v16; // ecx
  unsigned int v17; // ecx
  unsigned int v18; // ecx
  bool v19; // zf
  unsigned int v20; // ecx
  unsigned int v21; // ecx
  unsigned int v22; // ecx
  unsigned int v23; // ecx
  unsigned int v24; // ecx
  char *v25; // r8
  __int64 v26; // rcx
  unsigned int v28; // ecx
  unsigned int v29; // ecx
  unsigned int v30; // ecx
  unsigned int v31; // ecx
  unsigned int v32; // ecx
  unsigned __int8 v33; // cl

  v7 = (char)a1;
  if ( a1 && a2 && a3 )
  {
    *a3 = 0i64;
    v8 = a1;
    if ( (unsigned __int8)(*a1 - 0x40) <= 0xFu )
      v8 = a1 + 1;
    v9 = *v8;
    if ( v9 <= 0x7C )
    {
      if ( v9 == 0x7C )
        goto LABEL_30;
      if ( v9 > 0x75 )
      {
        v16 = v9 - 0x76;
        if ( !v16 )
          goto LABEL_30;
        v12 = v16 - 1;
        v11 = v12 == 0;
        goto LABEL_17;
      }
      if ( v9 == 0x75 )
        goto LABEL_30;
      v10 = v9 - 0xF;
      if ( v10 )
      {
        v12 = v10 - 0x61;
        v11 = v12 == 0;
LABEL_17:
        if ( !v11 )
        {
          v17 = v12 - 1;
          if ( v17 )
          {
            v18 = v17 - 1;
            if ( v18 )
            {
              v20 = v18 - 1;
              v19 = v20 == 0;
LABEL_28:
              if ( !v19 && v20 != 1 )
                return *a3 != 0i64;
              goto LABEL_30;
            }
          }
        }
LABEL_30:
        v25 = (char *)(v8 + 1);
        v14 = *v25;
        v15 = (unsigned __int8)((_BYTE)v25 - v7) + 1i64;
        goto LABEL_31;
      }
      if ( (unsigned __int8)(v8[1] + 0x80) > 0xFu )
        return *a3 != 0i64;
      goto LABEL_13;
    }
    if ( v9 > 0xE2 )
    {
      v28 = v9 - 0xE3;
      if ( !v28 )
        goto LABEL_30;
      v29 = v28 - 5;
      if ( !v29 || (v30 = v29 - 1) == 0 )
      {
        v13 = (int *)(v8 + 1);
        goto LABEL_14;
      }
      v31 = v30 - 1;
      if ( v31 )
      {
        v32 = v31 - 1;
        if ( !v32 )
          goto LABEL_30;
        if ( v32 != 0x14 )
          return *a3 != 0i64;
        v33 = v8[1];
        if ( ((v33 - 0x15) & 0xE7) != 0 )
        {
          if ( ((v33 - 0x14) & 0xE7) == 0
            && ((v8[2] + 0x1B) & 0x3F) == 0
            && sub_14002FF18(*(unsigned int *)(v8 + 3), 8i64, (__int64)&a5) )
          {
            *a3 = a5;
          }
          return *a3 != 0i64;
        }
LABEL_13:
        v13 = (int *)(v8 + 2);
LABEL_14:
        v14 = *v13;
        v15 = (unsigned __int8)((_BYTE)v13 - v7) + 4i64;
LABEL_31:
        v26 = v14 + a2 + v15;
LABEL_32:
        *a3 = v26;
        return *a3 != 0i64;
      }
    }
    else
    {
      if ( v9 == 0xE2 )
        goto LABEL_30;
      v21 = v9 - 0x7D;
      if ( !v21 )
        goto LABEL_30;
      v22 = v21 - 1;
      if ( !v22 )
        goto LABEL_30;
      v23 = v22 - 1;
      if ( !v23 )
        goto LABEL_30;
      v24 = v23 - 0x1B;
      if ( v24 )
      {
        v20 = v24 - 0x46;
        v19 = v20 == 0;
        goto LABEL_28;
      }
    }
    v26 = *(unsigned int *)((unsigned __int8)((_BYTE)v8 - v7) + a2 + 1);
    goto LABEL_32;
  }
  return 0;
}

//----- (00000001400271FC) ----------------------------------------------------
#error "140027233: call analysis failed (funcsize=56)"

//----- (00000001400273C4) ----------------------------------------------------
__int64 __fastcall sub_1400273C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, ULONG *a6, char *a7, __int64 a8)
{
  unsigned __int64 v8; // rdi
  unsigned int v9; // ebx
  __int64 v10; // rdx
  __int64 v11; // rsi
  __int64 v12; // r8
  __int64 v13; // r9
  __int64 v14; // r8
  __int64 v15; // r9
  unsigned int v16; // edx
  char v17; // dl
  __int64 v18; // rdi
  ULONG v20[18]; // [rsp+20h] [rbp-79h] BYREF
  __int64 v21; // [rsp+68h] [rbp-31h] BYREF
  __int64 v22; // [rsp+70h] [rbp-29h] BYREF
  unsigned __int16 v23[8]; // [rsp+78h] [rbp-21h] BYREF
  char v24[104]; // [rsp+88h] [rbp-11h] BYREF

  v8 = 0i64;
  LODWORD(a5) = 0;
  v9 = 2;
  v11 = sub_14000A0E4(a1, a2, a3, a4, v20[0]);
  if ( v11 )
  {
    LOBYTE(v10) = 1;
    if ( sub_140014874(v23, v10, v12, v13) )
    {
      if ( MEMORY[0xFFFFF7800000026C] <= 6u
        && (MEMORY[0xFFFFF7800000026C] != 6 || (unsigned int)(MEMORY[0xFFFFF78000000270] - 2) > 1) )
      {
        goto LABEL_10;
      }
      v20[0] = 0x53ADF459;
      v20[1] = 0x15912FA8;
      v20[2] = 0x9883E39E;
      v20[3] = 0xBF0FAA53;
      v20[4] = 0x4AD34AF5;
      v20[5] = 0xF04C3619;
      v20[6] = 0x6B7B6B6A;
      v20[7] = 0x5226E83C;
      v20[8] = 0x21BA9D72;
      v20[9] = 0xE68E8C5F;
      v20[0xA] = 0x88D04BF8;
      v20[0xB] = 0xC4D31B7F;
      v20[0xC] = 0xE3D9225E;
      v20[0xD] = 0xC80158C0;
      v20[0xE] = 0x62EF461E;
      v20[0xF] = 0x5F226ECD;
      v20[0x10] = 0x1B1CD01F;
      ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v24, 0i64, 0x44i64);
      v16 = 0xA1B5E05F;
      a6 = v20;
      a7 = v24;
      do
      {
        v16 = __ROL4__(
                ((v16 ^ (v16 << 0xD)) >> 0x11) ^ v16 ^ (v16 << 0xD) ^ (0x20
                                                                     * (((v16 ^ (v16 << 0xD)) >> 0x11) ^ v16 ^ (v16 << 0xD))),
                3);
        *(_DWORD *)&a7[v8] = *(ULONG *)((char *)a6 + v8) ^ v16;
        v8 += 4i64;
      }
      while ( v8 < 0x44 );
      LOBYTE(v8) = 1;
      LOBYTE(v14) = 1;
      if ( sub_140006F00((__int64)v23, (__int64)v24, v14, v15) )
      {
        v17 = 1;
      }
      else
      {
LABEL_10:
        v17 = 0;
        if ( (v8 & 1) == 0 )
          goto LABEL_13;
      }
      memset(v24, 0, 0x44ui64);
      if ( v17 )
      {
        v9 = 1;
LABEL_26:
        sub_14000724C((__int64)v23);
        return v9;
      }
LABEL_13:
      if ( sub_1400593BC((__int64)v23, &a8, &a5) )
      {
        v18 = a8;
        if ( (unsigned int)a5 >= 0x1000 )
          v9 = !sub_14005240C(v11, 0x1000ui64, &a5, &v21)
            || !sub_14005240C(v18, 0x1000ui64, &a5, &v22)
            || *(_WORD *)(v21 + 6) != *(_WORD *)(v22 + 6)
            || *(_DWORD *)(v21 + 8) != *(_DWORD *)(v22 + 8)
            || *(_DWORD *)(v21 + 0x28) != *(_DWORD *)(v22 + 0x28)
            || *(_DWORD *)(v21 + 0x58) != *(_DWORD *)(v22 + 0x58)
            || *(_DWORD *)(v21 + 0x50) != *(_DWORD *)(v22 + 0x50);
        if ( v18 )
          sub_140051220(v18);
      }
      goto LABEL_26;
    }
  }
  return v9;
}
// 1400273F6: variable 'v10' is possibly undefined
// 1400273F6: variable 'v12' is possibly undefined
// 1400273F6: variable 'v13' is possibly undefined
// 14002750A: variable 'v14' is possibly undefined
// 14002750A: variable 'v15' is possibly undefined

//----- (0000000140028CF4) ----------------------------------------------------
signed __int64 __fastcall sub_140028CF4(unsigned __int64 *a1, unsigned __int64 *a2, __int64 a3, char a4)
{
  signed __int64 result; // rax
  unsigned __int64 *v7; // rbp
  unsigned __int64 *v8; // rdi
  unsigned __int64 *v9; // r15
  __int64 v10; // r14
  __int64 v11; // r9
  __int64 v12; // rsi
  unsigned __int64 *v13; // rbp
  unsigned __int64 *v14; // [rsp+30h] [rbp-48h] BYREF
  __int64 v15; // [rsp+38h] [rbp-40h]

  result = (char *)a2 - (char *)a1;
  v7 = a2;
  v8 = a1;
  if ( (char *)a2 - (char *)a1 < 0x318 )
  {
LABEL_7:
    if ( v8 != v7 && v8 + 3 != v7 )
      JUMPOUT(0x140028EACi64);
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_140028F54(&v14, v8, v7);
      v9 = v14;
      v10 = v15;
      LOBYTE(v11) = a4;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(0xAAAAAAAAAAAAAAABui64 * (v14 - v8)) >= (__int64)(0xAAAAAAAAAAAAAAABui64
                                                                     * (((__int64)v7 - v15) >> 3)) )
      {
        sub_140028CF4(v15, v7, a3, v11);
        v7 = v9;
      }
      else
      {
        sub_140028CF4(v8, v14, a3, v11);
        v8 = (unsigned __int64 *)v10;
      }
      result = (char *)v7 - (char *)v8;
      if ( (char *)v7 - (char *)v8 < 0x318 )
        goto LABEL_7;
    }
    v12 = (char *)v7 - (char *)v8;
    if ( (__int64)(0xAAAAAAAAAAAAAAABui64 * (v7 - v8)) >> 1 > 0 )
      JUMPOUT(0x140028E01i64);
    if ( (__int64)(0xAAAAAAAAAAAAAAABui64 * (v7 - v8)) >= 2 )
    {
      v13 = v7 + 0xFFFFFFFD;
      do
      {
        if ( (__int64)(0xAAAAAAAAAAAAAAABui64 * (v12 >> 3)) >= 2 )
          JUMPOUT(0x140028E52i64);
        v12 = (char *)v13 - (char *)v8;
        v13 += 0xFFFFFFFD;
      }
      while ( v12 >= 0x30 );
    }
  }
  return result;
}
// 140028DFD: control flows out of bounds to 140028E01
// 140028E50: control flows out of bounds to 140028E52
// 140028F2D: control flows out of bounds to 140028EAC
// 140028D9B: variable 'v11' is possibly undefined

//----- (0000000140028F54) ----------------------------------------------------
unsigned __int64 **__fastcall sub_140028F54(unsigned __int64 **a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  unsigned __int64 *v6; // rdx
  unsigned __int64 *v7; // rax
  unsigned __int64 v8; // rcx
  unsigned __int64 *v9; // r9
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // r8
  unsigned __int64 *v12; // rcx
  unsigned __int64 *v13; // r8
  bool v14; // zf
  unsigned __int64 *v15; // r9
  unsigned __int64 *v16; // r8
  unsigned __int64 **result; // rax

  sub_14002926C(a2, &a2[3 * ((__int64)(0xAAAAAAAAAAAAAAABui64 * (a3 - a2)) >> 1)], a3 + 0xFFFFFFFD);
  v7 = v6 + 3;
  if ( a2 < v6 )
  {
    v8 = *v6;
    do
    {
      v9 = v6 + 0xFFFFFFFD;
      v10 = v6[0xFFFFFFFD];
      if ( v10 < v8 )
        break;
      if ( v10 > v8 )
        break;
      v6 += 0xFFFFFFFD;
      v8 = v10;
    }
    while ( a2 < v9 );
  }
  if ( v7 < a3 )
  {
    v11 = *v6;
    do
    {
      if ( *v7 < v11 )
        break;
      if ( *v7 > v11 )
        break;
      v7 += 3;
    }
    while ( v7 < a3 );
  }
  v12 = v7;
  v13 = v6;
  while ( v12 < a3 )
  {
    if ( *v6 >= *v12 )
    {
      if ( *v6 > *v12 )
        break;
      if ( v7 != v12 )
        JUMPOUT(0x140028FEFi64);
      v7 += 3;
    }
    v12 += 3;
  }
  v14 = v6 == a2;
  if ( v6 > a2 )
  {
    v15 = v6 + 0xFFFFFFFD;
    do
    {
      if ( *v15 >= *v6 )
      {
        if ( *v15 > *v6 )
          break;
        v6 += 0xFFFFFFFD;
        if ( v6 != v15 )
          JUMPOUT(0x140029038i64);
      }
      v13 += 0xFFFFFFFD;
      v15 += 0xFFFFFFFD;
    }
    while ( a2 < v13 );
    v14 = v13 == a2;
  }
  if ( !v14 )
  {
    v16 = v13 + 0xFFFFFFFD;
    if ( v12 == a3 )
    {
      if ( v16 != v6 + 0xFFFFFFFD )
        JUMPOUT(0x1400290DBi64);
      JUMPOUT(0x1400290FFi64);
    }
    JUMPOUT(0x140029128i64);
  }
  if ( v12 != a3 )
  {
    if ( v7 != v12 )
      JUMPOUT(0x14002907Ci64);
    JUMPOUT(0x14002909Ci64);
  }
  a1[1] = v7;
  result = a1;
  *a1 = v6;
  return result;
}
// 140028FED: control flows out of bounds to 140028FEF
// 140029036: control flows out of bounds to 140029038
// 14002907A: control flows out of bounds to 14002907C
// 1400290D9: control flows out of bounds to 1400290DB
// 14002907A: control flows out of bounds to 14002909C
// 1400290D0: control flows out of bounds to 140029128
// 1400290D9: control flows out of bounds to 1400290FF
// 140028F9B: variable 'v6' is possibly undefined

//----- (000000014002916C) ----------------------------------------------------
void __fastcall sub_14002916C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = (a3 - 1) >> 1;
  if ( a2 < v3 )
    JUMPOUT(0x1400291B5i64);
  if ( a2 == v3 && (a3 & 1) == 0 )
    JUMPOUT(0x1400291E5i64);
  JUMPOUT(0x14002923Fi64);
}
// 1400291B1: control flows out of bounds to 1400291B5
// 1400291E1: control flows out of bounds to 1400291E5
// 14002921F: control flows out of bounds to 140029222
// 140029205: control flows out of bounds to 14002923F

//----- (000000014002926C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
unsigned __int64 __fastcall sub_14002926C(unsigned __int64 *a1, unsigned __int64 *a2, unsigned __int64 *a3)
{
  signed __int64 v4; // rax
  __int64 v5; // rax
  __int64 v6; // rbx
  __int64 v7; // r8
  unsigned __int64 v8; // rax
  unsigned __int64 v9; // rax
  unsigned __int64 result; // rax

  v4 = 0xAAAAAAAAAAAAAAABui64 * (a3 - a1);
  if ( v4 <= 0x28 )
  {
    result = *a2;
    if ( *a2 < *a1 )
      JUMPOUT(0x1400294EEi64);
    if ( *a3 < result )
      JUMPOUT(0x140029516i64);
  }
  else
  {
    v5 = 3 * ((v4 + 1) >> 3);
    v6 = 0x10 * v5;
    v7 = 8 * v5;
    v8 = a1[v5];
    if ( v8 < *a1 )
      JUMPOUT(0x1400292BAi64);
    if ( a1[(unsigned __int64)v6 / 8] < v8 )
      JUMPOUT(0x1400292ECi64);
    if ( *a2 < a2[v7 / 0xFFFFFFFFFFFFFFF8ui64] )
      JUMPOUT(0x14002934Bi64);
    if ( a2[(unsigned __int64)v7 / 8] < *a2 )
      JUMPOUT(0x140029378i64);
    v9 = a3[v7 / 0xFFFFFFFFFFFFFFF8ui64];
    if ( v9 < a3[v6 / 0xFFFFFFFFFFFFFFF8ui64] )
      JUMPOUT(0x1400293D8i64);
    if ( *a3 < v9 )
      JUMPOUT(0x140029408i64);
    result = *a2;
    if ( *a2 < a1[(unsigned __int64)v7 / 8] )
      JUMPOUT(0x14002945Fi64);
    if ( a3[v7 / 0xFFFFFFFFFFFFFFF8ui64] < result )
      JUMPOUT(0x140029493i64);
  }
  return result;
}
// 1400292E0: positive sp value 8 has been found
// 1400292B8: control flows out of bounds to 1400292BA
// 1400292EA: control flows out of bounds to 1400292EC
// 140029349: control flows out of bounds to 14002934B
// 140029376: control flows out of bounds to 140029378
// 1400293D6: control flows out of bounds to 1400293D8
// 140029406: control flows out of bounds to 140029408
// 14002945D: control flows out of bounds to 14002945F
// 14002948D: control flows out of bounds to 140029493
// 1400294EC: control flows out of bounds to 1400294EE
// 140029514: control flows out of bounds to 140029516

//----- (0000000140029560) ----------------------------------------------------
_DWORD *__fastcall sub_140029560(unsigned __int64 a1, _DWORD *a2)
{
  _DWORD *v2; // r8
  int v4; // er9
  _QWORD *i; // r10
  unsigned __int64 v6; // rcx

  v2 = 0i64;
  if ( a1 )
  {
    if ( a2 )
    {
      v4 = 0;
      if ( *a2 )
      {
        for ( i = a2 + 4; ; i += 3 )
        {
          v6 = i[0xFFFFFFFF];
          if ( a1 >= v6 && a1 <= *i + v6 )
            break;
          if ( (unsigned int)++v4 >= *a2 )
            return v2;
        }
        v2 = &a2[4 * v4 + 2 + 2 * v4];
      }
    }
  }
  return v2;
}

//----- (00000001400295BC) ----------------------------------------------------
__int64 sub_1400295BC()
{
  __int64 result; // rax
  __int64 v1; // rbx
  __int64 v2; // rax
  __int64 (__fastcall *v3)(__int64, _QWORD, int *, _QWORD); // rax

  if ( qword_1400DA9C0 )
    return 0xC0000001i64;
  v1 = ((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(qword_1400DA9D8, &qword_1400DA9D8, 0i64);
  v2 = ((__int64 (__fastcall *)(__int64, __int64 *))loc_1400404E8)(qword_1400DA9E0, &qword_1400DA9E0);
  if ( !v1 || !v2 )
    return 0i64;
  v3 = (__int64 (__fastcall *)(__int64, _QWORD, int *, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *))loc_1400404E8)(
                                                                 qword_1400DA9D8,
                                                                 &qword_1400DA9D8);
  if ( v3 )
  {
    result = v3(1i64, 0i64, &dword_14001F534, 0i64);
    if ( (int)result >= 0 )
      return result;
  }
  else
  {
    result = 0xC0000002i64;
  }
  qword_1400DA9C0 = 0i64;
  return result;
}
// 14001F534: using guessed type int dword_14001F534;
// 1400DA9C0: using guessed type __int64 qword_1400DA9C0;
// 1400DA9D8: using guessed type __int64 qword_1400DA9D8;
// 1400DA9E0: using guessed type __int64 qword_1400DA9E0;

//----- (0000000140029664) ----------------------------------------------------
void sub_140029664()
{
  __int64 v0; // rbx
  void (__fastcall *v1)(__int64); // rax

  v0 = _InterlockedExchange64(&qword_1400DA9C0, 0i64);
  if ( v0 )
  {
    v1 = (void (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                         qword_1400DA9E0,
                                         &qword_1400DA9E0,
                                         0i64);
    if ( v1 )
      v1(v0);
  }
}
// 1400DA9C0: using guessed type __int64 qword_1400DA9C0;
// 1400DA9E0: using guessed type __int64 qword_1400DA9E0;

//----- (00000001400296A0) ----------------------------------------------------
bool __fastcall sub_1400296A0(unsigned __int64 a1, __int64 a2, unsigned __int64 *a3)
{
  unsigned __int64 v3; // r9
  unsigned __int64 v4; // rax
  unsigned __int64 v5; // rdx
  bool result; // al

  v3 = *a3;
  v4 = *a3 + *((unsigned int *)a3 + 2);
  result = 0;
  if ( *a3 < v4 && a1 >= v3 && a1 < v4 )
  {
    v5 = a1 + a2;
    if ( v5 >= v3 && v5 <= v4 )
      result = 1;
  }
  return result;
}

//----- (00000001400296CC) ----------------------------------------------------
char __fastcall sub_1400296CC(unsigned __int64 *a1, unsigned __int64 a2, __int64 a3)
{
  unsigned __int64 *v3; // r8
  __int64 v4; // r10
  __int64 v5; // rcx
  _QWORD *v6; // r11
  int v7; // eax

  if ( !a2 )
    return 0;
  if ( !a3 )
    return 0;
  if ( !sub_1400296A0(a2, 6i64, a1) )
    return 0;
  if ( *(_WORD *)(v4 + 4) != 0x6B6E )
    return 0;
  if ( ((*(int *)v4 >> 0x1F) ^ *(_DWORD *)v4) == *(int *)v4 >> 0x1F )
    return 0;
  if ( !sub_1400296A0(v4 + 6, 0x149i64, v3) )
    return 0;
  if ( !*(_WORD *)(v5 + 0x46) )
    return 0;
  v7 = *(_DWORD *)(v5 + 0x22);
  if ( !v7 && !*(_DWORD *)(v5 + 0x12) )
    return 0;
  if ( *(_DWORD *)(v5 + 0x12) && *(_DWORD *)(v5 + 0x1A) == 0xFFFFFFFF || v7 && *(_DWORD *)(v5 + 0x26) == 0xFFFFFFFF )
    return 0;
  *v6 = v5;
  return 1;
}
// 1400296FB: variable 'v4' is possibly undefined
// 140029715: variable 'v3' is possibly undefined
// 14002971E: variable 'v5' is possibly undefined
// 140029746: variable 'v6' is possibly undefined

//----- (0000000140029758) ----------------------------------------------------
char __fastcall sub_140029758(__int64 a1, unsigned __int64 a2, int a3, __int64 a4)
{
  char v7; // di
  __int64 v8; // rax

  *(_DWORD *)a4 = a3;
  *(_QWORD *)(a4 + 8) = a2;
  v7 = 0;
  v8 = sub_140051084(a2);
  *(_QWORD *)(a4 + 0x10) = v8;
  if ( v8 )
  {
    ((void (__fastcall *)(__int64, __int64, unsigned __int64))loc_14006F000)(v8, a1, a2);
    v7 = 1;
  }
  return v7;
}

//----- (00000001400297B8) ----------------------------------------------------
char __fastcall sub_1400297B8(__int64 a1, int a2, __int64 a3, __int64 a4)
{
  unsigned __int64 v8; // rcx
  int v9; // edi
  unsigned __int16 v10; // r10
  unsigned __int64 v11; // rcx
  unsigned __int64 v12; // rsi
  unsigned __int64 *v13; // r8

  if ( a1 )
  {
    v8 = *(_QWORD *)a1;
    if ( v8 )
    {
      if ( *(_DWORD *)(a1 + 8) )
      {
        v9 = *(_DWORD *)(a3 + 2);
        if ( v9 >= 0 )
        {
          v12 = v8 + *(unsigned int *)(a3 + 6);
          if ( sub_1400296A0(v12 + 0x1000, 6i64, (unsigned __int64 *)a1) )
          {
            v10 = 0xFFFF;
            if ( (unsigned int)v9 <= 0xFFFF )
              v10 = v9;
            v11 = v12 + 0x1004;
            if ( *(_WORD *)(v12 + 0x1004) != 0x6264
              && (*(int *)(v12 + 0x1000) - 6i64 >= (unsigned __int64)v10 || sub_1400296A0(v11, v10, v13)) )
            {
              if ( (unsigned int)(a2 - 4) <= 1 || a2 == 0xB )
                JUMPOUT(0x140029887i64);
              return sub_140029758(v11, v10, a2, a4);
            }
          }
        }
        else
        {
          v10 = v9;
          if ( (unsigned __int16)v9 <= 4u )
          {
            v11 = a3 + 6;
            return sub_140029758(v11, v10, a2, a4);
          }
        }
      }
    }
  }
  return 0;
}
// 140029883: control flows out of bounds to 140029887
// 140029868: variable 'v13' is possibly undefined
// 14002989A: variable 'v11' is possibly undefined
// 140029890: variable 'v10' is possibly undefined

//----- (00000001400298B8) ----------------------------------------------------
char __fastcall sub_1400298B8(__int64 a1, int *a2, __int64 a3, __int64 *a4)
{
  char v4; // bl
  __int64 v9; // rax
  __int64 v10; // rsi
  __int64 v11; // rdi
  __int64 v12; // rax
  __int64 v13; // rcx
  int v14; // eax
  __int64 v15; // rdx
  __int64 v16; // rcx

  v4 = 0;
  if ( a4 )
  {
    v9 = sub_140051084(0x40ui64);
    v10 = v9;
    if ( v9 )
    {
      v11 = v9 + 0x18;
      if ( sub_140007788(v9 + 0x18, (__int16 *)a1, *(_WORD *)(a1 + 2))
        && (v12 = sub_140051084(*((_QWORD *)a2 + 1)), *(_QWORD *)(v10 + 0x38) = v12, (v13 = v12) != 0) )
      {
        v14 = *a2;
        v15 = *((_QWORD *)a2 + 2);
        *(_QWORD *)(v10 + 0x30) = *((_QWORD *)a2 + 1);
        *(_QWORD *)(v10 + 0x10) = a3;
        *(_DWORD *)(v10 + 0x28) = v14;
        ((void (__fastcall *)(__int64, __int64))loc_14006F000)(v13, v15);
        *a4 = v10;
        v4 = 1;
      }
      else
      {
        if ( v11 )
        {
          v16 = *(_QWORD *)(v11 + 8);
          if ( v16 )
          {
            if ( *(_WORD *)v11 && *(_WORD *)(v11 + 2) )
            {
              sub_140051220(v16);
              JUMPOUT(0x140029969i64);
            }
          }
        }
        sub_140051220(v10);
      }
    }
  }
  return v4;
}
// 140029964: control flows out of bounds to 140029969

//----- (0000000140029998) ----------------------------------------------------
void __fastcall sub_140029998(__int64 a1)
{
  __int64 v2; // rcx
  __int64 v3; // rcx

  if ( a1 )
  {
    v2 = *(_QWORD *)(a1 + 0x38);
    if ( v2 )
      sub_140051220(v2);
    if ( a1 != 0xFFFFFFFFFFFFFFE8ui64 )
    {
      v3 = *(_QWORD *)(a1 + 0x20);
      if ( v3 )
      {
        if ( *(_WORD *)(a1 + 0x18) && *(_WORD *)(a1 + 0x1A) )
        {
          sub_140051220(v3);
          JUMPOUT(0x1400299E1i64);
        }
      }
    }
    sub_140051220(a1);
  }
}
// 1400299DC: control flows out of bounds to 1400299E1

//----- (0000000140029A00) ----------------------------------------------------
char __fastcall sub_140029A00(unsigned __int64 *a1, __int64 a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  unsigned __int64 v11; // rdx
  unsigned int v12; // er13
  int v13; // eax
  unsigned int *v14; // rcx
  unsigned __int64 *v15; // r8
  __int64 v16; // r10
  __int64 v17; // rax
  __int64 v18; // rcx
  unsigned __int64 *v19; // r8
  __int64 v20; // rcx
  unsigned int v21; // er10
  _BYTE *v22; // rbx
  unsigned int v23; // er11
  int v24; // er10
  unsigned int v25; // er8
  unsigned int v26; // edx
  __int64 v27; // rcx
  int v29; // [rsp+20h] [rbp-40h]
  unsigned __int16 v30; // [rsp+30h] [rbp-30h] BYREF
  _BYTE *v31; // [rsp+38h] [rbp-28h]

  if ( !a1 || !a2 || !a9 )
    return 0;
  if ( a3 == *(_DWORD *)a9 - 1 )
  {
    v11 = *(_QWORD *)(a9 + 0x70);
    if ( MEMORY[0xFFFFF78000000014] - *(_QWORD *)(a2 + 2) < v11 || !v11 )
    {
      v12 = 0;
      if ( *(_DWORD *)(a2 + 0x22) )
      {
        v13 = *(_DWORD *)(a2 + 0x26) + 0x1004;
        v29 = v13;
        do
        {
          if ( sub_1400296A0(*a1 + v13 + 4 * v12, 4i64, a1) )
          {
            v17 = *v14;
            if ( (_DWORD)v17 )
            {
              if ( sub_1400296A0(v17 + v16 + 0x1000, 0x18i64, v15)
                && *(_WORD *)(v18 + 4) == 0x6B76
                && ((*(int *)v18 >> 0x1F) ^ *(_DWORD *)v18) != *(int *)v18 >> 0x1F
                && *(_WORD *)(v18 + 6)
                && sub_1400296A0(v18 + 0x18, *(unsigned __int16 *)(v18 + 6), v19)
                && sub_1400076F8((__int64)&v30, v20, v21) )
              {
                v22 = v31;
                sub_140025404(v31, v30);
                sub_14000512C(v22, v23, 0);
                v25 = *(_DWORD *)(a9 + 0x68);
                v26 = 0;
                if ( v25 )
                {
                  v27 = a9 + 0x1C;
                  do
                  {
                    if ( v26 >= 0xA )
                      break;
                    if ( *(_DWORD *)(v27 - 4) == v24 )
                      JUMPOUT(0x140029B84i64);
                    ++v26;
                    v27 += 8i64;
                  }
                  while ( v26 < v25 );
                }
                if ( v22 )
                {
                  sub_140051220((__int64)v22);
                  JUMPOUT(0x140029C42i64);
                }
              }
            }
          }
          v13 = v29;
          ++v12;
        }
        while ( v12 < *(_DWORD *)(a2 + 0x22) );
      }
    }
  }
  return 0;
}
// 140029B80: control flows out of bounds to 140029B84
// 140029C3D: control flows out of bounds to 140029C42
// 140029AB7: variable 'v14' is possibly undefined
// 140029AC1: variable 'v16' is possibly undefined
// 140029AD0: variable 'v15' is possibly undefined
// 140029AE2: variable 'v18' is possibly undefined
// 140029B13: variable 'v19' is possibly undefined
// 140029B2A: variable 'v20' is possibly undefined
// 140029B23: variable 'v21' is possibly undefined
// 140029B57: variable 'v23' is possibly undefined
// 140029B7C: variable 'v24' is possibly undefined

//----- (0000000140029C7C) ----------------------------------------------------
__int64 __fastcall sub_140029C7C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  int v9; // eax
  __int64 v10; // r14
  unsigned __int64 v12; // rsi
  __int64 *v13; // r10
  _BYTE *v15; // r15
  unsigned int v16; // er14
  int v17; // eax
  __int64 v18; // r10
  int v19; // eax
  int v20; // er11
  __int64 v21; // r15
  __int16 v22; // cx
  int v23; // esi
  __int64 v24; // [rsp+88h] [rbp+10h]

  v24 = a2;
  v9 = 0;
  v10 = a2;
  if ( a1 )
  {
    v12 = *(_QWORD *)a1;
    if ( *(_QWORD *)a1 )
    {
      if ( *(_DWORD *)(a1 + 8) && a2 && a9 && a3 < *(_DWORD *)a9 )
      {
        v13 = *(__int64 **)(a9 + 8);
        while ( v13 != (__int64 *)(a9 + 8) )
        {
          if ( v9 == a3 )
          {
            if ( *((_DWORD *)v13 + 4) != 0xFFFFFFFF || *((_DWORD *)v13 + 5) != 0xFFFFFFFF )
            {
              if ( *(_WORD *)(a4 + 0x46) >= 0xFFu )
                return 0i64;
              v15 = (_BYTE *)(a4 + 0x4A);
              v16 = *(unsigned __int16 *)(a4 + 0x46);
              v17 = sub_14000512C((_BYTE *)(a4 + 0x4A), v16, 0);
              if ( *(_DWORD *)(v18 + 0x14) != v17 )
                return 0i64;
              v19 = sub_140025404(v15, v16);
              if ( v20 != v19 )
                return 0i64;
              v10 = v24;
            }
            v21 = v12 + v10;
            if ( !sub_1400296A0(v12 + v10, 8i64, (unsigned __int64 *)a1) )
              return 0i64;
            v22 = *(_WORD *)(v21 + 4);
            if ( ((v22 - 0x666C) & 0xFCFF) != 0 || v22 == 0x676C || !*(_WORD *)(v21 + 6) )
              return 0i64;
            v23 = 0;
            if ( *(_WORD *)(v21 + 6) )
            {
              do
              {
                if ( *(_WORD *)(v21 + 4) )
                  JUMPOUT(0x140029DE9i64);
                ++v23;
              }
              while ( v23 < *(unsigned __int16 *)(v21 + 6) );
            }
            return 0i64;
          }
          v13 = (__int64 *)*v13;
          ++v9;
        }
      }
    }
  }
  return 0i64;
}
// 140029DE6: control flows out of bounds to 140029DE9
// 140029D39: variable 'v18' is possibly undefined
// 140029D4D: variable 'v20' is possibly undefined

//----- (0000000140029F7C) ----------------------------------------------------
char __fastcall sub_140029F7C(__int64 a1, __int64 a2, unsigned int a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int *a9)
{
  unsigned __int64 v12; // rax
  __int64 v13; // rbx
  int v14; // esi
  _DWORD *v15; // rcx

  if ( !a1 )
    return 0;
  v12 = *(_QWORD *)a1;
  if ( !*(_QWORD *)a1 || !*(_DWORD *)(a1 + 8) && a3 >= *a9 )
    return 0;
  v13 = v12 + a2;
  if ( !sub_1400296A0(v12 + a2, 8i64, (unsigned __int64 *)a1)
    || *(_WORD *)(v13 + 4) != 0x6972
    || ((*(int *)v13 >> 0x1F) ^ *(_DWORD *)v13) == *(int *)v13 >> 0x1F
    || !*(_WORD *)(v13 + 6) )
  {
    return 0;
  }
  v14 = 0;
  if ( *(_WORD *)(v13 + 6) )
  {
    do
    {
      if ( sub_1400296A0(v13 + (unsigned int)(4 * v14 + 8), 4i64, (unsigned __int64 *)a1) )
        sub_140029C7C(a1, *v15 + 0x1000, a3, a4, (__int64)a9);
      ++v14;
    }
    while ( v14 < *(unsigned __int16 *)(v13 + 6) );
  }
  return 1;
}
// 14002A01E: variable 'v15' is possibly undefined
// 140029C7C: using guessed type __int64 __fastcall sub_140029C7C(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (000000014002A06C) ----------------------------------------------------
char __fastcall sub_14002A06C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int *a9)
{
  unsigned __int64 v9; // r14
  unsigned __int64 v12; // rbp
  char result; // al
  __int64 v14; // rcx
  __int64 v15; // r10
  int v16; // er11
  __int64 v17; // rdi
  unsigned int v18; // er15
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  __int64 v23; // [rsp+28h] [rbp-20h]
  __int64 v24; // [rsp+30h] [rbp-18h]
  __int64 v25; // [rsp+38h] [rbp-10h]
  unsigned int *v26; // [rsp+40h] [rbp-8h]

  v9 = *(_QWORD *)a1;
  v12 = *(_QWORD *)a1 + a2;
  result = sub_1400296A0(v12, 6i64, (unsigned __int64 *)a1);
  if ( result )
  {
    v17 = (__int64)a9;
    v18 = *a9;
    while ( a3 < v18 )
    {
      v19 = *(__int16 *)(v14 + 4) - 0x666C;
      if ( !v19 )
        return sub_140029C7C(a1, v15, a3, v16, v17);
      v20 = v19 - 0x200;
      if ( !v20 )
        return sub_140029C7C(a1, v15, a3, v16, v17);
      v21 = v20 - 0x100;
      if ( !v21 )
        return sub_140029C7C(a1, v15, a3, v16, v17);
      v22 = v21 - 6;
      if ( !v22 )
        return sub_140029F7C(a1, v15, a3, v16, v17, v23, v24, v25, v26);
      if ( v22 == 0x1FC )
      {
        if ( v9 )
        {
          if ( *(_DWORD *)(a1 + 8) )
          {
            if ( v15 )
            {
              result = sub_1400296A0(v12, 0x14Fi64, (unsigned __int64 *)a1);
              if ( result )
              {
                result = sub_1400296CC((unsigned __int64 *)a1, v12, (__int64)&a5);
                if ( result )
                {
                  v12 = v9 + *(unsigned int *)(a5 + 0x1A) + 0x1000i64;
                  result = sub_1400296A0(v12, 6i64, (unsigned __int64 *)a1);
                  if ( result )
                    continue;
                }
              }
            }
          }
        }
      }
      return result;
    }
  }
  return result;
}
// 14002A0C0: variable 'v14' is possibly undefined
// 14002A10F: variable 'v15' is possibly undefined
// 14002A17C: variable 'v16' is possibly undefined
// 14002A17C: variable 'v23' is possibly undefined
// 14002A17C: variable 'v24' is possibly undefined
// 14002A17C: variable 'v25' is possibly undefined
// 14002A17C: variable 'v26' is possibly undefined
// 140029C7C: using guessed type __int64 __fastcall sub_140029C7C(_DWORD, _DWORD, _DWORD, _DWORD, __int64);

//----- (000000014002A350) ----------------------------------------------------
__int64 __fastcall sub_14002A350(__int64 a1)
{
  signed __int32 v2; // ecx
  __int64 result; // rax
  unsigned int i; // esi

  v2 = _InterlockedIncrement((volatile signed __int32 *)a1);
  while ( *(int *)a1 < 2 )
    __asm { rep nop }
  if ( v2 == 1 )
  {
    *(_QWORD *)(a1 + 0x10) = 0xFFFFFFFFFFFFFFFFui64;
    if ( !*(_QWORD *)(a1 + 0x28)
      || (result = (*(__int64 (__fastcall **)(_QWORD))(a1 + 0x28))(*(_QWORD *)(a1 + 0x20)), (_BYTE)result) )
    {
      result = *(unsigned int *)(a1 + 0x30);
      for ( i = 0; i < (unsigned int)result; result = *(unsigned int *)(a1 + 0x30) )
      {
        (*(void (__fastcall **)(__int64, _QWORD))(a1 + 0x18))(a1 + 8, *(_QWORD *)(a1 + 0x20));
        if ( (unsigned __int64)*(int *)(a1 + 0xC) < *(_QWORD *)(a1 + 0x10) )
          *(_QWORD *)(a1 + 0x10) = *(int *)(a1 + 0xC);
        ++i;
        _InterlockedExchange((volatile __int32 *)(a1 + 0xC), 0);
      }
    }
    _InterlockedExchange((volatile __int32 *)(a1 + 4), 1);
  }
  else
  {
    result = *(unsigned int *)(a1 + 4);
    if ( v2 == 2 )
    {
      while ( !(_DWORD)result )
      {
        if ( *(_BYTE *)(a1 + 8) )
          ++*(_DWORD *)(a1 + 0xC);
        result = *(unsigned int *)(a1 + 4);
      }
    }
    else
    {
      while ( !(_DWORD)result )
      {
        __asm { rep nop }
        result = *(unsigned int *)(a1 + 4);
      }
    }
  }
  return result;
}

//----- (000000014002A548) ----------------------------------------------------
char __fastcall sub_14002A548(unsigned __int16 *a1, __int64 a2)
{
  char v4; // di
  __int64 v5; // rcx
  unsigned __int16 v6; // ax
  void *v7; // rax
  __int64 v8; // rbx

  v4 = 0;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v5 = *a1;
  if ( (unsigned __int16)(v5 - 1) > 0x1FFu )
    return 0;
  v6 = a1[1];
  if ( !v6 || v6 < (unsigned __int16)v5 )
    return 0;
  v7 = (void *)sub_140051084(v5 + 2);
  v8 = (__int64)v7;
  if ( v7 )
  {
    memset(v7, 0, *a1 + 2i64);
    ProbeForRead((volatile void *)*((unsigned int *)a1 + 1), *a1, 1u);
    ((void (__fastcall *)(__int64, _QWORD, _QWORD))loc_14006F000)(v8, *((unsigned int *)a1 + 1), *a1);
    v4 = sub_1400070E0(a2, v8);
    sub_140051220(v8);
  }
  return v4;
}

//----- (000000014002A624) ----------------------------------------------------
char __fastcall sub_14002A624(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  char v6; // bl
  unsigned int *v7; // rdi
  __int64 v8; // rdi
  unsigned __int16 *v9; // rdi
  unsigned int i; // er14
  __int64 v11; // rcx
  unsigned int v12; // eax
  char v14[56]; // [rsp+28h] [rbp-50h] BYREF

  v6 = 0;
  v7 = (unsigned int *)sub_140014298(a1);
  if ( !v7 || a2 > 0xFFFFFFFF )
    return 0;
  if ( sub_140015378(a1, (__int64)v14) )
  {
    ProbeForRead(v7, 0x3Cui64, 1u);
    v8 = v7[3];
    if ( v8 )
    {
      ProbeForRead((volatile void *)(unsigned int)v8, 0x24ui64, 1u);
      v9 = (unsigned __int16 *)*(unsigned int *)(v8 + 0xC);
      for ( i = 0; v9; ++i )
      {
        if ( i >= 0x200 )
          break;
        ProbeForRead(v9, 0x44ui64, 1u);
        v11 = *((unsigned int *)v9 + 6);
        if ( !(_DWORD)v11 )
          break;
        v12 = *((_DWORD *)v9 + 8);
        if ( !v12 )
          break;
        if ( (unsigned int)v11 <= (unsigned int)a2 && (unsigned int)a2 < (unsigned int)v11 + v12 )
        {
          *(_QWORD *)a3 = v11;
          *(_DWORD *)(a3 + 8) = *((_DWORD *)v9 + 8);
          *(_DWORD *)(a3 + 0xC) = *((_DWORD *)v9 + 0x10);
          if ( sub_14002A548(v9 + 0x12, a3 + 0x10) )
            v6 = 1;
          break;
        }
        v9 = (unsigned __int16 *)*(unsigned int *)v9;
      }
    }
    ((void (__fastcall *)(__int64, char *))loc_140015528)(a1, v14);
  }
  return v6;
}

//----- (000000014002A768) ----------------------------------------------------
char __fastcall sub_14002A768(__int64 a1, unsigned __int64 a2, __int64 a3)
{
  char v6; // bl
  __int64 v7; // rax
  _QWORD *v8; // rdi
  _QWORD *v9; // rdi
  _QWORD *v10; // rdi
  unsigned int i; // esi
  unsigned __int64 v12; // rcx
  __int64 v13; // rax
  char v15[96]; // [rsp+28h] [rbp-60h] BYREF

  v6 = 0;
  v7 = sub_140014260(a1);
  v8 = (_QWORD *)v7;
  if ( v7 )
  {
    if ( sub_140015378(a1, (__int64)v15) )
    {
      ProbeForRead(v8, 0x2C8ui64, 1u);
      v9 = (_QWORD *)v8[3];
      if ( v9 )
      {
        ProbeForRead(v9, 0x40ui64, 1u);
        v10 = (_QWORD *)v9[2];
        for ( i = 0; v10; ++i )
        {
          if ( i >= 0x200 )
            break;
          ProbeForRead(v10, 0x88ui64, 1u);
          v12 = v10[6];
          if ( !v12 )
            break;
          v13 = *((unsigned int *)v10 + 0x10);
          if ( !(_DWORD)v13 )
            break;
          if ( v12 <= a2 && a2 < v12 + v13 )
          {
            *(_QWORD *)a3 = v12;
            *(_DWORD *)(a3 + 8) = *((_DWORD *)v10 + 0x10);
            *(_DWORD *)(a3 + 0xC) = *((_DWORD *)v10 + 0x20);
            ProbeForRead((volatile void *)v10[0xA], *((unsigned __int16 *)v10 + 0x24), 1u);
            v6 = sub_14000721C(a3 + 0x10, (__int64)(v10 + 9));
            break;
          }
          v10 = (_QWORD *)*v10;
        }
      }
      ((void (__fastcall *)(__int64, char *))loc_140015528)(a1, v15);
    }
    LOBYTE(v7) = v6;
  }
  return v7;
}

//----- (000000014002A8C8) ----------------------------------------------------
char __fastcall sub_14002A8C8(__int64 a1, unsigned __int64 a2, void *a3)
{
  int v6; // eax

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !a3 )
    return 0;
  if ( a2 > (unsigned __int64)MmHighestUserAddress )
    return 0;
  memset(a3, 0, 0x20ui64);
  v6 = sub_140013EF0(a1);
  if ( !v6 )
    return 0;
  if ( v6 == 0x20 )
    return sub_14002A624(a1, a2, (__int64)a3);
  return sub_14002A768(a1, a2, (__int64)a3);
}

//----- (000000014002A94C) ----------------------------------------------------
void __fastcall sub_14002A94C(__int64 a1)
{
  if ( a1 )
    sub_14000724C(a1 + 0x10);
}

//----- (000000014002A964) ----------------------------------------------------
unsigned __int64 sub_14002A964()
{
  return __readmsr(0x1Bu);
}

//----- (000000014002AAC8) ----------------------------------------------------
__int64 __fastcall sub_14002AAC8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // rax
  __int64 v9; // r8
  unsigned int v10; // eax
  int v11; // er11
  __int64 result; // rax
  unsigned int v13; // [rsp+20h] [rbp-20h] BYREF
  int v14; // [rsp+24h] [rbp-1Ch]
  int v15; // [rsp+28h] [rbp-18h]
  int v16; // [rsp+2Ch] [rbp-14h]
  int v17; // [rsp+30h] [rbp-10h]

  dword_1400DA9C8 = sub_14000A930(a1, a2, a3, a4, v13);
  v13 = 0x7F4ACBEC;
  v14 = 0xF85125D4;
  v15 = 0x83534846;
  v16 = 0x51D08CD2;
  v17 = 0x68B597BB;
  v4 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v13);
  LOBYTE(v5) = 1;
  qword_1400DA9D0 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v4, &qword_1400DA9D0, v5);
  v13 = 0xF25428D7;
  v14 = 0xF54169C3;
  v15 = 0x78F43419;
  v16 = 0x896FF96A;
  v17 = 0x4F60BFC4;
  v6 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v13);
  LOBYTE(v7) = 1;
  qword_1400DA9D8 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v6, &qword_1400DA9D8, v7);
  v13 = 0xBDFEDDE1;
  v14 = 0xD8493189;
  v15 = 0x4A9DFFF1;
  v16 = 0x69F5D43A;
  v17 = 0x3EFFF626;
  v8 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v13);
  LOBYTE(v9) = 1;
  qword_1400DA9E0 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v8, &qword_1400DA9E0, v9);
  v10 = sub_140025404(&dword_1400DA9C8, 0x20u);
  result = 0x29AA10B2 * (v11 ^ v10);
  dword_1400DA9E8 = result;
  return result;
}
// 14002AB15: variable 'v5' is possibly undefined
// 14002AB5A: variable 'v7' is possibly undefined
// 14002AB9F: variable 'v9' is possibly undefined
// 14002ABBF: variable 'v11' is possibly undefined
// 1400DA9C8: using guessed type int dword_1400DA9C8;
// 1400DA9D0: using guessed type __int64 qword_1400DA9D0;
// 1400DA9D8: using guessed type __int64 qword_1400DA9D8;
// 1400DA9E0: using guessed type __int64 qword_1400DA9E0;
// 1400DA9E8: using guessed type int dword_1400DA9E8;

//----- (000000014002AC18) ----------------------------------------------------
__int64 __fastcall sub_14002AC18(__int64 a1, unsigned int a2, __int64 a3)
{
  __int64 (__fastcall *v6)(__int64, _QWORD, __int64); // rax
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(__int64, _QWORD, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                           qword_1400DA9D0,
                                                           &qword_1400DA9D0,
                                                           0i64);
  if ( v6 )
    result = v6(a1, a2, a3);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DA9D0: using guessed type __int64 qword_1400DA9D0;

//----- (000000014002AF9C) ----------------------------------------------------
unsigned __int64 __fastcall sub_14002AF9C(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, char a4)
{
  unsigned __int64 result; // rax
  unsigned __int64 v7; // rbp
  unsigned __int64 v8; // rdi
  unsigned __int64 v9; // r15
  __int64 v10; // r14
  __int64 v11; // r9
  __int64 v12; // rsi
  unsigned __int64 v13; // rbp
  unsigned __int64 v14; // [rsp+30h] [rbp-48h] BYREF
  __int64 v15; // [rsp+38h] [rbp-40h]

  result = a2 - a1;
  v7 = a2;
  v8 = a1;
  if ( (__int64)(a2 - a1) < 0x318 )
  {
LABEL_7:
    if ( v8 != v7 && v8 + 0x18 != v7 )
      JUMPOUT(0x14002B089i64);
  }
  else
  {
    while ( a3 > 0 )
    {
      sub_14002B21C(&v14, v8, v7);
      v9 = v14;
      v10 = v15;
      LOBYTE(v11) = a4;
      a3 = (a3 >> 2) + (a3 >> 1);
      if ( (__int64)(0xAAAAAAAAAAAAAAABui64 * ((__int64)(v14 - v8) >> 3)) >= (__int64)(0xAAAAAAAAAAAAAAABui64
                                                                                     * ((__int64)(v7 - v15) >> 3)) )
      {
        sub_14002AF9C(v15, v7, a3, v11);
        v7 = v9;
      }
      else
      {
        sub_14002AF9C(v8, v14, a3, v11);
        v8 = v10;
      }
      result = v7 - v8;
      if ( (__int64)(v7 - v8) < 0x318 )
        goto LABEL_7;
    }
    v12 = v7 - v8;
    if ( (__int64)(0xAAAAAAAAAAAAAAABui64 * ((__int64)(v7 - v8) >> 3)) >> 1 > 0 )
      JUMPOUT(0x14002B110i64);
    if ( (__int64)(0xAAAAAAAAAAAAAAABui64 * ((__int64)(v7 - v8) >> 3)) >= 2 )
    {
      v13 = v7 - 0x18;
      do
      {
        if ( (__int64)(0xAAAAAAAAAAAAAAABui64 * (v12 >> 3)) >= 2 )
          JUMPOUT(0x14002B161i64);
        v12 = v13 - v8;
        v13 -= 0x18i64;
      }
      while ( v12 >= 0x30 );
    }
  }
  return result;
}
// 14002B086: control flows out of bounds to 14002B089
// 14002B10C: control flows out of bounds to 14002B110
// 14002B15F: control flows out of bounds to 14002B161
// 14002B043: variable 'v11' is possibly undefined

//----- (000000014002B21C) ----------------------------------------------------
unsigned __int64 *__fastcall sub_14002B21C(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v6; // rdi
  unsigned __int64 v7; // rbx
  signed __int64 v8; // rax
  unsigned __int64 v9; // rcx
  __int64 v10; // r9
  __int64 v11; // r9
  __int64 v12; // r10
  unsigned __int64 v13; // rdx
  unsigned __int64 v14; // r8
  unsigned __int64 v15; // r11
  unsigned __int64 v16; // rax
  unsigned __int64 v17; // rcx
  unsigned __int64 v18; // rdx
  unsigned __int64 v19; // rcx
  unsigned __int64 v20; // rdx
  unsigned __int64 v21; // r8
  bool v22; // zf
  unsigned __int64 v23; // r8
  unsigned __int64 v24; // r9
  unsigned __int64 v25; // rdx

  v4 = a3 - 0x18;
  v6 = a2;
  v7 = a2 + 0x18 * ((__int64)(0xAAAAAAAAAAAAAAABui64 * ((__int64)(a3 - a2) >> 3)) >> 1);
  v8 = 0xAAAAAAAAAAAAAAABui64 * ((__int64)(a3 - 0x18 - a2) >> 3);
  v9 = a2;
  if ( v8 <= 0x28 )
  {
    v14 = a3 - 0x18;
  }
  else
  {
    ((void (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64))loc_14002B5B0)(
      a2,
      0x18 * ((v8 + 1) >> 3) + a2,
      0x30 * ((v8 + 1) >> 3) + a2);
    ((void (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64))loc_14002B5B0)(v7 - v10, v7, v10 + v7);
    ((void (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64))loc_14002B5B0)(v4 - v12, v4 - v11, v4);
    v14 = v13;
    v9 = v15;
  }
  ((void (__fastcall *)(unsigned __int64, unsigned __int64, unsigned __int64))loc_14002B5B0)(v9, v7, v14);
  v16 = v7 + 0x18;
  while ( v6 < v7 )
  {
    v17 = *(_QWORD *)(v7 - 0x10);
    if ( v17 > *(_QWORD *)(v7 + 8) || v17 < *(_QWORD *)(v7 + 8) )
      break;
    v7 -= 0x18i64;
  }
  if ( v16 < a3 )
  {
    v18 = *(_QWORD *)(v7 + 8);
    do
    {
      if ( *(_QWORD *)(v16 + 8) > v18 )
        break;
      if ( *(_QWORD *)(v16 + 8) < v18 )
        break;
      v16 += 0x18i64;
    }
    while ( v16 < a3 );
  }
  v19 = v16;
  v20 = v7;
  while ( v19 < a3 )
  {
    v21 = *(_QWORD *)(v7 + 8);
    if ( v21 <= *(_QWORD *)(v19 + 8) )
    {
      if ( v21 < *(_QWORD *)(v19 + 8) )
        break;
      if ( v16 != v19 )
        JUMPOUT(0x14002B332i64);
      v16 += 0x18i64;
    }
    v19 += 0x18i64;
  }
  v22 = v7 == v6;
  if ( v7 > v6 )
  {
    v23 = v7 - 0x18;
    do
    {
      v24 = *(_QWORD *)(v23 + 8);
      if ( v24 <= *(_QWORD *)(v7 + 8) )
      {
        if ( v24 < *(_QWORD *)(v7 + 8) )
          break;
        v7 -= 0x18i64;
        if ( v7 != v23 )
          JUMPOUT(0x14002B37Ai64);
      }
      v20 -= 0x18i64;
      v23 -= 0x18i64;
    }
    while ( v6 < v20 );
    v22 = v20 == v6;
  }
  if ( !v22 )
  {
    v25 = v20 - 0x18;
    if ( v19 == a3 )
    {
      if ( v25 != v7 - 0x18 )
        JUMPOUT(0x14002B418i64);
      JUMPOUT(0x14002B438i64);
    }
    JUMPOUT(0x14002B460i64);
  }
  if ( v19 != a3 )
  {
    if ( v16 != v19 )
      JUMPOUT(0x14002B3BCi64);
    JUMPOUT(0x14002B3DCi64);
  }
  *a1 = v7;
  a1[1] = v16;
  return a1;
}
// 14002B330: control flows out of bounds to 14002B332
// 14002B378: control flows out of bounds to 14002B37A
// 14002B3BA: control flows out of bounds to 14002B3BC
// 14002B416: control flows out of bounds to 14002B418
// 14002B3BA: control flows out of bounds to 14002B3DC
// 14002B40E: control flows out of bounds to 14002B460
// 14002B416: control flows out of bounds to 14002B438
// 14002B2AE: variable 'v10' is possibly undefined
// 14002B2C2: variable 'v12' is possibly undefined
// 14002B2BF: variable 'v11' is possibly undefined
// 14002B2CD: variable 'v13' is possibly undefined
// 14002B2D0: variable 'v15' is possibly undefined

//----- (000000014002B4AC) ----------------------------------------------------
void __fastcall sub_14002B4AC(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rbx

  v3 = (a3 - 1) >> 1;
  if ( a2 >= v3 )
  {
    if ( a2 == v3 && (a3 & 1) == 0 )
      JUMPOUT(0x14002B521i64);
    JUMPOUT(0x14002B581i64);
  }
  JUMPOUT(0x14002B4F5i64);
}
// 14002B4F1: control flows out of bounds to 14002B4F5
// 14002B51D: control flows out of bounds to 14002B521
// 14002B561: control flows out of bounds to 14002B564
// 14002B545: control flows out of bounds to 14002B581

//----- (000000014002BACC) ----------------------------------------------------
char __fastcall sub_14002BACC(unsigned int a1)
{
  unsigned int v1; // ecx
  unsigned int v2; // ecx
  unsigned int v3; // ecx
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // ecx
  unsigned int v7; // ecx
  unsigned int v8; // ecx
  bool v9; // zf
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // ecx
  unsigned int v15; // ecx
  unsigned int v16; // ecx

  if ( a1 > 0xB3 )
  {
    v10 = a1 - 0xC2;
    if ( !v10 )
      return 1;
    v11 = v10 - 0x15;
    if ( !v11 )
      return 1;
    v12 = v11 - 0x16;
    if ( !v12 )
      return 1;
    v13 = v12 - 0xF9;
    if ( !v13 )
      return 1;
    v14 = v13 - 0x2D;
    if ( !v14 )
      return 1;
    v15 = v14 - 0x32;
    if ( !v15 )
      return 1;
    v16 = v15 - 0x1B;
    if ( !v16 )
      return 1;
    v9 = v16 == 2;
  }
  else
  {
    if ( a1 == 0xB3 )
      return 1;
    v1 = a1 - 1;
    if ( !v1 )
      return 1;
    v2 = v1 - 1;
    if ( !v2 )
      return 1;
    v3 = v2 - 2;
    if ( !v3 )
      return 1;
    v4 = v3 - 1;
    if ( !v4 )
      return 1;
    v5 = v4 - 0x1F;
    if ( !v5 )
      return 1;
    v6 = v5 - 1;
    if ( !v6 )
      return 1;
    v7 = v6 - 0x4B;
    if ( !v7 )
      return 1;
    v8 = v7 - 0x1C;
    if ( !v8 )
      return 1;
    v9 = v8 == 0x15;
  }
  return v9;
}

//----- (000000014002C0B8) ----------------------------------------------------
__int64 __fastcall sub_14002C0B8(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v6; // rax
  __int64 v7; // r8
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // rax
  __int64 v11; // r8
  __int64 v12; // rax
  __int64 v13; // r8
  __int64 v14; // rax
  __int64 v15; // r8
  __int64 v16; // rax
  __int64 v17; // r8
  int v18; // eax
  int v19; // er11
  __int64 result; // rax
  unsigned int v21; // [rsp+20h] [rbp-20h] BYREF
  int v22; // [rsp+24h] [rbp-1Ch]
  int v23; // [rsp+28h] [rbp-18h]
  int v24; // [rsp+2Ch] [rbp-14h]
  int v25; // [rsp+30h] [rbp-10h]

  dword_1400DAB40 = sub_14000A930(a1, a2, a3, a4, v21);
  v21 = 0x4A82885F;
  v22 = 0x9A68A3BD;
  v23 = 0x7346FA7;
  v24 = 0x60968137;
  v25 = 0xF769423F;
  v4 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v21);
  LOBYTE(v5) = 1;
  qword_1400DAB48 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v4, &qword_1400DAB48, v5);
  v21 = 0x15E8E55B;
  v22 = 0x1972D1E5;
  v23 = 0x9FD9DF29;
  v24 = 0xD2448AC4;
  v25 = 0x40C40D55;
  v6 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v21);
  LOBYTE(v7) = 1;
  qword_1400DAB50 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v6, &qword_1400DAB50, v7);
  v21 = 0x39A7F8AC;
  v22 = 0xC26E8638;
  v23 = 0x9931A9D8;
  v24 = 0xE956E9DC;
  v25 = 0xFAA9DD89;
  v8 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v21);
  LOBYTE(v9) = 1;
  qword_1400DAB58 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v8, &qword_1400DAB58, v9);
  v21 = 0x94F4FE58;
  v22 = 0xE8E06D9C;
  v23 = 0x930713A;
  v24 = 0x48F67F89;
  v25 = 0x913ECEAA;
  v10 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v21);
  LOBYTE(v11) = 1;
  qword_1400DAB60 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v10, &qword_1400DAB60, v11);
  v21 = 0x6201362E;
  v22 = 0x34CA9DA6;
  v23 = 0x2C13CF70;
  v24 = 0x90515BF9;
  v25 = 0xE39D0DB7;
  v12 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v21);
  LOBYTE(v13) = 1;
  qword_1400DAB68 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v12, &qword_1400DAB68, v13);
  v21 = 0xD11172F3;
  v22 = 0xDA7313D4;
  v23 = 0x5D20B4C3;
  v24 = 0x5F69F88D;
  v25 = 0xE4942398;
  v14 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v21);
  LOBYTE(v15) = 1;
  qword_1400DAB70 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v14, &qword_1400DAB70, v15);
  v21 = 0xF1B01EE8;
  v22 = 0x42B2674A;
  v23 = 0x37072904;
  v24 = 0x7F878D75;
  v25 = 0x51B35D42;
  v16 = ((__int64 (__fastcall *)(unsigned int *))loc_1400061CC)(&v21);
  LOBYTE(v17) = 1;
  qword_1400DAB78 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v16, &qword_1400DAB78, v17);
  v18 = sub_140025404(&dword_1400DAB40, 0x40u);
  result = 0x83C6EE0F * (v19 ^ v18);
  dword_1400DAB80 = result;
  return result;
}
// 14002C105: variable 'v5' is possibly undefined
// 14002C14A: variable 'v7' is possibly undefined
// 14002C18F: variable 'v9' is possibly undefined
// 14002C1D4: variable 'v11' is possibly undefined
// 14002C219: variable 'v13' is possibly undefined
// 14002C25E: variable 'v15' is possibly undefined
// 14002C2A3: variable 'v17' is possibly undefined
// 14002C2C3: variable 'v19' is possibly undefined
// 1400DAB40: using guessed type int dword_1400DAB40;
// 1400DAB48: using guessed type __int64 qword_1400DAB48;
// 1400DAB50: using guessed type __int64 qword_1400DAB50;
// 1400DAB58: using guessed type __int64 qword_1400DAB58;
// 1400DAB60: using guessed type __int64 qword_1400DAB60;
// 1400DAB68: using guessed type __int64 qword_1400DAB68;
// 1400DAB70: using guessed type __int64 qword_1400DAB70;
// 1400DAB78: using guessed type __int64 qword_1400DAB78;
// 1400DAB80: using guessed type int dword_1400DAB80;

//----- (000000014002C31C) ----------------------------------------------------
__int64 __fastcall sub_14002C31C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  __int64 (__fastcall *v8)(__int64, __int64, _QWORD, __int64); // rax
  __int64 result; // rax

  v8 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                    qword_1400DAB58,
                                                                    &qword_1400DAB58,
                                                                    0i64);
  if ( v8 )
    result = v8(a1, a2, a3, a4);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DAB58: using guessed type __int64 qword_1400DAB58;

//----- (000000014002C384) ----------------------------------------------------
__int64 __fastcall sub_14002C384(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (__fastcall *v7)(__int64, __int64, __int64, __int64); // rax
  __int64 result; // rax

  v7 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DAB68,
                                                                     &qword_1400DAB68,
                                                                     0i64);
  if ( v7 )
    result = v7(a1, 1i64, a3, a4);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DAB68: using guessed type __int64 qword_1400DAB68;

//----- (000000014002C3E0) ----------------------------------------------------
__int64 __fastcall sub_14002C3E0(volatile signed __int64 *a1)
{
  if ( *a1 != 2 )
  {
    if ( !_InterlockedCompareExchange64(a1, 1i64, 0i64) )
      return 0x103i64;
    while ( *a1 != 2 )
      __asm { rep nop }
  }
  return 0i64;
}

//----- (000000014002C40C) ----------------------------------------------------
char __fastcall sub_14002C40C(volatile void *a1, __int64 a2)
{
  ProbeForRead(a1, 0x1000ui64, 1u);
  ((void (__fastcall *)(__int64, volatile void *, __int64))loc_14006F000)(a2, a1, 0x1000i64);
  return 1;
}

//----- (000000014002CB08) ----------------------------------------------------
void sub_14002CB08()
{
  if ( _InterlockedCompareExchange(&dword_1400DABC8, 0, 0) )
  {
    ExAcquireFastMutex(&stru_1400DAB88);
    sub_14001FBDC(P);
    ExReleaseFastMutex(&stru_1400DAB88);
  }
}
// 1400DABC8: using guessed type int dword_1400DABC8;

//----- (000000014002D2D8) ----------------------------------------------------
__int64 __fastcall sub_14002D2D8(__int64 a1, unsigned int a2)
{
  __int64 v4; // rax
  __int64 result; // rax

  v4 = ((__int64 (__fastcall *)(__int64, __int64 (__fastcall *)(), _QWORD))loc_1400404E8)(a1, sub_14002D2D8, 0i64);
  if ( a1 && v4 && a2 && !KeGetCurrentIrql() && a2 >= 0x1464 )
    result = ((__int64 (__fastcall *)(__int64))loc_14002CCB0)(v4);
  else
    result = 0i64;
  return result;
}

//----- (000000014002D658) ----------------------------------------------------
#error "14002D6A1: call analysis failed (funcsize=65)"

//----- (000000014002D72C) ----------------------------------------------------
__int64 __fastcall sub_14002D72C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, unsigned int a5)
{
  __int64 v5; // rbx
  __int64 v6; // rax

  v5 = 0i64;
  a5 = 0;
  if ( (unsigned int)sub_140061B64(0xBu, (__int64)&a5, 0, (__int64)&a5) == 0xC0000004 )
  {
    if ( a5 )
    {
      v6 = sub_140051084(a5);
      v5 = v6;
      if ( v6 )
      {
        if ( (int)sub_140061B64(0xBu, v6, a5, 0i64) < 0 )
        {
          sub_140051220(v5);
          v5 = 0i64;
        }
      }
    }
  }
  return v5;
}

//----- (000000014002D880) ----------------------------------------------------
__int64 __fastcall sub_14002D880(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, char a4)
{
  __int64 result; // rax
  unsigned __int64 v7; // rbp
  unsigned __int64 v8; // rsi
  unsigned __int64 v9; // r15
  __int64 v10; // r14
  __int64 v11; // r9
  __int64 v12; // rdi
  __int64 v13; // r15
  unsigned __int64 v14; // rbp
  unsigned __int64 v15; // [rsp+30h] [rbp-168h] BYREF
  __int64 v16; // [rsp+38h] [rbp-160h]

  result = a2 - a1;
  v7 = a2;
  v8 = a1;
  if ( (__int64)(a2 - a1) < 0x2628 )
    return sub_14002DBA4(v8, v7);
  while ( a3 > 0 )
  {
    sub_14002DDFC(&v15, v8, v7);
    v9 = v15;
    v10 = v16;
    LOBYTE(v11) = a4;
    a3 = (a3 >> 2) + (a3 >> 1);
    if ( 0x14C1BACF914C1BADi64 * ((__int64)(v15 - v8) >> 3) >= 0x14C1BACF914C1BADi64 * ((__int64)(v7 - v16) >> 3) )
    {
      sub_14002D880(v16, v7, a3, v11);
      v7 = v9;
    }
    else
    {
      sub_14002D880(v8, v15, a3, v11);
      v8 = v10;
    }
    result = v7 - v8;
    if ( (__int64)(v7 - v8) < 0x2628 )
      return sub_14002DBA4(v8, v7);
  }
  v12 = v7 - v8;
  v13 = 0x14C1BACF914C1BADi64 * ((__int64)(v7 - v8) >> 3);
  if ( v13 >> 1 > 0 )
    JUMPOUT(0x14002D9C9i64);
  if ( v13 >= 2 )
  {
    v14 = v7 - 0x128;
    do
    {
      if ( 0x14C1BACF914C1BADi64 * (v12 >> 3) >= 2 )
        JUMPOUT(0x14002DA85i64);
      v12 = v14 - v8;
      v14 -= 0x128i64;
    }
    while ( v12 >= 0x250 );
  }
  return result;
}
// 14002D9C6: control flows out of bounds to 14002D9C9
// 14002DA82: control flows out of bounds to 14002DA85
// 14002D92A: variable 'v11' is possibly undefined

//----- (000000014002DBA4) ----------------------------------------------------
__int64 __fastcall sub_14002DBA4(__int64 a1, __int64 a2)
{
  if ( a1 != a2 && a1 + 0x128 != a2 )
    JUMPOUT(0x14002DC07i64);
  return a2;
}
// 14002DC04: control flows out of bounds to 14002DC07

//----- (000000014002DDFC) ----------------------------------------------------
unsigned __int64 *__fastcall sub_14002DDFC(unsigned __int64 *a1, unsigned __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 *v3; // rdi
  __int64 v4; // r12
  unsigned __int64 v5; // rbx
  unsigned __int64 v7; // r15
  __int64 v8; // rax
  __int64 v9; // rax
  __int64 v10; // rdi
  __int64 v11; // rsi
  __int64 v12; // r14
  unsigned __int64 v13; // rcx
  unsigned __int64 v14; // rax
  unsigned __int64 v15; // rdx
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // r9
  unsigned __int64 v18; // rax
  bool v19; // zf
  unsigned __int64 v20; // r10
  unsigned __int64 v21; // rax
  unsigned __int64 v22; // r9
  unsigned __int64 *result; // rax
  unsigned __int64 *v24; // [rsp+8B8h] [rbp+7B0h]
  unsigned __int64 v25; // [rsp+8C8h] [rbp+7C0h]

  v25 = a3;
  v24 = a1;
  v3 = a1;
  v4 = a3 - 0x128;
  v5 = a3;
  v7 = a2 + 0x128 * ((0x14C1BACF914C1BADi64 * ((__int64)(a3 - a2) >> 3)) >> 1);
  v8 = 0x14C1BACF914C1BADi64 * ((__int64)(a3 - 0x128 - a2) >> 3);
  if ( v8 <= 0x28 )
  {
    sub_14002EB78(a2, v7, a3 - 0x128);
  }
  else
  {
    v9 = (v8 + 1) >> 3;
    v10 = 0x128 * v9;
    v11 = 0x250 * v9;
    v12 = 0x128 * v9 + a2;
    sub_14002EB78(a2, v12, 0x250 * v9 + a2);
    sub_14002EB78(v7 - v10, v7, v10 + v7);
    sub_14002EB78(v4 - v11, v4 - v10, v4);
    sub_14002EB78(v12, v7, v4 - v10);
    v5 = v25;
    v3 = v24;
  }
  v13 = v7 + 0x128;
  while ( a2 < v7 )
  {
    v14 = *(_QWORD *)(v7 - 0x118);
    if ( v14 < *(_QWORD *)(v7 + 0x10) || v14 > *(_QWORD *)(v7 + 0x10) )
      break;
    v7 -= 0x128i64;
  }
  if ( v13 < v5 )
  {
    v15 = *(_QWORD *)(v7 + 0x10);
    do
    {
      if ( *(_QWORD *)(v13 + 0x10) < v15 )
        break;
      if ( *(_QWORD *)(v13 + 0x10) > v15 )
        break;
      v13 += 0x128i64;
    }
    while ( v13 < v5 );
  }
  v16 = v13;
  v17 = v7;
  while ( v16 < v5 )
  {
    v18 = *(_QWORD *)(v7 + 0x10);
    if ( v18 >= *(_QWORD *)(v16 + 0x10) )
    {
      if ( v18 > *(_QWORD *)(v16 + 0x10) )
        break;
      if ( v13 != v16 )
        JUMPOUT(0x14002DF69i64);
      v13 += 0x128i64;
    }
    v16 += 0x128i64;
  }
  v19 = v7 == a2;
  if ( v7 > a2 )
  {
    v20 = v7 - 0x128;
    do
    {
      v21 = *(_QWORD *)(v20 + 0x10);
      if ( v21 >= *(_QWORD *)(v7 + 0x10) )
      {
        if ( v21 > *(_QWORD *)(v7 + 0x10) )
          break;
        v7 -= 0x128i64;
        if ( v7 != v20 )
          JUMPOUT(0x14002E0E3i64);
      }
      v17 -= 0x128i64;
      v20 -= 0x128i64;
    }
    while ( a2 < v17 );
    v19 = v17 == a2;
  }
  if ( !v19 )
  {
    v22 = v17 - 0x128;
    if ( v16 == v5 )
    {
      if ( v22 != v7 - 0x128 )
        JUMPOUT(0x14002E4E4i64);
      JUMPOUT(0x14002E62Ai64);
    }
    JUMPOUT(0x14002E772i64);
  }
  if ( v16 != v5 )
  {
    if ( v13 != v16 )
      JUMPOUT(0x14002E24Di64);
    JUMPOUT(0x14002E393i64);
  }
  result = v3;
  *v3 = v7;
  v3[1] = v13;
  return result;
}
// 14002DF66: control flows out of bounds to 14002DF69
// 14002E0E0: control flows out of bounds to 14002E0E3
// 14002E24A: control flows out of bounds to 14002E24D
// 14002E390: control flows out of bounds to 14002E393
// 14002E4E1: control flows out of bounds to 14002E4E4
// 14002E627: control flows out of bounds to 14002E62A
// 14002E76F: control flows out of bounds to 14002E772

//----- (000000014002E8D4) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_14002E8D4(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rdi

  v3 = (a3 - 1) >> 1;
  if ( a2 < v3 )
    JUMPOUT(0x14002E94Ci64);
  if ( a2 == v3 && (a3 & 1) == 0 )
    JUMPOUT(0x14002E9E8i64);
  JUMPOUT(0x14002EAF3i64);
}
// 14002EB75: positive sp value 8 has been found
// 14002E949: control flows out of bounds to 14002E94C
// 14002E9E5: control flows out of bounds to 14002E9E8
// 14002EA7A: control flows out of bounds to 14002EA7D
// 14002EAF0: control flows out of bounds to 14002EAF3

//----- (000000014002EB78) ----------------------------------------------------
unsigned __int64 __fastcall sub_14002EB78(__int64 a1, __int64 a2, __int64 a3)
{
  unsigned __int64 result; // rax

  result = *(_QWORD *)(a2 + 0x10);
  if ( result < *(_QWORD *)(a1 + 0x10) )
    JUMPOUT(0x14002EBA2i64);
  if ( *(_QWORD *)(a3 + 0x10) < result )
    JUMPOUT(0x14002ED0Bi64);
  return result;
}
// 14002EB9F: control flows out of bounds to 14002EBA2
// 14002ED08: control flows out of bounds to 14002ED0B

//----- (000000014002F228) ----------------------------------------------------
void sub_14002F228()
{
  JUMPOUT(0x14002F23Ai64);
}
// 14002F236: control flows out of bounds to 14002F23A

//----- (000000014002F378) ----------------------------------------------------
__int64 sub_14002F378()
{
  if ( KeGetCurrentIrql() <= 1u )
  {
    ExAcquireFastMutex(&stru_1400DAC10);
    JUMPOUT(0x14002F3BCi64);
  }
  return 0i64;
}
// 14002F3B8: control flows out of bounds to 14002F3BC

//----- (000000014002F3D8) ----------------------------------------------------
#error "14002F4C5: call analysis failed (funcsize=70)"

//----- (000000014002F51C) ----------------------------------------------------
__int64 __fastcall sub_14002F51C(ULONG64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 result; // rax
  ULONG64 v9; // rbx

  result = sub_140052944(a1);
  v9 = result;
  if ( result )
  {
    a8 = result;
    a7 = 0x17i64;
    result = sub_140061928(0xFFFFFFFFFFFFFFFFui64, (__int64)&a8, (__int64)&a7, 0x40u);
    if ( (int)result >= 0 )
    {
      sub_14005221C(v9, 0x17i64, 1);
      JUMPOUT(0x14002F582i64);
    }
  }
  return result;
}
// 14002F57D: control flows out of bounds to 14002F582

//----- (000000014002F5F8) ----------------------------------------------------
void sub_14002F5F8()
{
  __int64 v0; // rax

  v0 = sub_140048808();
  sub_14004888C(v0);
  JUMPOUT(0x14002F638i64);
}
// 14002F634: control flows out of bounds to 14002F638

//----- (000000014002F770) ----------------------------------------------------
#error "14002F7CD: call analysis failed (funcsize=38)"

//----- (000000014002F828) ----------------------------------------------------
__int64 __fastcall sub_14002F828(__int64 a1, unsigned int a2, void *a3, _DWORD *a4, __int64 a5, __int64 a6, PVOID a7, _DWORD *a8)
{
  __int64 result; // rax
  unsigned int *v12; // r14
  void *v13; // rcx
  PVOID v14; // [rsp+38h] [rbp-90h] BYREF
  PVOID Object[5]; // [rsp+40h] [rbp-88h] BYREF
  char v16[96]; // [rsp+68h] [rbp-60h] BYREF
  void *retaddr; // [rsp+C8h] [rbp+0h] BYREF
  unsigned int v18; // [rsp+D8h] [rbp+10h]

  result = (__int64)&retaddr;
  a8 = a4;
  a7 = a3;
  v18 = a2;
  Object[4] = (PVOID)4;
  Object[0] = 0i64;
  v14 = 0i64;
  if ( a4 )
  {
    result = ((__int64 (__fastcall *)(_DWORD *, _QWORD, __int64))loc_14006F2C0)(a4 + 2, 0i64, 0xA98i64);
    *a4 = 1;
    a4[1] = 6;
    if ( a1 && *(_QWORD *)(a1 + 8) && *(_WORD *)a1 && *(_WORD *)(a1 + 2) && a2 )
    {
      result = MEMORY[0xFFFFF7800000026C];
      if ( MEMORY[0xFFFFF7800000026C] < 6u
        || MEMORY[0xFFFFF7800000026C] == 6 && (result = 0xFFFFF78000000270ui64, !MEMORY[0xFFFFF78000000270]) )
      {
        a4[1] = 0;
      }
      else
      {
        result = qword_1400DABD8;
        if ( qword_1400DABD8 && byte_1400DABE8 )
        {
          result = sub_1400488FC(qword_1400DABD8, (__int64)&a7);
          if ( (int)result >= 0 )
          {
            v12 = (unsigned int *)sub_14002F378();
            Object[1] = v12;
            if ( v12 && sub_140015378((__int64)a7, (__int64)v16) )
            {
              if ( qword_1400DAC48 )
              {
                sub_14005221C(qword_1400DAC48, 4i64, 1);
                v13 = (void *)*(unsigned int *)qword_1400DAC48;
                if ( (_DWORD)v13 )
                {
                  if ( ObReferenceObjectByHandle(v13, 2u, (POBJECT_TYPE)ExEventObjectType, 1, Object, 0i64) >= 0 )
                  {
                    sub_14005221C((ULONG64)v12, 0xCB4i64, 1);
                    if ( ObReferenceObjectByHandle(
                           (HANDLE)v12[1],
                           0x100000u,
                           (POBJECT_TYPE)ExEventObjectType,
                           1,
                           &v14,
                           0i64) >= 0 )
                    {
                      v12[2] = v18;
                      JUMPOUT(0x14002FA14i64);
                    }
                    v14 = 0i64;
                  }
                  else
                  {
                    Object[0] = 0i64;
                  }
                }
              }
              ((void (__fastcall *)(PVOID, char *))loc_140015528)(a7, v16);
              a4[1] = 7;
              if ( v14 )
                ObfDereferenceObject(v14);
              if ( Object[0] )
                ObfDereferenceObject(Object[0]);
            }
            result = ObfDereferenceObject(a7);
          }
        }
        else
        {
          a4[1] = 6;
        }
      }
    }
    else
    {
      a4[1] = 4;
    }
  }
  return result;
}
// 14002FA11: control flows out of bounds to 14002FA14
// 14002FB6A: control flows out of bounds to 14002FB6D
// 14002FAC8: conditional instruction was optimized away because of '%var_98.1==0'
// 14002FB2E: conditional instruction was optimized away because of '%var_98.1==0'
// 1400DABD8: using guessed type __int64 qword_1400DABD8;
// 1400DABE8: using guessed type char byte_1400DABE8;
// 1400DAC48: using guessed type __int64 qword_1400DAC48;

//----- (000000014002FBD8) ----------------------------------------------------
char sub_14002FBD8()
{
  char v0; // cl

  if ( MEMORY[0xFFFFF7800000026C] < 6u )
    return 1;
  v0 = 0;
  if ( MEMORY[0xFFFFF7800000026C] == 6 && !MEMORY[0xFFFFF78000000270] )
    return 1;
  if ( qword_1400DABD8 )
  {
    if ( byte_1400DABE8 )
      v0 = 1;
  }
  return v0;
}
// 1400DABD8: using guessed type __int64 qword_1400DABD8;
// 1400DABE8: using guessed type char byte_1400DABE8;

//----- (000000014002FC18) ----------------------------------------------------
char __fastcall sub_14002FC18(__int64 a1)
{
  char v1; // dl

  v1 = 0;
  if ( a1 && a1 == qword_1400DABD8 )
    v1 = 1;
  return v1;
}
// 1400DABD8: using guessed type __int64 qword_1400DABD8;

//----- (000000014002FC44) ----------------------------------------------------
void __fastcall sub_14002FC44(void *a1)
{
  if ( a1 && !Object )
  {
    ObReferenceObjectByHandle(a1, 2u, (POBJECT_TYPE)ExEventObjectType, 1, (PVOID *)&Object, 0i64);
    JUMPOUT(0x14002FC89i64);
  }
}
// 14002FC87: control flows out of bounds to 14002FC89

//----- (000000014002FC9C) ----------------------------------------------------
LONG_PTR sub_14002FC9C()
{
  LONG_PTR result; // rax

  result = qword_1400DABD8;
  if ( qword_1400DABD8 )
  {
    result = sub_1400151F8(qword_1400DABD8, 0i64);
    qword_1400DABD8 = 0i64;
  }
  if ( Object )
  {
    result = ObfDereferenceObject(Object);
    Object = 0i64;
  }
  qword_1400DABE0 = 0i64;
  return result;
}
// 1400151F8: using guessed type __int64 __fastcall sub_1400151F8(_QWORD, _QWORD);
// 1400DABD8: using guessed type __int64 qword_1400DABD8;
// 1400DABE0: using guessed type __int64 qword_1400DABE0;

//----- (000000014002FD08) ----------------------------------------------------
__int64 __fastcall sub_14002FD08(__int64 a1, unsigned int a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v8; // rax
  __int64 v10; // [rsp+20h] [rbp-28h]
  __int64 v11; // [rsp+28h] [rbp-20h]
  void *v12; // [rsp+30h] [rbp-18h]

  if ( !a1 || !a2 )
    return 0i64;
  a5 = 0i64;
  a8 = a2;
  v8 = sub_140014914(a1, 8u, a3, a4, v10, v11, v12);
  if ( v8 )
  {
    sub_1400616FC(v8, (__int64)&a5, 0i64, (__int64)&a8);
    JUMPOUT(0x14002FD80i64);
  }
  return 0i64;
}
// 14002FD7D: control flows out of bounds to 14002FD80
// 14002FD42: variable 'v10' is possibly undefined
// 14002FD42: variable 'v11' is possibly undefined
// 14002FD42: variable 'v12' is possibly undefined
// 140014CAC: using guessed type __int64 __fastcall sub_140014CAC(_QWORD, _QWORD);

//----- (000000014002FDD8) ----------------------------------------------------
char __fastcall sub_14002FDD8(__int64 a1, ULONG64 a2, __int64 a3, unsigned int a4, unsigned int a5)
{
  char v8; // bl
  __int64 v10; // [rsp+20h] [rbp-48h]
  __int64 v11; // [rsp+20h] [rbp-48h]
  PVOID Object; // [rsp+28h] [rbp-40h] BYREF
  char v13[48]; // [rsp+30h] [rbp-38h] BYREF

  v8 = 0;
  LOBYTE(v10) = 0;
  if ( !a1 || !a2 || !a3 )
    return 0;
  if ( (int)sub_1400488FC(a1, (__int64)&Object) >= 0 )
  {
    if ( sub_140015378((__int64)Object, (__int64)v13) )
    {
      sub_14005221C(a2, a4, 1);
      if ( sub_140014C20(a2, a4, 0x40u, (__int64)&a5, v10, (__int64)Object) )
      {
        sub_140052288(a2, a4);
        ((void (__fastcall *)(ULONG64, __int64, _QWORD))loc_14006F000)(a2, a3, a4);
        v8 = 1;
        LOBYTE(v11) = 1;
        sub_140014C20(a2, a4, a5, (__int64)&a5, v11, (__int64)Object);
      }
      ((void (__fastcall *)(PVOID, char *))loc_140015528)(Object, v13);
    }
    ObfDereferenceObject(Object);
  }
  return v8;
}
// 14002FE56: variable 'v10' is possibly undefined
// 14002FE8C: variable 'v11' is possibly undefined

//----- (000000014002FED0) ----------------------------------------------------
__int64 __fastcall sub_14002FED0(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a1 && a2 && a3 )
    sub_140044564(a3, a1, a2, 2u);
  return 0i64;
}

//----- (000000014002FF18) ----------------------------------------------------
__int64 __fastcall sub_14002FF18(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  if ( a1
    && a2
    && a1 > (unsigned __int64)MmSystemRangeStart
    && a3
    && (unsigned int)((a1 + a2 - (a1 & 0xFFFFFFFFFFFFF000ui64) + 0xFFF) >> 0xC) )
  {
    JUMPOUT(0x14002FFB1i64);
  }
  return 0i64;
}
// 14002FFAF: control flows out of bounds to 14002FFB1

//----- (000000014003004C) ----------------------------------------------------
char __fastcall sub_14003004C(__int64 a1)
{
  void (__fastcall *v2)(__int64, _QWORD); // rax

  v2 = (void (__fastcall *)(__int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                               qword_1400DADA8,
                                               &qword_1400DADA8,
                                               0i64);
  if ( v2 )
    v2(a1, 0i64);
  return 1;
}
// 1400DADA8: using guessed type __int64 qword_1400DADA8;

//----- (000000014003019C) ----------------------------------------------------
__int64 __fastcall sub_14003019C(unsigned __int64 a1, unsigned __int64 a2, void *a3)
{
  __int64 v3; // rdi
  __int64 v4; // rax

  v3 = 0i64;
  if ( a1 && a2 && a1 > (unsigned __int64)MmSystemRangeStart && a3 )
  {
    memset(a3, 0, a2);
    if ( MEMORY[0xFFFFF7800000026C] > 6u || MEMORY[0xFFFFF7800000026C] == 6 && MEMORY[0xFFFFF78000000270] == 3 )
      v4 = sub_14002FED0(a1, a2, (__int64)a3);
    else
      v4 = sub_14002FF18(a1, a2, (__int64)a3);
    v3 = v4;
  }
  return v3;
}

//----- (000000014003020C) ----------------------------------------------------
__int64 __fastcall sub_14003020C(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a1 && a3 )
    sub_140044564(a3, a1, a2, 1u);
  return 0i64;
}

//----- (0000000140030250) ----------------------------------------------------
bool __fastcall sub_140030250(__int64 a1, __int64 a2, __int64 a3)
{
  return sub_14003020C(a1, 0x1000i64, a3) == 0x1000;
}

//----- (000000014003026C) ----------------------------------------------------
char __fastcall sub_14003026C(__int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  unsigned __int64 v3; // rdi

  if ( !a1 )
    return 0;
  v2 = a1 & 0xFFFFFFFFFFFFF000ui64;
  v3 = (a1 + a2 + 0xFFF) & 0xFFFFFFFFFFFFF000ui64;
  while ( v2 < v3 )
  {
    if ( !(unsigned __int8)sub_140044444(v2) )
      return 0;
    v2 += 0x1000i64;
  }
  return 1;
}

//----- (00000001400302C0) ----------------------------------------------------
char __fastcall sub_1400302C0(unsigned __int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  char v8; // bl
  _DWORD *v9; // r14
  void *v12; // rax
  __int64 v13; // r15
  __int64 v14; // rbp
  void *v15; // rax
  unsigned int v16; // er12
  unsigned int *v17; // rdi
  _DWORD *v19; // [rsp+70h] [rbp+18h]

  v19 = a3;
  v8 = 0;
  v9 = a3;
  if ( !a1 || !a2 )
    return 0;
  *a2 = 0i64;
  if ( a3 )
    *a3 = 0;
  v12 = (void *)sub_140051084(0x1000ui64);
  v13 = (__int64)v12;
  if ( v12 )
  {
    if ( sub_14003019C(a1, 0x1000ui64, v12) == 0x1000 )
    {
      if ( sub_14005240C(v13, 0x1000ui64, 0i64, &a8) )
      {
        v14 = a8;
        v15 = (void *)sub_140051084(*(unsigned int *)(a8 + 0x50));
        *a2 = v15;
        if ( v15 )
        {
          memset(v15, 0, *(unsigned int *)(v14 + 0x50));
          ((void (__fastcall *)(void *, __int64, _QWORD))loc_14006F000)(v15, v13, *(unsigned int *)(v14 + 0x54));
          v16 = 0;
          if ( *(_WORD *)(v14 + 6) )
          {
            v17 = (unsigned int *)(v14 + *(unsigned __int16 *)(v14 + 0x14) + 0x20i64);
            do
            {
              if ( (v17[7] & 0x2000000) == 0 )
              {
                sub_14003019C(a1 + v17[1], *v17, (void *)(v17[1] + *a2));
                JUMPOUT(0x1400303CDi64);
              }
              v17 += 0xA;
              ++v16;
            }
            while ( v16 < *(unsigned __int16 *)(v14 + 6) );
            v9 = v19;
          }
          if ( v9 )
            *v9 = *(_DWORD *)(v14 + 0x50);
          v8 = 1;
        }
      }
    }
    sub_140051220(v13);
  }
  return v8;
}
// 1400303C8: control flows out of bounds to 1400303CD

//----- (0000000140030428) ----------------------------------------------------
__int64 __fastcall sub_140030428(__int64 a1, __int64 a2, unsigned int a3)
{
  unsigned int v3; // er9
  unsigned int v4; // er8

  v3 = 4;
  if ( a1 && a2 )
  {
    if ( MEMORY[0xFFFFF7800000026C] < 0xAu )
      return sub_14004447C(a1, a2, a3);
    if ( !a3 )
    {
      v3 = 0x204;
      return sub_1400444D0(a1, a2, v3);
    }
    v4 = a3 - 1;
    if ( !v4 )
      return sub_1400444D0(a1, a2, v3);
    if ( v4 == 1 )
    {
      v3 = 0x404;
      return sub_1400444D0(a1, a2, v3);
    }
  }
  return 0i64;
}

//----- (0000000140030478) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_140030478(__int64 a1, int a2, __int64 a3)
{
  JUMPOUT(0x1400304ABi64);
}
// 140030643: positive sp value 18 has been found
// 1400304A8: control flows out of bounds to 1400304AB

//----- (0000000140030674) ----------------------------------------------------
char __fastcall sub_140030674(ULONG64 *a1)
{
  ULONG64 v2; // rcx
  __int64 v3; // rdx
  char result; // al

  if ( !a1 )
    goto LABEL_9;
  v2 = *a1;
  if ( !v2 )
    goto LABEL_9;
  v3 = a1[3];
  if ( !v3 )
    goto LABEL_9;
  if ( v2 < (unsigned __int64)MmHighestUserAddress )
  {
    sub_14005221C(v2, v3, 1);
    return 1;
  }
  if ( v2 >= (unsigned __int64)MmSystemRangeStart && v3 + v2 > v2 )
    result = 1;
  else
LABEL_9:
    result = 0;
  return result;
}

//----- (00000001400306D0) ----------------------------------------------------
void sub_1400306D0()
{
  JUMPOUT(0x1400306DCi64);
}
// 1400306D8: control flows out of bounds to 1400306DC

//----- (0000000140030734) ----------------------------------------------------
__int64 __fastcall sub_140030734(ULONG64 *a1, int a2, __int64 a3, int a4)
{
  if ( !sub_140030674(a1) || !a3 || !a4 )
    return 0i64;
  sub_140030478((__int64)a1, a2, (__int64)&dword_140030644);
  return 0i64;
}
// 140030644: using guessed type int dword_140030644;

//----- (00000001400307A8) ----------------------------------------------------
char __fastcall sub_1400307A8(__int64 a1)
{
  __int64 v2; // rax

  v2 = sub_140048808();
  sub_140013EF0(v2);
  if ( *(_QWORD *)(a1 + 0x18) >= 0x40ui64 )
    JUMPOUT(0x1400307F3i64);
  return 0;
}
// 1400307F0: control flows out of bounds to 1400307F3

//----- (000000014003097C) ----------------------------------------------------
bool __fastcall sub_14003097C(__int64 a1, int a2, int a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int64 v9; // r9

  v9 = *(_QWORD *)a9 + 0x10i64 * (unsigned int)(*(_DWORD *)(a9 + 8))++;
  *(_QWORD *)v9 = a1;
  *(_DWORD *)(v9 + 8) = a2;
  *(_DWORD *)(v9 + 0xC) = a3;
  return *(_DWORD *)(a9 + 8) == *(_DWORD *)(a9 + 0xC);
}

//----- (00000001400309AC) ----------------------------------------------------
__int64 __fastcall sub_1400309AC(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  if ( a1 && a2 && a3 && a4 && sub_140051084(0x18i64 * (a4 >> 3)) )
    JUMPOUT(0x140030A1Ai64);
  return 0i64;
}
// 140030A14: control flows out of bounds to 140030A1A

//----- (00000001400317F8) ----------------------------------------------------
char __fastcall sub_1400317F8(ULONG64 a1, __int64 a2, __int64 a3)
{
  unsigned int *v6; // rdi
  unsigned __int16 i; // si
  unsigned int v8; // eax

  v6 = (unsigned int *)(*(unsigned __int16 *)(a3 + 0x14) + a3 + 0x18);
  if ( !a1 || !a2 )
    return 0;
  sub_14005221C(a1, 0x1000i64, 1);
  ((void (__fastcall *)(ULONG64, __int64, __int64))loc_14006F000)(a1, a2, 0x1000i64);
  for ( i = 0; i < *(_WORD *)(a3 + 6); ++i )
  {
    v8 = v6[4];
    if ( v8 )
    {
      sub_14005221C(a1 + v6[3], v8, 1);
      ((void (__fastcall *)(ULONG64, __int64, _QWORD))loc_14006F000)(a1 + v6[3], a2 + v6[5], v6[4]);
    }
    v6 += 0xA;
  }
  return 1;
}

//----- (00000001400318E0) ----------------------------------------------------
void __fastcall sub_1400318E0(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned int a6)
{
  unsigned __int16 v8; // si
  _DWORD *v9; // rbx
  unsigned int v10; // er8
  unsigned int v11; // er10
  __int64 v12; // [rsp+20h] [rbp-18h]
  __int64 v13; // [rsp+28h] [rbp-10h]

  v8 = 0;
  if ( *(_WORD *)(a2 + 6) )
  {
    v9 = (_DWORD *)(a2 + *(unsigned __int16 *)(a2 + 0x14) + 0x3Ci64);
    do
    {
      v10 = v9[0xFFFFFFFB];
      if ( !v10 )
      {
        if ( (*v9 & 0x40) != 0 )
        {
          v10 = *(_DWORD *)(a2 + 0x20);
        }
        else if ( (char)*v9 < 0 )
        {
          v10 = *(_DWORD *)(a2 + 0x24);
        }
      }
      v11 = dword_1400C4460[4 * (((unsigned __int64)(unsigned int)*v9 >> 0x1D) & 1)
                          + 2 * (((unsigned __int64)(unsigned int)*v9 >> 0x1E) & 1)
                          + ((unsigned __int64)(unsigned int)*v9 >> 0x1F)];
      a6 = v11;
      if ( (*v9 & 0x4000000) != 0 )
      {
        v11 |= 0x200u;
        a6 = v11;
      }
      if ( v10 )
        sub_140014C20(a1 + (unsigned int)v9[0xFFFFFFFA], v10, v11, (__int64)&a6, v12, v13);
      ++v8;
      v9 += 0xA;
    }
    while ( v8 < *(_WORD *)(a2 + 6) );
  }
}
// 140031994: variable 'v12' is possibly undefined
// 140031994: variable 'v13' is possibly undefined

//----- (00000001400319C4) ----------------------------------------------------
__int64 __fastcall sub_1400319C4(__int64 a1)
{
  __int64 v1; // rbx
  unsigned __int64 v2; // rsi
  unsigned __int64 v3; // r14
  __int64 v4; // rax
  char *i; // rcx
  unsigned int v6; // edx
  char *v8; // r14
  unsigned int v9; // edx
  unsigned __int64 v10; // r8
  unsigned __int64 v11; // rdi
  char v12; // cl
  __int64 *v13; // rax
  __int64 v14; // rax
  int v15[2]; // [rsp+20h] [rbp-E0h]
  __int16 v16; // [rsp+28h] [rbp-D8h]
  __int64 v17[2]; // [rsp+2Ah] [rbp-D6h] BYREF
  char v18[256]; // [rsp+40h] [rbp-C0h] BYREF
  __int16 v19[256]; // [rsp+140h] [rbp+40h] BYREF

  v1 = 0i64;
  if ( !a1 )
    return 0i64;
  v2 = 0xFFFFFFFFFFFFFFFFui64;
  v3 = 0xFFFFFFFFFFFFFFFFui64;
  do
    ++v3;
  while ( *(_BYTE *)(a1 + v3) );
  if ( (unsigned int)(v3 - 1) > 0xFE )
    return 0i64;
  ((void (__fastcall *)(char *, __int64, _QWORD))loc_14006F000)(v18, a1, (unsigned int)v3);
  v18[(unsigned int)v3] = 0;
  v4 = 0i64;
  if ( !(_DWORD)v3 )
    return 0i64;
  for ( i = v18; ; ++i )
  {
    v6 = v4 + 1;
    if ( *i == 0x2E )
      break;
    v4 = v6;
    if ( v6 >= (unsigned int)v3 )
      return 0i64;
  }
  v18[v4] = 0;
  v8 = &v18[v6];
  if ( !v8 )
    return 0i64;
  sub_1400076B4((__int64)v19, 0x100i64, (__int64)v18);
  v15[0] = 0x10D501BD;
  v16 = 0xD22E;
  v9 = 0x10B10193;
  v15[1] = 0xCFC53EBA;
  v17[0] = 0i64;
  v10 = 0i64;
  LOWORD(v17[1]) = 0;
  v11 = 8i64;
  do
  {
    *(_DWORD *)((char *)v17 + v10 * 4) = v15[v10] ^ v9;
    ++v10;
    v9 = -(((v9 ^ (v9 >> 7)) << 9) ^ v9 ^ (v9 >> 7) ^ ((((v9 ^ (v9 >> 7)) << 9) ^ v9 ^ (v9 >> 7)) >> 0xD));
  }
  while ( v10 < 2 );
  do
  {
    v12 = v9;
    v9 >>= 8;
    *((_BYTE *)v17 + v11) = *((_BYTE *)v15 + v11) ^ v12;
    ++v11;
  }
  while ( v11 < 0xA );
  do
    ++v2;
  while ( v19[v2] );
  if ( v2 <= 0xFF )
  {
    if ( v2 < 0xFF )
    {
      v13 = v17;
      do
      {
        if ( !*(_WORD *)v13 )
          break;
        v19[v2] = *(_WORD *)v13;
        v13 = (__int64 *)((char *)v13 + 2);
        ++v2;
      }
      while ( v2 < 0xFF );
    }
    v19[v2] = 0;
  }
  memset(v17, 0, 0xAui64);
  v14 = sub_140052728((__int64)v19);
  if ( v14 )
    v1 = sub_1400529D4(v14, (__int64)v8);
  return v1;
}

//----- (0000000140031BA0) ----------------------------------------------------
char __fastcall sub_140031BA0(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, unsigned int a8)
{
  __int64 v9; // rax
  _DWORD *v11; // rdi
  __int64 v12; // r14
  __int64 v13; // rbx
  unsigned int v14; // eax
  _DWORD *v15; // rax
  __int64 v17; // [rsp+20h] [rbp-258h]
  __int64 v18; // [rsp+20h] [rbp-258h]
  __int64 v19; // [rsp+28h] [rbp-250h]
  char v20[568]; // [rsp+40h] [rbp-238h] BYREF

  LOBYTE(v9) = a2;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        sub_1400076B4((__int64)v20, 0x100i64, (__int64)a3);
        v9 = sub_140052728((__int64)v20);
        if ( v9 )
        {
          LOBYTE(v9) = 0x4D;
          if ( *(_WORD *)a1 == 0x5A4D )
          {
            v11 = (_DWORD *)(a1 + *(int *)(a1 + 0x3C));
            if ( *v11 == 0x4550 )
            {
              v12 = (unsigned int)v11[0x21];
              if ( (_DWORD)v12 )
              {
                v9 = (__int64)sub_1400524BC((unsigned int)v11[0x20], a1 + *(int *)(a1 + 0x3C), a1);
                v13 = v9;
                if ( (_DWORD *)v9 != v11 )
                {
                  sub_140014C20(v9, v12, 0x40u, (__int64)&a8, v17, v9);
                  while ( 1 )
                  {
                    v14 = *(_DWORD *)(v13 + 0xC);
                    if ( !v14 )
                      break;
                    v15 = sub_1400524BC(v14, (__int64)v11, a1);
                    if ( !v15 )
                      break;
                    if ( sub_140007538((__int64)v15, a3, 0x20ui64) )
                      JUMPOUT(0x140031CE4i64);
                    v13 += 0x14i64;
                    v19 = v13;
                  }
                  LOBYTE(v9) = sub_140014C20(v13, (unsigned int)v11[0x21], a8, (__int64)&a8, v18, v19);
                }
              }
            }
          }
        }
      }
    }
  }
  return v9;
}
// 140031CE0: control flows out of bounds to 140031CE4
// 140031C6C: variable 'v17' is possibly undefined
// 140031D98: variable 'v18' is possibly undefined
// 140031D98: variable 'v19' is possibly undefined

//----- (0000000140031DB4) ----------------------------------------------------
char __fastcall sub_140031DB4(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, unsigned int a8)
{
  __int64 v9; // rax
  _DWORD *v11; // rdi
  __int64 v12; // r14
  __int64 v13; // rbx
  unsigned int v14; // eax
  _DWORD *v15; // rax
  __int64 v17; // [rsp+20h] [rbp-258h]
  __int64 v18; // [rsp+20h] [rbp-258h]
  __int64 v19; // [rsp+28h] [rbp-250h]
  char v20[568]; // [rsp+40h] [rbp-238h] BYREF

  LOBYTE(v9) = a2;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        sub_1400076B4((__int64)v20, 0x100i64, (__int64)a3);
        v9 = sub_140052728((__int64)v20);
        if ( v9 )
        {
          LOBYTE(v9) = 0x4D;
          if ( *(_WORD *)a1 == 0x5A4D )
          {
            v11 = (_DWORD *)(a1 + *(int *)(a1 + 0x3C));
            if ( *v11 == 0x4550 )
            {
              v12 = (unsigned int)v11[0x25];
              if ( (_DWORD)v12 )
              {
                v9 = (__int64)sub_1400524BC((unsigned int)v11[0x24], a1 + *(int *)(a1 + 0x3C), a1);
                v13 = v9;
                if ( (_DWORD *)v9 != v11 )
                {
                  sub_140014C20(v9, v12, 0x40u, (__int64)&a8, v17, v9);
                  while ( 1 )
                  {
                    v14 = *(_DWORD *)(v13 + 0xC);
                    if ( !v14 )
                      break;
                    v15 = sub_1400524BC(v14, (__int64)v11, a1);
                    if ( !v15 )
                      break;
                    if ( sub_140007538((__int64)v15, a3, 0x20ui64) )
                      JUMPOUT(0x140031EFEi64);
                    v13 += 0x14i64;
                    v19 = v13;
                  }
                  LOBYTE(v9) = sub_140014C20(v13, (unsigned int)v11[0x25], a8, (__int64)&a8, v18, v19);
                }
              }
            }
          }
        }
      }
    }
  }
  return v9;
}
// 140031EFA: control flows out of bounds to 140031EFE
// 140031E80: variable 'v17' is possibly undefined
// 140031FB2: variable 'v18' is possibly undefined
// 140031FB2: variable 'v19' is possibly undefined

//----- (0000000140031FCC) ----------------------------------------------------
void __fastcall sub_140031FCC(__int64 a1, __int64 a2, int a3, __int64 a4)
{
  __int64 v6; // rax
  __int64 v7; // rsi
  __int64 v8; // rbp
  unsigned int v9; // er15
  _DWORD *v10; // r14
  unsigned int *v11; // r12
  __int64 v12; // rdi
  _DWORD *v13; // rax
  unsigned int v14; // er9
  int v15; // edx

  if ( a1 && a2 && a3 && a4 )
  {
    if ( a3 == 0x20 )
    {
      v6 = *(unsigned int *)(a4 + 0x34);
      v7 = 0xA0i64;
    }
    else
    {
      if ( a3 != 0x40 )
        return;
      v6 = *(_QWORD *)(a4 + 0x30);
      v7 = 0xB0i64;
    }
    v8 = a1 - v6;
    if ( a1 != v6 && *(_DWORD *)(a4 + v7 + 4) )
    {
      v9 = 0;
      v10 = sub_1400524BC(*(unsigned int *)(a4 + v7), a4, a2);
      do
      {
        v11 = v10 + 1;
        v12 = (unsigned int)v10[1];
        if ( !(_DWORD)v12 )
          break;
        v13 = sub_1400524BC((unsigned int)*v10, a4, a2);
        v14 = 0;
        v10 += 2;
        if ( ((v12 - 8) & 0xFFFFFFFFFFFFFFFEui64) != 0 )
        {
          do
          {
            v15 = *(unsigned __int16 *)v10 >> 0xC;
            if ( v15 == 3 )
            {
              *(_DWORD *)((char *)v13 + (*(_WORD *)v10 & 0xFFF)) += v8;
            }
            else if ( v15 == 0xA )
            {
              *(_QWORD *)((char *)v13 + (*(_WORD *)v10 & 0xFFF)) += v8;
            }
            v12 = *v11;
            ++v14;
            v10 = (_DWORD *)((char *)v10 + 2);
          }
          while ( v14 < (unsigned __int64)(v12 - 8) >> 1 );
        }
        v9 += v12;
      }
      while ( v9 < *(_DWORD *)(a4 + v7 + 4) );
    }
  }
}
// 140032065: conditional instruction was optimized away because of 'edi.4!=0'

//----- (0000000140032104) ----------------------------------------------------
bool __fastcall sub_140032104(__int64 a1, unsigned __int64 a2, __int64 *a3, _QWORD *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, _QWORD *a9, _DWORD *a10, _DWORD *a11)
{
  __int64 v11; // r14
  __int64 v12; // rcx
  __int16 v13; // ax
  int v14; // er13
  unsigned int v15; // er12
  __int64 v16; // rax
  unsigned int v17; // edi
  unsigned int v18; // ebx
  __int64 v19; // r8
  __int64 v20; // rax
  _BYTE *v21; // r12
  _BYTE *v22; // rdi
  __int64 v23; // rdi
  __int64 v24; // rbx
  __int64 v25; // r8
  __int64 v26; // r9
  __int64 v28; // [rsp+20h] [rbp-78h] BYREF
  __int64 v29; // [rsp+28h] [rbp-70h] BYREF
  __int64 v30; // [rsp+30h] [rbp-68h]
  unsigned int v31; // [rsp+38h] [rbp-60h]
  unsigned int v32; // [rsp+3Ch] [rbp-5Ch]
  __int64 v33; // [rsp+40h] [rbp-58h]
  __int64 v34; // [rsp+48h] [rbp-50h] BYREF
  __int64 v35; // [rsp+50h] [rbp-48h]
  unsigned int v37; // [rsp+A0h] [rbp+8h]

  v11 = 0i64;
  v30 = 0i64;
  if ( !a1 || !a2 || !a3 || !a4 || !a9 )
    return 0;
  *a3 = 0i64;
  *a4 = 0i64;
  *a9 = 0i64;
  if ( a10 )
    *a10 = 0;
  if ( a11 )
    *a11 = 0;
  if ( sub_14005240C(a1, a2, &v34, &v29) )
  {
    v12 = v29;
    v13 = *(_WORD *)(v29 + 4);
    if ( v13 == 0x14C )
    {
      v14 = 0x20;
      v15 = *(_DWORD *)(v29 + 0x50);
      LODWORD(v28) = v15;
LABEL_18:
      v35 = v15;
      v16 = sub_140051084(v15);
      v11 = v16;
      v30 = v16;
      if ( v16 )
      {
        ((void (__fastcall *)(__int64, __int64, unsigned __int64))loc_14006F000)(v16, a1, a2);
        v17 = (unsigned int)sub_14000A890(4, 0x10) << 0xC;
        LODWORD(v29) = v17;
        v31 = v17;
        v37 = (unsigned int)sub_14000A890(4, 0x10) << 0xC;
        v32 = v37;
        v18 = v15 + v37 + v17;
        v20 = sub_140014BD0(v18, v18, v19, 4i64, v28);
        v21 = (_BYTE *)v20;
        v33 = v20;
        if ( v20 )
        {
          if ( sub_140014C20(v20, v18, 0x40u, (__int64)&v28 + 4, v28, v29) )
          {
            sub_14005221C((ULONG64)v21, v17, 1);
            sub_14000A8E8(v21, v17);
            if ( sub_140014C20((__int64)v21, v17, 0x20u, (__int64)&v28 + 4, v28, v29) )
            {
              v22 = &v21[(unsigned int)v28 + v17];
              sub_14005221C((ULONG64)v22, v37, 1);
              sub_14000A8E8(v22, v37);
              if ( sub_140014C20((__int64)v22, v37, 2u, (__int64)&v28 + 4, v28, v29) )
              {
                v23 = (__int64)&v21[(unsigned int)v29];
                v33 = v23;
                v24 = v11 + *(int *)(v34 + 0x3C);
                v29 = v24;
                sub_140031FCC(v23, v11, v14, v24);
                if ( v14 == 0x40 )
                  *(_QWORD *)(v24 + 0x30) = v23;
                else
                  *(_DWORD *)(v24 + 0x34) = v23;
                if ( sub_1400317F8(v23, v11, v24) )
                {
                  sub_1400318E0(v23, v24, v25, v26, v28, v29);
                  *a3 = v23;
                  *a4 = v35;
                  *a9 = v23 + *(unsigned int *)(v24 + 0x28);
                }
              }
            }
          }
        }
      }
      goto LABEL_28;
    }
    if ( v13 == (__int16)0x8664 )
    {
      v14 = 0x40;
      v15 = *(_DWORD *)(v29 + 0x50);
      LODWORD(v28) = v15;
      if ( a10 )
        *a10 = *(_DWORD *)(v29 + 0xA0);
      if ( a11 )
        *a11 = *(_DWORD *)(v12 + 0xA4);
      goto LABEL_18;
    }
  }
LABEL_28:
  if ( v11 )
    sub_140051220(v11);
  return *a9 != 0i64;
}
// 14003227C: variable 'v19' is possibly undefined
// 14003237C: variable 'v25' is possibly undefined
// 14003237C: variable 'v26' is possibly undefined

//----- (00000001400323DC) ----------------------------------------------------
void __fastcall sub_1400323DC(ULONG64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  int v6; // eax
  __int64 v7; // rcx
  __int64 v8; // rax

  if ( a1 )
  {
    sub_14005221C(a1, 0x1000i64, 1);
    if ( sub_14005240C(a1, 0x1000ui64, 0i64, &a5) )
    {
      v6 = sub_140052894(a1);
      if ( v6 == 0x20 )
      {
        v7 = 0x78i64;
      }
      else
      {
        if ( v6 != 0x40 )
          return;
        v7 = 0x88i64;
      }
      if ( *(_DWORD *)(v7 + a5 + 4) )
      {
        v8 = *(unsigned int *)(v7 + a5);
        if ( (_DWORD)v8 )
        {
          sub_140052288(a1 + v8, 0x28i64);
          JUMPOUT(0x140032460i64);
        }
      }
    }
  }
}
// 14003245B: control flows out of bounds to 140032460

//----- (0000000140034AD0) ----------------------------------------------------
__int64 __fastcall sub_140034AD0(_BYTE *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  unsigned int v9; // ebx
  unsigned __int64 v10; // rdi
  int v11; // eax

  a8 = a4;
  if ( (unsigned __int64)(a2 - 1) <= 0x7FFFFFFE )
  {
    v10 = a2 - 1;
    v9 = 0;
    sub_140034B38((__int64)a1, a2 - 1, a3, (__int64)&a8);
    if ( v11 < 0 || v11 > v10 )
    {
      a1[v10] = 0;
      v9 = 0x80000005;
    }
    else if ( v11 == v10 )
    {
      a1[v10] = 0;
    }
  }
  else
  {
    v9 = 0xC000000D;
    if ( a2 )
      *a1 = 0;
  }
  return v9;
}
// 140034B14: variable 'v11' is possibly undefined

//----- (0000000140034B38) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_140034B38(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  void (__fastcall *v4)(__int64, __int64, __int64, __int64); // rax
  int v9[8]; // [rsp+20h] [rbp-20h] BYREF

  v4 = (void (__fastcall *)(__int64, __int64, __int64, __int64))qword_1400D8210;
  if ( qword_1400D8210
    || (v9[0] = 0x6347F5AD,
        v9[1] = 0x7A60205B,
        v9[2] = 0x809F0BF0,
        v9[3] = 0x6953FF6B,
        v9[4] = 0xE613A479,
        v4 = (void (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(int *))loc_1400061CC)(v9),
        (qword_1400D8210 = (__int64)v4) != 0) )
  {
    v4(a1, a2, a3, a4);
  }
  JUMPOUT(0x140034BCBi64);
}
// 140034BD8: positive sp value 58 has been found
// 140034BC6: control flows out of bounds to 140034BCB
// 1400D8210: using guessed type __int64 qword_1400D8210;

//----- (0000000140034BDC) ----------------------------------------------------
__int64 sub_140034BDC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  __int64 v4; // rbx
  int (__fastcall *v6)(__int64, __int64, __int64, char *); // rax
  va_list va; // [rsp+30h] [rbp+8h] BYREF

  va_start(va, a4);
  v4 = 0i64;
  if ( a1 )
  {
    v4 = sub_140051084(0x400ui64);
    if ( v4 )
    {
      v6 = (int (__fastcall *)(__int64, __int64, __int64, char *))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                    qword_1400DAD30,
                                                                    &qword_1400DAD30,
                                                                    0i64);
      if ( !v6 || v6(a1, v4, 0x400i64, va) < 0 )
      {
        sub_140051220(v4);
        v4 = 0i64;
      }
    }
  }
  return v4;
}
// 1400DAD30: using guessed type __int64 qword_1400DAD30;

//----- (0000000140034C4C) ----------------------------------------------------
char __fastcall sub_140034C4C(PVOID Object, __int64 a2, __int64 a3, __int64 a4, ULONG ResultLength, __int64 a6, __int64 a7, HANDLE KeyHandle)
{
  char v8; // bl
  NTSTATUS v11; // eax
  _DWORD *v12; // rdi
  struct _UNICODE_STRING ValueName; // [rsp+40h] [rbp-10h] BYREF

  v8 = 0;
  ResultLength = 0;
  if ( !Object || !a2 || !*(_QWORD *)(a2 + 8) || !*(_WORD *)a2 || !*(_WORD *)(a2 + 2) || !a3 )
    return 0;
  if ( sub_140007178((__int64)&ValueName, (unsigned __int16 *)a2, *(_WORD *)a2) )
  {
    if ( ObOpenObjectByPointer(Object, 0x200u, 0i64, 0x20019u, 0i64, 0, &KeyHandle) >= 0 )
    {
      v11 = ZwQueryValueKey(KeyHandle, &ValueName, KeyValuePartialInformation, 0i64, 0, &ResultLength);
      if ( v11 == 0xC0000023 || v11 == 0x80000005 )
      {
        if ( ResultLength )
        {
          v12 = (_DWORD *)sub_140051084(ResultLength);
          if ( v12 )
          {
            if ( ZwQueryValueKey(KeyHandle, &ValueName, KeyValuePartialInformation, v12, ResultLength, &ResultLength) >= 0
              && v12[1] == 1 )
            {
              v8 = sub_1400070E0(a3, (__int64)(v12 + 3));
            }
            sub_140051220((__int64)v12);
          }
        }
      }
      ZwClose(KeyHandle);
    }
    sub_14000724C((__int64)&ValueName);
  }
  return v8;
}

//----- (0000000140034D98) ----------------------------------------------------
char __fastcall sub_140034D98(__int64 a1)
{
  unsigned int v2; // edx
  unsigned __int64 i; // rdi
  int v4; // ecx
  unsigned __int64 j; // rdi
  char v6; // cl
  __int64 v7; // rcx
  _WORD *v8; // rax
  unsigned int v9; // ecx
  unsigned __int8 *k; // rdx
  int v11; // eax
  char result; // al
  int v13[50]; // [rsp+52h] [rbp-AEh]
  __int16 v14; // [rsp+11Ah] [rbp+1Ah]
  char v15[208]; // [rsp+170h] [rbp+70h] BYREF

  v13[0] = 0x6097BF94;
  v13[1] = 0xD1C5DF9F;
  v13[2] = 0x665BB984;
  v13[3] = 0x19F53903;
  v13[4] = 0xA39D03F6;
  v13[5] = 0xB29A83A0;
  v13[6] = 0x279541FC;
  v13[7] = 0x91176528;
  v13[8] = 0x27BC8CED;
  v13[9] = 0xCA78A661;
  v13[0xA] = 0x79AF7D58;
  v13[0xB] = 0xB574C4AD;
  v13[0xC] = 0xE2E9FC5E;
  v13[0xD] = 0x55854CC0;
  v13[0xE] = 0x8526CD59;
  v13[0xF] = 0x20838AA0;
  v13[0x10] = 0xA6FCBEC6;
  v13[0x11] = 0xEC5BDB5;
  v13[0x12] = 0x970AA50;
  v13[0x13] = 0xF59B07B4;
  v13[0x14] = 0xF20149A7;
  v13[0x15] = 0x5C87D229;
  v13[0x16] = 0x87CBD88A;
  v13[0x17] = 0xD7A7E71;
  v13[0x18] = 0x4858AB7C;
  v13[0x19] = 0xA475462C;
  v13[0x1A] = 0x2978CF92;
  v13[0x1B] = 0x965272F6;
  v13[0x1C] = 0xA945B8C4;
  v13[0x1D] = 0xBA6D3440;
  v13[0x1E] = 0xB1BB63D6;
  v13[0x1F] = 0x7BC70768;
  v13[0x20] = 0x3CF4FB0B;
  v13[0x21] = 0x59ABF544;
  v13[0x22] = 0x154560BD;
  v13[0x23] = 0xED4FB77D;
  v13[0x24] = 0x42568C20;
  v13[0x25] = 0x63E28416;
  v13[0x26] = 0xF66BE812;
  v13[0x27] = 0x7A7AE09;
  v13[0x28] = 0x334E19B5;
  v13[0x29] = 0x2E4D8929;
  v13[0x2A] = 0x38C655DE;
  v13[0x2B] = 0x1743343F;
  v13[0x2C] = 0xB36F530F;
  v13[0x2D] = 0x73AF2F41;
  v13[0x2E] = 0xC5792834;
  v13[0x2F] = 0x1A9CEE1D;
  v13[0x30] = 0x387A75A9;
  v13[0x31] = 0xD7FDAB2E;
  v14 = 0xA238;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v15, 0i64, 0xCAi64);
  v2 = 0x60C5BFC8;
  for ( i = 0i64; i < 0x32; ++i )
  {
    v4 = v13[i] ^ v2;
    v2 = __ROR4__(0x43FD43FD * v2 + 0xC39EC3, 2);
    *(_DWORD *)&v15[i * 4] = v4;
  }
  for ( j = 0xC8i64; j < 0xCA; ++j )
  {
    v6 = v2;
    v2 >>= 8;
    v15[j] = *((_BYTE *)v13 + j) ^ v6;
  }
  if ( a1 )
  {
    if ( *(_DWORD *)(a1 + 0x14) == 1 && *(_DWORD *)(a1 + 0x20) > 0x18u && **(_WORD **)(a1 + 0x18) == 0x76 )
    {
      v7 = *(_QWORD *)(a1 + 8);
      if ( v7 )
      {
        v8 = *(_WORD **)(v7 + 8);
        if ( v8 )
        {
          if ( *(_WORD *)v7
            && *(_WORD *)(v7 + 2)
            && *(_WORD *)v7 == 0x4C
            && *v8 == 0x7B
            && v8[0x25] == 0x7D
            && v8[9] == 0x2D
            && v8[0xE] == 0x2D
            && v8[0x13] == 0x2D
            && v8[0x18] == 0x2D )
          {
            v9 = 1;
            for ( k = (unsigned __int8 *)(v8 + 1); ; k += 2 )
            {
              if ( v9 > 0x18 || (v11 = 0x1084200, !_bittest(&v11, v9)) )
              {
                if ( !byte_1400BCCB0[*k] )
                  break;
              }
              if ( ++v9 >= 0x25 )
                JUMPOUT(0x1400350BCi64);
            }
          }
        }
      }
    }
  }
  result = 0;
  memset(v15, 0, 0xCAui64);
  return result;
}
// 1400350B8: control flows out of bounds to 1400350BC

//----- (00000001400352E8) ----------------------------------------------------
__int64 __fastcall sub_1400352E8(__int64 a1, __int64 a2, __int64 a3, char ***a4)
{
  char v5; // bl
  char **v7; // rax
  unsigned int v8; // edx
  unsigned __int64 i; // rdi
  char v10; // al
  char v11; // dl
  char v12; // bl
  unsigned int v13; // edi
  unsigned __int64 j; // rdx
  int v15; // edx
  unsigned __int64 k; // rdi
  char v17; // al
  char v18; // dl
  unsigned int v19; // edi
  unsigned __int64 v20; // r8
  unsigned __int64 l; // rdx
  int v22; // ecx
  char v23; // dl
  char v24; // dl
  unsigned __int32 v25; // edi
  unsigned __int64 m; // r8
  char v27; // dl
  unsigned int v28; // ecx
  unsigned __int64 n; // rdi
  char v30; // dl
  __int64 result; // rax
  int v32[22]; // [rsp+20h] [rbp-E0h]
  __int16 v33; // [rsp+78h] [rbp-88h]
  int v34[19]; // [rsp+7Ah] [rbp-86h]
  int v35[20]; // [rsp+C6h] [rbp-3Ah]
  int v36[21]; // [rsp+116h] [rbp+16h]
  int v37[25]; // [rsp+16Ah] [rbp+6Ah]
  int v38[33]; // [rsp+1CEh] [rbp+CEh]
  char v39[90]; // [rsp+252h] [rbp+152h] BYREF
  char v40[76]; // [rsp+2ACh] [rbp+1ACh] BYREF
  char v41[80]; // [rsp+2F8h] [rbp+1F8h] BYREF
  char v42[84]; // [rsp+348h] [rbp+248h] BYREF
  char v43[100]; // [rsp+39Ch] [rbp+29Ch] BYREF
  char v44[192]; // [rsp+400h] [rbp+300h] BYREF

  v5 = 0;
  if ( !a4 )
    goto LABEL_37;
  if ( !a1 )
    goto LABEL_37;
  if ( ExGetPreviousMode() != 1 )
    goto LABEL_37;
  v7 = *a4;
  if ( !*a4 || !v7[1] || !*(_WORD *)v7 || !*((_WORD *)v7 + 1) )
    goto LABEL_37;
  if ( PsGetCurrentThreadId() != *(HANDLE *)(a1 + 0x20) )
    goto LABEL_12;
  v37[0] = 0x1CBE3DC5;
  v37[1] = 0x6A3C5832;
  v37[2] = 0x15FB03B;
  v37[3] = 0x52E66224;
  v37[4] = 0x6E86A845;
  v37[5] = 0x65F12F54;
  v37[6] = 0x6D38069B;
  v37[7] = 0x8BA8D365;
  v37[8] = 0xC39819BC;
  v37[9] = 0x1D260EAB;
  v37[0xA] = 0xF98A52AA;
  v37[0xB] = 0x7B307489;
  v37[0xC] = 0x37FA5E;
  v37[0xD] = 0x4F912809;
  v37[0xE] = 0xCDDD1306;
  v37[0xF] = 0x8CB5E1AA;
  v37[0x10] = 0x8754C82;
  v37[0x11] = 0x9AB6DDD5;
  v37[0x12] = 0xC8E93436;
  v37[0x13] = 0x4075870C;
  v37[0x14] = 0x259F2A91;
  v37[0x15] = 0x147A0A2A;
  v37[0x16] = 0x7DB08453;
  v37[0x17] = 0x86B265E7;
  v37[0x18] = 0xFF093A45;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v43, 0i64, 0x64i64);
  v8 = 0xAFA645AD;
  for ( i = 0i64; i < 0x19; ++i )
  {
    v8 = ~(((v8 ^ (v8 << 0xD)) >> 7) ^ v8 ^ (v8 << 0xD) ^ ((((v8 ^ (v8 << 0xD)) >> 7) ^ v8 ^ (v8 << 0xD)) << 0x11));
    *(_DWORD *)&v43[i * 4] = v37[i] ^ v8;
  }
  v5 = 1;
  v10 = sub_140006F2C(*a4, v43);
  v11 = 1;
  if ( !v10 )
LABEL_12:
    v11 = 0;
  if ( (v5 & 1) != 0 )
  {
    v5 &= 0xFEu;
    memset(v43, 0, sizeof(v43));
  }
  if ( v11 )
    goto LABEL_36;
  v36[0] = 0x6E35E12C;
  v12 = v5 | 2;
  v36[1] = 0xDDC8EDB3;
  v36[2] = 0xA96197AC;
  v36[3] = 0x1C7D84B;
  v36[4] = 0x3C6698DC;
  v36[5] = 0xB6F05FC9;
  v36[6] = 0x70C78D1B;
  v36[7] = 0xE0ACE61B;
  v36[8] = 0xE36430B0;
  v36[9] = 0xD0859E1D;
  v36[0xA] = 0xB250CB99;
  v36[0xB] = 0xD3E509A1;
  v36[0xC] = 0xC507B9FC;
  v36[0xD] = 0x7AC77A3C;
  v36[0xE] = 0x817DE3CB;
  v36[0xF] = 0xA87C9279;
  v36[0x10] = 0x5F3043D1;
  v36[0x11] = 0x6D89C375;
  v36[0x12] = 0x67A06471;
  v36[0x13] = 0x3008CF0D;
  v36[0x14] = 0xBBA8DEB9;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v42, 0i64, 0x54i64);
  v13 = 0xF7928ED4;
  for ( j = 0i64; j < 0x15; ++j )
  {
    v13 = 0xFF6D712C - 0xF793 * v13;
    *(_DWORD *)&v42[j * 4] = v36[j] ^ v13;
  }
  if ( sub_140006F2C(*a4, v42) )
    goto LABEL_22;
  v12 |= 4u;
  v34[0] = 0x6ED22021;
  v34[1] = 0x4764A6B0;
  v34[2] = 0xA497387D;
  v34[3] = 0x223B5530;
  v34[4] = 0xF5CCA79F;
  v34[5] = 0xC6937F25;
  v34[6] = 0x8AB85406;
  v34[7] = 0x4CC41E0C;
  v34[8] = 0xEFA0E248;
  v34[9] = 0xCFB4C1FC;
  v34[0xA] = 0xCCF11CD5;
  v34[0xB] = 0xD5DC1360;
  v34[0xC] = 0x5BE9845;
  v34[0xD] = 0xAD395015;
  v34[0xE] = 0xA00AD090;
  v34[0xF] = 0x263E0C3C;
  v34[0x10] = 0x1379D93A;
  v34[0x11] = 0xE0F90119;
  v34[0x12] = 0xDDC892BE;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v40, 0i64, 0x4Ci64);
  v15 = 0x2C44A6B8;
  for ( k = 0i64; k < 0x13; ++k )
  {
    v15 = __ROR4__(
            ((v15 ^ (unsigned int)(v15 << 0xD)) >> 7) ^ v15 ^ (v15 << 0xD) ^ ((((v15 ^ (unsigned int)(v15 << 0xD)) >> 7) ^ v15 ^ (v15 << 0xD)) << 0x11),
            2);
    *(_DWORD *)&v40[k * 4] = v34[k] ^ v15;
  }
  v17 = sub_140006F2C(*a4, v40);
  v18 = 0;
  if ( v17 )
LABEL_22:
    v18 = 1;
  if ( (v12 & 4) != 0 )
    memset(v40, 0, sizeof(v40));
  memset(v42, 0, sizeof(v42));
  if ( v18 )
    goto LABEL_36;
  v32[0] = 0xC3D965FA;
  v32[1] = 0x5222F72E;
  v32[2] = 0xE013DCF8;
  v32[3] = 0xC7AA2711;
  v32[4] = 0x7AB8B446;
  v32[5] = 0x8F4F69CC;
  v32[6] = 0x5EA27179;
  v32[7] = 0xA6998D73;
  v32[8] = 0xC15AFF7E;
  v32[9] = 0xB004EB3B;
  v32[0xA] = 0x9348307C;
  v32[0xB] = 0xDBE7CB93;
  v32[0xC] = 0xC4661365;
  v32[0xD] = 0x3179AF6B;
  v32[0xE] = 0x106E1CF7;
  v32[0xF] = 0x8021950C;
  v32[0x10] = 0x347E366E;
  v32[0x11] = 0xB8F28D5;
  v32[0x12] = 0xE7B694BD;
  v32[0x13] = 0x185B8FBD;
  v32[0x14] = 0xFE8B536;
  v32[0x15] = 0x89268F9B;
  v33 = 0x5B80;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v39, 0i64, 0x5Ai64);
  v19 = 0xC39465A6;
  v20 = 0x58i64;
  for ( l = 0i64; l < 0x16; ++l )
  {
    v22 = v32[l] ^ v19;
    v19 = __ROL4__(0x7E09 * v19 + 0x8F812, 3);
    *(_DWORD *)&v39[l * 4] = v22;
  }
  do
  {
    v23 = v19;
    v19 >>= 8;
    v39[v20] = *((_BYTE *)v32 + v20) ^ v23;
    ++v20;
  }
  while ( v20 < 0x5A );
  v24 = sub_140006F2C(*a4, v39);
  memset(v39, 0, sizeof(v39));
  if ( v24 )
    goto LABEL_36;
  v38[0] = 0xCB76701;
  v38[1] = 0xF56E2D2B;
  v38[2] = 0x10880D36;
  v38[3] = 0x8326B1AB;
  v38[4] = 0x41F32F7D;
  v38[5] = 0x9EFE774;
  v38[6] = 0x4633E0D7;
  v38[7] = 0xFB8101D7;
  v38[8] = 0xBF84D737;
  v38[9] = 0x2F02E1C6;
  v38[0xA] = 0x9E2F7F89;
  v38[0xB] = 0x39319C83;
  v38[0xC] = 0x6E8E4583;
  v38[0xD] = 0xD0A2004B;
  v38[0xE] = 0xAB7F43D;
  v38[0xF] = 0xDD7371DC;
  v38[0x10] = 0x6245F3E6;
  v38[0x11] = 0xFAF49B18;
  v38[0x12] = 0x2D9771CB;
  v38[0x13] = 0x418D70F3;
  v38[0x14] = 0x415E0557;
  v38[0x15] = 0x3EEC3F32;
  v38[0x16] = 0x76594039;
  v38[0x17] = 0xAFE6DA7C;
  v38[0x18] = 0x3BB33DA1;
  v38[0x19] = 0x3F8B85B7;
  v38[0x1A] = 0x1BE908B0;
  v38[0x1B] = 0x672A3B83;
  v38[0x1C] = 0x36453BA9;
  v38[0x1D] = 0x698AAFFD;
  v38[0x1E] = 0x34AE92C9;
  v38[0x1F] = 0x55019A7B;
  v38[0x20] = 0x42698410;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v44, 0i64, 0x84i64);
  v25 = 0xA47C7E57;
  for ( m = 0i64; m < 0x21; ++m )
  {
    v25 = _byteswap_ulong(((v25 ^ (v25 << 0xD)) >> 0x11) ^ v25 ^ (v25 << 0xD) ^ (0x20
                                                                               * (((v25 ^ (v25 << 0xD)) >> 0x11) ^ v25 ^ (v25 << 0xD))));
    *(_DWORD *)&v44[m * 4] = v38[m] ^ v25;
  }
  v27 = sub_140006F2C(*a4, v44);
  memset(v44, 0, 0x84ui64);
  if ( v27 )
    goto LABEL_36;
  v35[0] = 0x813CDFEC;
  v35[1] = 0x7E58F1BE;
  v35[2] = 0x59EF554E;
  v35[3] = 0xA1943D48;
  v35[4] = 0x24C8C3CE;
  v35[5] = 0xDC505163;
  v35[6] = 0x93320586;
  v35[7] = 0xDEF1EE93;
  v35[8] = 0xBFAEF4F;
  v35[9] = 0xDC443F55;
  v35[0xA] = 0x2BD40A5C;
  v35[0xB] = 0xB921372;
  v35[0xC] = 0xA99B5A4F;
  v35[0xD] = 0x5B823E1;
  v35[0xE] = 0x85D01996;
  v35[0xF] = 0xE00C51C0;
  v35[0x10] = 0x202D7CCC;
  v35[0x11] = 0x9FCEE618;
  v35[0x12] = 0x8B526D7A;
  v35[0x13] = 0x1CCBD2BC;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v41, 0i64, 0x50i64);
  v28 = 0x1C03D613;
  for ( n = 0i64; n < 0x14; ++n )
  {
    v28 = 0xFFFFCFC7 - 0x41C64E6D * v28;
    *(_DWORD *)&v41[n * 4] = v35[n] ^ v28;
  }
  v30 = sub_140006F2C(*a4, v41);
  memset(v41, 0, sizeof(v41));
  if ( v30 )
LABEL_36:
    result = 0xC0000034i64;
  else
LABEL_37:
    result = 0i64;
  return result;
}

//----- (0000000140035BE4) ----------------------------------------------------
__int64 __fastcall sub_140035BE4(_QWORD *a1, char a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, ULONG64 a8)
{
  unsigned int v11; // er14
  unsigned __int16 *v12; // r15
  __int64 v13; // rax
  __int64 v14; // rdx
  __int64 v15; // r8
  __int64 v16; // r9
  __int64 v17; // rax
  __int64 v18; // rax
  int v19; // eax
  __int64 v20; // r9
  char v21; // al
  char *v22; // rax
  char v23; // dl
  __int64 v24; // r9
  char *v25; // rax
  char v26; // dl
  __int64 v27; // rdi
  char *v28; // rax
  char v29; // dl
  char *v30; // rax
  char v31; // dl
  __int64 v32; // rax
  __int64 v33; // rdx
  __int64 v34; // rdi
  __int64 v35; // r14
  __int64 v36; // rsi
  __int64 v37; // rax
  __int64 v38; // rdx
  char v39; // si
  char *v40; // rax
  char *v41; // rax
  char *v42; // rax
  char *v43; // rax
  char *v44; // rax
  char v45; // al
  char v46; // dl
  char v47; // si
  __int64 v48; // rax
  __int64 v49; // r8
  __int64 v50; // r9
  char *v51; // rax
  char v52; // al
  char v53; // dl
  _DWORD *v54; // rsi
  unsigned int v55; // eax
  __int64 v56; // rax
  __int64 v57; // r8
  __int64 v58; // r9
  LONG v59; // edx
  __int64 v60; // rax
  __int64 v61; // r8
  __int64 v62; // r9
  LONG v63; // edx
  ULONG64 v64; // rcx
  __int64 v65; // rdx
  ULONG64 v66; // rdi
  unsigned __int64 v67; // rcx
  __int64 v69; // [rsp+28h] [rbp-4A0h] BYREF
  __int64 v70; // [rsp+30h] [rbp-498h]
  HANDLE v71; // [rsp+38h] [rbp-490h]
  __int16 v72; // [rsp+40h] [rbp-488h]
  int v73[8]; // [rsp+48h] [rbp-480h] BYREF
  int v74[9]; // [rsp+68h] [rbp-460h] BYREF
  int v75[26]; // [rsp+8Ch] [rbp-43Ch] BYREF
  int v76[9]; // [rsp+F4h] [rbp-3D4h] BYREF
  int v77[19]; // [rsp+118h] [rbp-3B0h] BYREF
  int v78[21]; // [rsp+164h] [rbp-364h] BYREF
  int v79[22]; // [rsp+1B8h] [rbp-310h] BYREF
  __int16 v80; // [rsp+210h] [rbp-2B8h]
  int v81[26]; // [rsp+212h] [rbp-2B6h] BYREF
  int v82[33]; // [rsp+27Ah] [rbp-24Eh] BYREF
  int v83[19]; // [rsp+2FEh] [rbp-1CAh] BYREF
  int v84[21]; // [rsp+34Ah] [rbp-17Eh] BYREF
  __int64 v85; // [rsp+3A0h] [rbp-128h]
  int v86[24]; // [rsp+3A8h] [rbp-120h] BYREF
  unsigned __int64 v87; // [rsp+408h] [rbp-C0h]
  char v88[144]; // [rsp+410h] [rbp-B8h] BYREF
  char v89; // [rsp+4D8h] [rbp+10h]

  v89 = a2;
  v11 = 0;
  v12 = 0i64;
  v85 = 0i64;
  if ( !a1 )
  {
    v13 = sub_14004882C();
    if ( !sub_14002FC18(v13) )
      goto LABEL_76;
  }
  if ( sub_140006EE4(*(_QWORD *)(a3 + 8)) )
    goto LABEL_76;
  v17 = sub_140034BDC(*(_QWORD *)a3, v14, v15, v16);
  v12 = (unsigned __int16 *)v17;
  v85 = v17;
  if ( !v17 )
    goto LABEL_76;
  if ( *(_QWORD *)(v17 + 8) )
  {
    if ( *(_WORD *)v17 )
    {
      if ( *(_WORD *)(v17 + 2) )
      {
        v18 = *(_QWORD *)(a3 + 8);
        if ( v18 )
        {
          if ( *(_QWORD *)(v18 + 8) && *(_WORD *)v18 && *(_WORD *)(v18 + 2) )
          {
            v19 = sub_14003D284(v12, (__int64)v73, (__int64)&v69);
            if ( v19 == 1 )
            {
              v21 = sub_14003C714(a3, (__int64)v73, (__int64)&v69, v20);
              goto LABEL_17;
            }
            if ( v19 == 2 )
            {
              v21 = sub_14003C84C(a3, (__int64)v73, (__int64)&v69);
              goto LABEL_17;
            }
          }
        }
      }
    }
  }
  v21 = 0;
LABEL_17:
  if ( v21 )
  {
    v11 = 0xC0000503;
    goto LABEL_76;
  }
  if ( a1 )
  {
    v75[0] = 0x78ABBE34;
    v75[1] = 0xCABD7DFA;
    v75[2] = 0xBF67E96;
    v75[3] = 0x428DD8A6;
    v75[4] = 0x51FF3697;
    v75[5] = 0x807A2226;
    v75[6] = 0xDB157B33;
    v75[7] = 0x48559B07;
    v75[8] = 0xE3DDD58B;
    v75[9] = 0xC6611593;
    v75[0xA] = 0x707A0E13;
    v75[0xB] = 0x9FFDA28A;
    v75[0xC] = 0x3E48E4D3;
    v75[0xD] = 0x56023B2C;
    v75[0xE] = 0x7AB604D5;
    v75[0xF] = 0x8A41C36C;
    v75[0x10] = 0x58E4134C;
    v75[0x11] = 0x46BE722;
    v75[0x12] = 0x83BB82D8;
    v75[0x13] = 0x4F7236D2;
    v75[0x14] = 0x4E904223;
    v75[0x15] = 0xF113E5EA;
    v75[0x16] = 0x3E2C45ED;
    v75[0x17] = 0xE95A8E8;
    v75[0x18] = 0x58ADB28D;
    v75[0x19] = 0x15C628F6;
    v22 = (char *)sub_140036B94((__int64)v75, (__int64)v81);
    v23 = sub_140006F2C((char **)v12, v22);
    memset(v81, 0, sizeof(v81));
    if ( v23 )
    {
      if ( !sub_140034C4C(*(PVOID *)a3, *(_QWORD *)(a3 + 8), (__int64)&v69, v24, 0, v69, v70, v71) )
      {
LABEL_29:
        if ( a2 )
        {
          v34 = a1[1];
          v35 = sub_140048808();
          v36 = ((__int64 (__fastcall *)(__int64, _QWORD, _QWORD))loc_14001561C)(v34, 0i64, 0i64);
          if ( (v36 & 0x880000002000000i64) == 0 )
          {
            v37 = ((__int64 (__fastcall *)(__int64, _QWORD, _QWORD))loc_14001561C)(v35, 0i64, 0i64) & 0x880000002000000i64;
            if ( v37 )
            {
              LOBYTE(v38) = 1;
              ((void (__fastcall *)(__int64, __int64, __int64))loc_14001561C)(v34, v38, v36 | v37);
            }
          }
        }
LABEL_75:
        v11 = 0xC0000034;
        goto LABEL_76;
      }
      v86[0] = 0x2AEA0D23;
      v86[1] = 0x59377C8;
      v86[2] = 0x271BE681;
      v86[3] = 0x2A7B28F0;
      v86[4] = 0xF0A5EF8C;
      v86[5] = 0xED9F90E4;
      v86[6] = 0x503C4774;
      v86[7] = 0x801E2CC6;
      v86[8] = 0x1A492FED;
      v86[9] = 0x9C9F814A;
      v86[0xA] = 0x49D502AE;
      v86[0xB] = 0x5E9A4B11;
      LOWORD(v86[0xC]) = 0xBAEA;
      v25 = (char *)((__int64 (__fastcall *)(int *, int *))dword_140036C0C)(v86, v84);
      v26 = sub_140006F2C((char **)&v69, v25);
      memset(v84, 0, 0x32ui64);
      if ( v26 )
      {
        v27 = 0x880000000000000i64;
      }
      else
      {
        v73[0] = 0xE17EF8ED;
        v73[1] = 0xD5B20D60;
        v73[2] = 0x6EB576E7;
        v73[3] = 0x87F7577E;
        v73[4] = 0xCC8F44FB;
        LOWORD(v73[5]) = 0x1129;
        v28 = (char *)((__int64 (__fastcall *)(int *, int *))loc_140036CA4)(v73, v74);
        v29 = sub_140006F2C((char **)&v69, v28);
        memset(v74, 0, 0x16ui64);
        if ( v29 )
        {
          v27 = 0x80000000000000i64;
        }
        else
        {
          v74[0] = 0xB362CDD7;
          v74[1] = 0xF32E27C;
          v74[2] = 0x5E4A0684;
          v74[3] = 0xE4DB7D7B;
          v74[4] = 0xDF44BAE0;
          v74[5] = 0x6F3D03AF;
          LOWORD(v74[6]) = 0x5345;
          v30 = (char *)((__int64 (__fastcall *)(int *, int *))loc_140036D28)(v74, v73);
          v31 = sub_140006F2C((char **)&v69, v30);
          memset(v73, 0, 0x1Aui64);
          v27 = v31 != 0 ? 0x2000000 : 0;
          if ( !v31 )
          {
LABEL_28:
            sub_14000724C((__int64)&v69);
            goto LABEL_29;
          }
        }
      }
      v32 = ((__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))loc_14001561C)(a1[1], 0i64, 0i64);
      LOBYTE(v33) = 1;
      ((void (__fastcall *)(_QWORD, __int64, __int64))loc_14001561C)(a1[1], v33, v27 | v32);
      goto LABEL_28;
    }
    v81[0] = 0x406E7371;
    v81[1] = 0x7C3DC98E;
    v81[2] = 0x13C3296C;
    v81[3] = 0x59B6BDCF;
    v81[4] = 0x4FB7EEF8;
    v81[5] = 0x3B6CF959;
    v81[6] = 0x83A21C5D;
    v81[7] = 0x87F51027;
    v81[8] = 0xB59A6F36;
    v81[9] = 0xCE23A5B5;
    v81[0xA] = 0x6FE68C54;
    v81[0xB] = 0xB5EA35BD;
    v81[0xC] = 0x3A7F4A3D;
    v81[0xD] = 0x26503E18;
    v81[0xE] = 0x4EDB7C47;
    v81[0xF] = 0x8926D45E;
    v81[0x10] = 0x2B4C10AD;
    v81[0x11] = 0xB01A4174;
    v81[0x12] = 0xBD96B892;
    v81[0x13] = 0x72125F44;
    v81[0x14] = 0xB921AC84;
    v81[0x15] = 0x265BE174;
    v81[0x16] = 0xA2E6DE7B;
    v81[0x17] = 0x4E1FC302;
    v81[0x18] = 0x37CD8407;
    v39 = 1;
    v40 = (char *)sub_140036DBC((__int64)v81, (__int64)v75);
    if ( sub_140006F2C((char **)v12, v40) )
      goto LABEL_38;
    v78[0] = 0x521E462E;
    v78[1] = 0x847A2395;
    v78[2] = 0xF44867EE;
    v78[3] = 0x47B4DBAE;
    v78[4] = 0xA64029F7;
    v78[5] = 0x6573D799;
    v78[6] = 0xC1EECDF0;
    v78[7] = 0x2674F810;
    v78[8] = 0x2F6B37A6;
    v78[9] = 0x7E4B5632;
    v78[0xA] = 0x33FD1782;
    v78[0xB] = 0x2681D802;
    v78[0xC] = 0x6B4C1F31;
    v78[0xD] = 0x772D370B;
    v78[0xE] = 0x42CB8923;
    v78[0xF] = 0x6F4A581;
    v78[0x10] = 0x573530E1;
    v78[0x11] = 0x225AD2A3;
    v78[0x12] = 0x6C9E929A;
    v78[0x13] = 0xEB6037A9;
    v78[0x14] = 0xBBF8D96C;
    v39 = 3;
    v41 = (char *)sub_140036E28((__int64)v78, (__int64)v84);
    if ( sub_140006F2C((char **)v12, v41) )
      goto LABEL_38;
    v77[0] = 0xA2A52FA9;
    v77[1] = 0x1FE08BFC;
    v77[2] = 0x65572043;
    v77[3] = 0x2628997D;
    v77[4] = 0xD4D08E6C;
    v77[5] = 0xA11C1D7;
    v77[6] = 0xE3AF07B7;
    v77[7] = 0x880C5D73;
    v77[8] = 0x4AB9DDD2;
    v77[9] = 0xBECCE644;
    v77[0xA] = 0xD0CBB098;
    v77[0xB] = 0x5EEE2135;
    v77[0xC] = 0xE5A29AA4;
    v77[0xD] = 0x70CEE9F8;
    v77[0xE] = 0xC42F38C8;
    v77[0xF] = 0x9EE264D2;
    v77[0x10] = 0xC3E0E31B;
    v77[0x11] = 0x416E11EC;
    v77[0x12] = 0xC9EB67C9;
    v39 = 7;
    v42 = (char *)sub_140036EA0((__int64)v77, (__int64)v83);
    if ( sub_140006F2C((char **)v12, v42) )
      goto LABEL_38;
    v79[0] = 0x4EB553A7;
    v79[1] = 0xA2D64E0;
    v79[2] = 0x7F300A55;
    v79[3] = 0x79FF6889;
    v79[4] = 0x7F99C301;
    v79[5] = 0xB61507A2;
    v79[6] = 0xD432611C;
    v79[7] = 0x78E3AB70;
    v79[8] = 0x6495D60;
    v79[9] = 0xD482412C;
    v79[0xA] = 0x3DF06624;
    v79[0xB] = 0x2728B79E;
    v79[0xC] = 0x266C1B0;
    v79[0xD] = 0x47ECE8E1;
    v79[0xE] = 0xB9FD43AA;
    v79[0xF] = 0x1197C1FD;
    v79[0x10] = 0x3BC4A566;
    v79[0x11] = 0x1C2A62B4;
    v79[0x12] = 0xCB1EF6ED;
    v79[0x13] = 0xB0F66763;
    v79[0x14] = 0x2FCA5ABD;
    v79[0x15] = 0x83ACBE92;
    v80 = 0x92C4;
    v39 = 0xF;
    v43 = (char *)sub_140036F0C((__int64)v79, (__int64)v86);
    if ( sub_140006F2C((char **)v12, v43) )
      goto LABEL_38;
    v82[0] = 0x68D11F12;
    v82[1] = 0x6310074E;
    v82[2] = 0x86B81AC0;
    v82[3] = 0x215E6920;
    v82[4] = 0x70E9150;
    v82[5] = 0xD443BC83;
    v82[6] = 0xC3215BB3;
    v82[7] = 0x21BC8CAF;
    v82[8] = 0x8DFE1BE9;
    v82[9] = 0xDA1EBC37;
    v82[0xA] = 0xE8CC79D6;
    v82[0xB] = 0xECCB4580;
    v82[0xC] = 0x6A3166F4;
    v82[0xD] = 0x23BBFCAA;
    v82[0xE] = 0x9D915BDE;
    v82[0xF] = 0xD1AA4C5E;
    v82[0x10] = 0x1C18999D;
    v82[0x11] = 0x5AEEF768;
    v82[0x12] = 0xE8E06A0E;
    v82[0x13] = 0x7AC0D85E;
    v82[0x14] = 0xE9DD5DB1;
    v82[0x15] = 0xAAD5A29F;
    v82[0x16] = 0xE0708D13;
    v82[0x17] = 0x620CA1CE;
    v82[0x18] = 0x6614DA7B;
    v82[0x19] = 0xBA0E7792;
    v82[0x1A] = 0xB32B2D57;
    v82[0x1B] = 0x4AFCE0CA;
    v82[0x1C] = 0xF620B748;
    v82[0x1D] = 0x8BB36EE0;
    v82[0x1E] = 0x6DD9313E;
    v82[0x1F] = 0xE79A4D74;
    v82[0x20] = 0xEBEA1CFD;
    v39 = 0x1F;
    v44 = (char *)sub_140036FB0((__int64)v82, (__int64)v88);
    v45 = sub_140006F2C((char **)v12, v44);
    v46 = 0;
    if ( v45 )
LABEL_38:
      v46 = 1;
    if ( (v39 & 0x10) != 0 )
    {
      v39 &= 0xEFu;
      memset(v88, 0, 0x84ui64);
    }
    if ( (v39 & 8) != 0 )
    {
      v39 &= 0xF7u;
      memset(v86, 0, 0x5Aui64);
    }
    if ( (v39 & 4) != 0 )
    {
      v39 &= 0xFBu;
      memset(v83, 0, sizeof(v83));
    }
    if ( (v39 & 2) != 0 )
    {
      v39 &= 0xFDu;
      memset(v84, 0, sizeof(v84));
    }
    if ( (v39 & 1) != 0 )
    {
      v39 &= 0xFEu;
      memset(v75, 0, 0x64ui64);
    }
    if ( v46 )
      goto LABEL_75;
    if ( !v89 )
    {
      v76[0] = 0x20AA6B1A;
      v76[1] = 0x17843F71;
      v76[2] = 0xB51A02C5;
      v76[3] = 0xC05D24D3;
      v76[4] = 0x1065131C;
      v76[5] = 0xE02D77D5;
      v76[6] = 0x624A6C59;
      v76[7] = 0xE8FBA1A0;
      v76[8] = 0x6D504ACC;
      v47 = v39 | 0x20;
      v48 = ((__int64 (__fastcall *)(int *, int *))qword_140037020[0])(v76, v74);
      LOBYTE(v49) = 1;
      if ( sub_140006F00(*(_QWORD *)(a3 + 8), v48, v49, v50) )
        goto LABEL_53;
      v84[0] = 0xAB678623;
      v84[1] = 0x27992B66;
      v84[2] = 0x2B6A6512;
      v84[3] = 0x5B9C592D;
      v84[4] = 0x6A4A7C75;
      v84[5] = 0x7878B76E;
      v84[6] = 0x67C7891C;
      v84[7] = 0x727906C5;
      v84[8] = 0x6A4F636A;
      v84[9] = 0xE341A7E2;
      v84[0xA] = 0xB89AF6D6;
      v84[0xB] = 0xF0CAD822;
      LOWORD(v84[0xC]) = 0x2942;
      v47 |= 0x40u;
      v51 = (char *)((__int64 (__fastcall *)(int *, int *))dword_140037074)(v84, v86);
      v52 = sub_140006F2C((char **)v12, v51);
      v53 = 1;
      if ( !v52 )
LABEL_53:
        v53 = 0;
      if ( (v47 & 0x40) != 0 )
      {
        v47 &= 0xBFu;
        memset(v86, 0, 0x32ui64);
      }
      if ( (v47 & 0x20) != 0 )
        memset(v74, 0, sizeof(v74));
      if ( v53 )
        goto LABEL_75;
      if ( *(_DWORD *)(a3 + 0x10) == 2 )
      {
        v54 = *(_DWORD **)(a3 + 0x18);
        if ( v54 )
        {
          v55 = *(_DWORD *)(a3 + 0x20);
          if ( v55 >= 0x10 )
          {
            LODWORD(a8) = v55 - 0x10;
            v83[0] = 0x3188BFFC;
            v83[1] = 0x98D8A90A;
            v83[2] = 0x2006E48C;
            v83[3] = 0x4D4B2C24;
            v83[4] = 0x4209589;
            v83[5] = 0x3B04C5BC;
            v83[6] = 0xDB9A4130;
            v83[7] = 0x731902DC;
            v83[8] = 0xF35DA422;
            v83[9] = 0x25AD41B1;
            v83[0xA] = 0xBDB6D3CC;
            v83[0xB] = 0xADCA534C;
            v83[0xC] = 0x3AD3CA2F;
            v56 = ((__int64 (__fastcall *)(int *, int *))dword_14003710C)(v83, v84);
            LOBYTE(v57) = 1;
            v59 = sub_140006F00(*(_QWORD *)(a3 + 8), v56, v57, v58);
            memset(v84, 0, 0x34ui64);
            if ( !v59 )
            {
              if ( (unsigned int)a8 < 4 )
              {
                v54[2] = 0;
                v11 = 0xC0000023;
              }
              else
              {
                v54[2] = 4;
                v54[3] = 1;
                v11 = 0xC0000503;
              }
              v54[1] = 4;
              **(_DWORD **)(a3 + 0x28) = 0x14;
              goto LABEL_76;
            }
            v69 = 0x23F703D956654D19i64;
            v70 = 0x1DB92C39886C5C90i64;
            v71 = (HANDLE)0xE0D9E677308BD799i64;
            v72 = 0x6CA9;
            v60 = ((__int64 (__fastcall *)(__int64 *, int *))loc_140037164)(&v69, v74);
            LOBYTE(v61) = 1;
            v63 = sub_140006F00(*(_QWORD *)(a3 + 8), v60, v61, v62);
            memset(v74, 0, 0x1Aui64);
            if ( !v63 )
            {
              if ( sub_14004882C() != a1[2] )
                goto LABEL_75;
              v64 = a1[0x2C];
              if ( !v64 )
                goto LABEL_75;
              sub_14005221C(v64, 0x3Ci64, 1);
              v65 = a1[0x2C];
              v66 = 0i64;
              a8 = 0i64;
              if ( v65 )
              {
                v67 = 0i64;
                v87 = 0i64;
                while ( v67 < 8 )
                {
                  *((_BYTE *)&a8 + v67) = *(_BYTE *)(v65 + 4 * v67 + 0x1C) ^ 0x90;
                  v87 = ++v67;
                  v66 = a8;
                }
              }
              sub_14005221C(v66, 0x28i64, 1);
              if ( PsGetCurrentThreadId() != (HANDLE)*(unsigned int *)(v66 + 0xC) )
                goto LABEL_75;
            }
          }
        }
      }
    }
  }
LABEL_76:
  if ( v12 )
    sub_140051220((__int64)v12);
  return v11;
}
// 140035C52: variable 'v14' is possibly undefined
// 140035C52: variable 'v15' is possibly undefined
// 140035C52: variable 'v16' is possibly undefined
// 140035CD6: variable 'v20' is possibly undefined
// 140035E5C: variable 'v24' is possibly undefined
// 14003603E: variable 'v33' is possibly undefined
// 1400360A6: variable 'v38' is possibly undefined
// 1400367FE: variable 'v49' is possibly undefined
// 1400367FE: variable 'v50' is possibly undefined
// 1400369E9: variable 'v57' is possibly undefined
// 1400369E9: variable 'v58' is possibly undefined
// 140036A9C: variable 'v61' is possibly undefined
// 140036A9C: variable 'v62' is possibly undefined
// 140036C0C: using guessed type int dword_140036C0C;
// 140037020: using guessed type __int64 qword_140037020[4];
// 140037074: using guessed type int dword_140037074;
// 14003710C: using guessed type int dword_14003710C;

//----- (0000000140036B94) ----------------------------------------------------
__int64 __fastcall sub_140036B94(__int64 a1, __int64 a2)
{
  unsigned int v4; // er8
  unsigned __int64 i; // rdx
  __int64 result; // rax

  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x68i64);
  v4 = 0x6314586D;
  for ( i = 0i64; i < 0x68; i += 4i64 )
  {
    v4 = __ROR4__(((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7) ^ ((((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7)) >> 0xD), 3);
    result = a2;
    *(_DWORD *)(a2 + i) = *(_DWORD *)(a1 + i) ^ v4;
  }
  return result;
}

//----- (0000000140036DBC) ----------------------------------------------------
__int64 __fastcall sub_140036DBC(__int64 a1, __int64 a2)
{
  int v4; // er8
  unsigned __int64 i; // rdx
  __int64 result; // rax

  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x64i64);
  v4 = 0x3828D2CA;
  for ( i = 0i64; i < 0x64; i += 4i64 )
  {
    v4 = __ROL4__(0x343FD * v4 + 0x269EC3, 3);
    result = a2;
    *(_DWORD *)(a2 + i) = *(_DWORD *)(a1 + i) ^ v4;
  }
  return result;
}

//----- (0000000140036E28) ----------------------------------------------------
__int64 __fastcall sub_140036E28(__int64 a1, __int64 a2)
{
  unsigned int v4; // er8
  unsigned __int64 i; // rdx
  __int64 result; // rax

  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x54i64);
  v4 = 0x7F8AE6CE;
  for ( i = 0i64; i < 0x54; i += 4i64 )
  {
    v4 = __ROL4__(((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7) ^ ((((v4 ^ (v4 >> 7)) << 9) ^ v4 ^ (v4 >> 7)) >> 0xD), 2);
    result = a2;
    *(_DWORD *)(a2 + i) = *(_DWORD *)(a1 + i) ^ v4;
  }
  return result;
}

//----- (0000000140036EA0) ----------------------------------------------------
__int64 __fastcall sub_140036EA0(__int64 a1, __int64 a2)
{
  unsigned int v4; // er8
  unsigned __int64 i; // rdx
  __int64 result; // rax

  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x4Ci64);
  v4 = 0x9ABD9E42;
  for ( i = 0i64; i < 0x4C; i += 4i64 )
  {
    v4 = __ROL4__(0x343FD * v4 + 0x269EC3, 2);
    result = a2;
    *(_DWORD *)(a2 + i) = *(_DWORD *)(a1 + i) ^ v4;
  }
  return result;
}

//----- (0000000140036F0C) ----------------------------------------------------
__int64 __fastcall sub_140036F0C(__int64 a1, __int64 a2)
{
  unsigned __int64 v4; // rdx
  unsigned int v5; // er8
  unsigned __int64 v6; // r9
  char v7; // cl
  __int64 result; // rax

  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x5Ai64);
  v4 = 0i64;
  v5 = 0x4EF853FB;
  v6 = 0x58i64;
  do
  {
    *(_DWORD *)(a2 + v4) = *(_DWORD *)(a1 + v4) ^ v5;
    v4 += 4i64;
    v5 = __ROL4__(((v5 ^ (v5 >> 7)) << 9) ^ v5 ^ (v5 >> 7) ^ ((((v5 ^ (v5 >> 7)) << 9) ^ v5 ^ (v5 >> 7)) >> 0xD), 1);
  }
  while ( v4 < 0x58 );
  do
  {
    v7 = v5;
    v5 >>= 8;
    result = a2;
    *(_BYTE *)(a2 + v6) = *(_BYTE *)(a1 + v6) ^ v7;
    ++v6;
  }
  while ( v6 < 0x5A );
  return result;
}

//----- (0000000140036FB0) ----------------------------------------------------
__int64 __fastcall sub_140036FB0(__int64 a1, __int64 a2)
{
  unsigned int v4; // er8
  unsigned __int64 i; // rdx
  __int64 result; // rax

  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x84i64);
  v4 = 0xC212A35B;
  for ( i = 0i64; i < 0x84; i += 4i64 )
  {
    v4 = 0xFFD9613D - 0x343FD * v4;
    result = a2;
    *(_DWORD *)(a2 + i) = *(_DWORD *)(a1 + i) ^ v4;
  }
  return result;
}

//----- (00000001400371F8) ----------------------------------------------------
__int64 __fastcall sub_1400371F8(__int64 a1, __int64 a2, __int64 a3)
{
  int v4; // edi
  __int64 v5; // rax
  __int64 v6; // rax
  __int64 v7; // rdx
  __int64 *v8; // rbx
  __int64 v9; // r9
  __int64 v10; // rax
  __int64 v11; // rax
  __int64 v12; // r15
  __int64 *i; // rax
  __int64 *v14; // rbx
  int v15; // edi
  int v16; // edi
  int v17; // edi
  char ***v18; // r9
  __int64 v19; // r8
  int v20; // eax
  __int64 v22; // [rsp+20h] [rbp-28h]
  __int64 v23; // [rsp+28h] [rbp-20h]
  __int64 v24; // [rsp+30h] [rbp-18h]
  ULONG64 v25; // [rsp+38h] [rbp-10h]

  v4 = a2;
  LODWORD(v22) = 0;
  if ( !a2 || !a3 )
    return (unsigned int)v22;
  v5 = sub_140048808();
  v6 = sub_14004888C(v5);
  v8 = sub_140062BF4(v6);
  if ( !v8 )
  {
    v10 = sub_140048808();
    v11 = sub_14004888C(v10);
    v12 = v11;
    if ( dword_1400DB428 && v11 && KeGetCurrentIrql() <= 1u )
    {
      ExAcquireFastMutex(&stru_1400DB2C8);
      for ( i = (__int64 *)qword_1400DB418; i != &qword_1400DB418; i = (__int64 *)*i )
      {
        v14 = i + 0xFFFFFFB4;
        if ( i[0xFFFFFFB7i64] == v12 )
          goto LABEL_13;
      }
      v14 = 0i64;
LABEL_13:
      if ( v14 && !*((_BYTE *)v14 + 0x25C) )
        ++*((_DWORD *)v14 + 0x96);
      ExReleaseFastMutex(&stru_1400DB2C8);
      JUMPOUT(0x1400372E9i64);
    }
    v8 = 0i64;
  }
  v15 = v4 - 1;
  if ( !v15 )
  {
    if ( dword_1400D82EC > 0 )
    {
      sub_140034D98(a3);
      JUMPOUT(0x140037354i64);
    }
    LODWORD(v22) = 0;
    goto LABEL_31;
  }
  v16 = v15 - 7;
  if ( v16 )
  {
    v17 = v16 - 4;
    if ( v17 )
    {
      if ( v17 != 0x10 )
        goto LABEL_31;
      v18 = (char ***)a3;
      v19 = 0i64;
    }
    else
    {
      v18 = 0i64;
      v19 = a3;
    }
    LOBYTE(v7) = 0;
    v20 = sub_1400352E8((__int64)v8, v7, v19, v18);
  }
  else
  {
    v20 = sub_140035BE4(v8, 0, a3, v9, v22, v23, v24, v25);
  }
  LODWORD(v22) = v20;
LABEL_31:
  if ( v8 )
    sub_140062D30((__int64)v8);
  return (unsigned int)v22;
}
// 1400372E6: control flows out of bounds to 1400372E9
// 140037352: control flows out of bounds to 140037354
// 14003731A: variable 'v7' is possibly undefined
// 14003732E: variable 'v9' is possibly undefined
// 14003732E: variable 'v22' is possibly undefined
// 14003732E: variable 'v23' is possibly undefined
// 14003732E: variable 'v24' is possibly undefined
// 14003732E: variable 'v25' is possibly undefined
// 1400D82EC: using guessed type int dword_1400D82EC;
// 1400DB418: using guessed type __int64 qword_1400DB418;
// 1400DB428: using guessed type int dword_1400DB428;

//----- (0000000140037538) ----------------------------------------------------
char __fastcall sub_140037538(unsigned int *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, PVOID Object)
{
  __int64 v7; // rdi
  __int64 v9; // rcx
  char v10[56]; // [rsp+30h] [rbp-38h] BYREF

  v7 = 0i64;
  if ( !a1 )
    return 0;
  sub_14005221C((ULONG64)a1, 0x10i64, 1);
  if ( !*a1 || !*(_QWORD *)(a1 + 1) || !a1[3] )
    return 0;
  if ( (int)sub_1400488FC(*a1, (__int64)&Object) >= 0 )
  {
    if ( sub_140015378((__int64)Object, (__int64)v10) )
    {
      LOBYTE(v9) = 1;
      v7 = ((__int64 (__fastcall *)(__int64))loc_14000E260)(v9);
      ((void (__fastcall *)(PVOID, char *))loc_140015528)(Object, v10);
    }
    ObfDereferenceObject(Object);
  }
  if ( v7 )
  {
    sub_14005221C(*(_QWORD *)(a1 + 1), a1[3], 1);
    JUMPOUT(0x140037609i64);
  }
  return 0;
}
// 140037607: control flows out of bounds to 140037609
// 1400375B4: variable 'v9' is possibly undefined

//----- (0000000140037BC0) ----------------------------------------------------
void sub_140037BC0()
{
  JUMPOUT(0x140037BD5i64);
}
// 140037BD1: control flows out of bounds to 140037BD5

//----- (0000000140037D0C) ----------------------------------------------------
#error "140037D50: call analysis failed (funcsize=23)"

//----- (0000000140037D6C) ----------------------------------------------------
char __fastcall sub_140037D6C(__int64 a1)
{
  if ( !a1 || !dword_1400DAC84 || KeGetCurrentIrql() > 1u )
    return 0;
  if ( sub_140051084(0x18ui64) )
    JUMPOUT(0x140037DC9i64);
  return 0;
}
// 140037DC3: control flows out of bounds to 140037DC9
// 1400DAC84: using guessed type int dword_1400DAC84;

//----- (0000000140037EE8) ----------------------------------------------------
void sub_140037EE8()
{
  bool v0; // zf
  bool v1; // bl
  __int64 *v2; // rbx
  struct _KEVENT *v3; // rcx
  __int64 v4; // rax
  __int64 v5; // rbx

  if ( dword_1400DAC84 )
  {
    ExAcquireFastMutex(&stru_1400DACA0);
    v0 = dword_1400DAC84 == 1;
    dword_1400DAC84 = 2;
    v1 = v0;
    ExReleaseFastMutex(&stru_1400DACA0);
    if ( v1 )
    {
      v2 = (__int64 *)qword_1400DAC90;
      if ( (__int64 *)qword_1400DAC90 != &qword_1400DAC90 )
      {
        do
        {
          v3 = (struct _KEVENT *)v2[2];
          if ( v3 )
            KeSetEvent(v3 + 3, 0, 0);
          v2 = (__int64 *)*v2;
        }
        while ( v2 != &qword_1400DAC90 );
        while ( 1 )
        {
          v5 = qword_1400DAC90;
          if ( (__int64 *)qword_1400DAC90 == &qword_1400DAC90 )
            break;
          v4 = *(_QWORD *)qword_1400DAC90;
          if ( *(__int64 **)(qword_1400DAC90 + 8) != &qword_1400DAC90 || *(_QWORD *)(v4 + 8) != qword_1400DAC90 )
            __fastfail(3u);
          qword_1400DAC90 = *(_QWORD *)qword_1400DAC90;
          *(_QWORD *)(v4 + 8) = &qword_1400DAC90;
          ((void (__fastcall *)(_QWORD))loc_140069B20)(*(_QWORD *)(v5 + 0x10));
          sub_140051220(v5);
        }
      }
    }
  }
}
// 1400DAC84: using guessed type int dword_1400DAC84;
// 1400DAC90: using guessed type __int64 qword_1400DAC90;

//----- (00000001400383D8) ----------------------------------------------------
__int64 __fastcall sub_1400383D8(__int64 a1, unsigned int a2, __int64 a3, char a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, __int64 a9)
{
  __int64 (__fastcall *v13)(__int64, _QWORD, __int64, __int64); // rax

  v13 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DACF8,
                                                                     &qword_1400DACF8,
                                                                     0i64);
  if ( !v13 )
    return 0xC0000002i64;
  LOBYTE(a9) = a4;
  return v13(a1, a2, a3, a9);
}
// 1400DACF8: using guessed type __int64 qword_1400DACF8;

//----- (0000000140038450) ----------------------------------------------------
__int64 __fastcall sub_140038450(__int64 a1, __int64 a2)
{
  __int64 (__fastcall *v4)(__int64, __int64, _QWORD, _QWORD); // rax
  __int64 result; // rax

  v4 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                   qword_1400DAD20,
                                                                   &qword_1400DAD20,
                                                                   0i64);
  if ( v4 )
    result = v4(a1, a2, 0i64, 0i64);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DAD20: using guessed type __int64 qword_1400DAD20;

//----- (00000001400384B8) ----------------------------------------------------
__int64 __fastcall sub_1400384B8(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  __int64 (__fastcall *v7)(__int64, _QWORD, _QWORD, _QWORD); // rax
  __int64 result; // rax

  v7 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                  qword_1400DAD28,
                                                                  &qword_1400DAD28,
                                                                  0i64);
  if ( v7 )
    result = v7(a1, a2, 0i64, a4);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DAD28: using guessed type __int64 qword_1400DAD28;

//----- (0000000140038530) ----------------------------------------------------
__int64 __fastcall sub_140038530(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAD10,
                                          &qword_1400DAD10,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAD10: using guessed type __int64 qword_1400DAD10;

//----- (0000000140038568) ----------------------------------------------------
char __fastcall sub_140038568(__int64 a1, __int64 *a2)
{
  unsigned __int64 v4; // rbp
  unsigned __int64 v5; // rsi
  _BYTE *v6; // rax
  _BYTE *v7; // rcx
  unsigned __int64 v8; // rdx
  __int64 v9; // r15
  char v10; // al

  if ( !a1 || !a2 )
    return 0;
  v4 = 0xFFFFFFFFFFFFFFFFui64;
  do
    ++v4;
  while ( *(_BYTE *)(a1 + v4) );
  v5 = v4 + 1;
  if ( v4 + 1 > 1 )
  {
    v6 = (_BYTE *)sub_140051084(v4 + 1);
    *a2 = (__int64)v6;
    v7 = v6;
    if ( v6 )
    {
      if ( v5 <= 0x7FFFFFFF )
      {
        v8 = 0x7FFFFFFE - v5;
        v9 = a1 - (_QWORD)v6;
        do
        {
          if ( !(v8 + v5) )
            break;
          v10 = v7[v9];
          if ( !v10 )
            break;
          *v7++ = v10;
          --v5;
        }
        while ( v5 );
        JUMPOUT(0x14003860Ci64);
      }
      *v6 = 0;
      sub_140051220(*a2);
      *a2 = 0i64;
    }
  }
  return 0;
}
// 140038608: control flows out of bounds to 14003860C

//----- (0000000140038678) ----------------------------------------------------
bool __fastcall sub_140038678(_BYTE *a1, int a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9)
{
  unsigned __int64 v12; // r8
  unsigned int v13; // edx
  unsigned __int64 v14; // rdi
  char v15; // cl
  bool v16; // dl
  __int64 v18; // [rsp+20h] [rbp-30h]
  __int64 v19; // [rsp+28h] [rbp-28h]
  __int64 v20; // [rsp+30h] [rbp-20h]
  _BYTE v21[11]; // [rsp+38h] [rbp-18h] BYREF
  __int16 v22; // [rsp+43h] [rbp-Dh]
  char v23; // [rsp+45h] [rbp-Bh]

  if ( !a1 || !*a1 || !a3 )
    return 0;
  v20 = 0xEFD3FD11D14F79A1ui64;
  *(_QWORD *)&v21[3] = 0i64;
  v12 = 0i64;
  v22 = 0;
  v13 = 0xBE610A84;
  v23 = 0;
  *(_WORD *)v21 = 0x3E94;
  v14 = 8i64;
  v21[2] = 0x7F;
  do
  {
    *(_DWORD *)&v21[v12 + 3] = *(_DWORD *)((char *)&v20 + v12) ^ v13;
    v12 += 4i64;
    v13 = ~(((v13 ^ (v13 << 0xD)) >> 0x11) ^ v13 ^ (v13 << 0xD) ^ (0x20
                                                                 * (((v13 ^ (v13 << 0xD)) >> 0x11) ^ v13 ^ (v13 << 0xD))));
  }
  while ( v12 < 8 );
  do
  {
    v15 = v13;
    v13 >>= 8;
    v21[v14 + 3] = *((_BYTE *)&v20 + v14) ^ v15;
    ++v14;
  }
  while ( v14 < 0xB );
  LODWORD(v19) = a9 != 0 ? 0 : 0x2C;
  LODWORD(v18) = a2;
  v16 = (int)sub_140034AD0(a3, 0x100i64, (__int64)&v21[3], (__int64)a1, v18, v19, v20, *(__int64 *)v21) >= 0;
  memset(&v21[3], 0, 0xBui64);
  return v16;
}
// 14003876C: variable 'v18' is possibly undefined
// 14003876C: variable 'v19' is possibly undefined

//----- (0000000140038794) ----------------------------------------------------
bool __fastcall sub_140038794(_BYTE *a1, _BYTE *a2, _BYTE *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, char a9)
{
  int v10; // edi
  unsigned __int64 i; // r8
  bool v12; // cf
  int v13; // edx
  bool v14; // si
  _BYTE *v15; // rdi
  __int64 v17; // [rsp+28h] [rbp-18h]

  a8 = a4;
  if ( !a1 || !*a1 || !a2 || !*a2 || !a3 )
    return 0;
  a8 = 0xBF75627892D1C32Dui64;
  a5 = 0i64;
  v10 = 0x11A57974;
  for ( i = 0i64; i < 8; i += 4i64 )
  {
    v10 = __ROR4__(
            ((v10 ^ (unsigned int)(v10 << 0xD)) >> 0x11) ^ v10 ^ (v10 << 0xD) ^ (0x20
                                                                               * (((v10 ^ (unsigned int)(v10 << 0xD)) >> 0x11) ^ v10 ^ (v10 << 0xD))),
            1);
    *(_DWORD *)((char *)&a5 + i) = *(_DWORD *)((char *)&a8 + i) ^ v10;
  }
  v12 = a9 != 0;
  a9 = -a9;
  LODWORD(v17) = v12 ? 0 : 0x2C;
  v13 = sub_140034AD0(a3, 0x100i64, (__int64)&a5, (__int64)a1, (__int64)a2, v17, (__int64)&a8, (__int64)&a5);
  v14 = v13 >= 0;
  memset(&a5, 0, sizeof(a5));
  if ( v13 >= 0 )
  {
    v15 = a3;
    do
    {
      if ( !*v15 )
        break;
      *v15 = tolower((char)*v15);
      ++v15;
    }
    while ( (unsigned __int64)(v15 - a3) < 0x100 );
  }
  return v14;
}
// 140038859: variable 'v17' is possibly undefined

//----- (00000001400388B0) ----------------------------------------------------
char __fastcall sub_1400388B0(unsigned __int64 a1, char a2, unsigned int *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9, _WORD *a10)
{
  __int64 v14; // r13
  int *v15; // rsi
  unsigned int v17; // eax
  unsigned int v18; // ecx
  unsigned __int64 v19; // r8
  unsigned int *v20; // r14
  unsigned __int64 v21; // rdi
  unsigned __int64 v22; // rax
  __int64 v23; // r9
  _BYTE *v24; // r15
  unsigned __int64 v25; // rcx
  int v26; // eax
  __int64 v27; // rax
  int *v28; // rdi
  int *v29; // rdx
  int v30; // ecx
  bool v31; // al
  __int64 v32; // rdx
  bool v33; // al
  unsigned __int64 v34; // r8
  __int64 *i; // rax
  __int64 v36; // rcx
  __int64 *v37; // rdi
  bool v38; // r8
  bool v39; // al
  unsigned __int64 v40; // r8
  __int64 v41; // [rsp+20h] [rbp-218h]
  __int64 v42; // [rsp+28h] [rbp-210h]
  __int64 v43; // [rsp+30h] [rbp-208h]
  __int64 v44; // [rsp+38h] [rbp-200h]
  char v45; // [rsp+40h] [rbp-1F8h]
  unsigned __int64 v46; // [rsp+60h] [rbp-1D8h]
  unsigned __int64 v47; // [rsp+68h] [rbp-1D0h]
  int v48[40]; // [rsp+70h] [rbp-1C8h] BYREF
  char v49[296]; // [rsp+110h] [rbp-128h] BYREF
  char v50; // [rsp+248h] [rbp+10h]
  __int64 v51; // [rsp+258h] [rbp+20h]

  v51 = a4;
  v50 = a2;
  LOBYTE(v43) = 0;
  ((void (__fastcall *)(int *, _QWORD, __int64))loc_14006F2C0)(v48, 0i64, 0x98i64);
  a9 = 0i64;
  v14 = 0i64;
  v44 = 0i64;
  v15 = 0i64;
  v45 = 0;
  if ( !a1 || !a3 || !a4 )
    return 0;
  if ( a2 == 0x20 )
  {
    v17 = a3[0x20];
    v18 = a3[0x21];
  }
  else
  {
    if ( a2 != 0x40 )
      return 0;
    v17 = a3[0x24];
    v18 = a3[0x25];
  }
  v19 = a3[0x14];
  v47 = v19;
  v20 = (unsigned int *)(a1 + v17);
  v21 = v19 + a1;
  v46 = v19 + a1;
  if ( !v19 || v18 < 0x14ui64 || (unsigned __int64)v20 <= a1 || (unsigned __int64)v20 + v18 > v21 )
    return 0;
  v48[2] = 0x67452301;
  v48[3] = 0xEFCDAB89;
  v48[4] = 0x98BADCFE;
  v48[5] = 0x10325476;
  v48[0] = 0;
  v48[1] = 0;
  while ( 1 )
  {
    v22 = v20[3];
    if ( !(_DWORD)v22 )
      break;
    if ( v22 <= v19 )
    {
      if ( sub_140038568(a1 + (unsigned int)v22, (__int64 *)&a9) )
      {
        v24 = a9;
        v25 = 0xFFFFFFFFFFFFFFFFui64;
        do
          ++v25;
        while ( a9[v25] );
        if ( v25 > 4 )
        {
          v26 = *(_DWORD *)&a9[v25 - 4];
          if ( v26 == 0x78636F2E || v26 == 0x7379732E || v26 == 0x6C6C642E )
            a9[v25 - 4] = 0;
        }
        v27 = *v20;
        if ( (_DWORD)v27 || (v27 = v20[4], (_DWORD)v27) )
        {
          v15 = (int *)(a1 + v27);
          v45 = a1 + v27;
        }
        if ( v15 && (unsigned __int64)v15 < v21 )
        {
          if ( v50 == 0x20 )
          {
            v28 = v15;
            while ( 1 )
            {
              v29 = v28;
              v30 = *v28;
              if ( !*v28 )
                break;
              ++v28;
              v31 = !*v28 && !v20[8];
              v32 = (unsigned int)*v29;
              LOBYTE(v41) = v31;
              if ( v30 >= 0 )
                v33 = sub_140038794(v24, (_BYTE *)(a1 + v32 + 2), v49, v23, v41, v42, v43, v44, v45);
              else
                v33 = sub_140038678(v24, v32, v49, v23, v41, v42, v43, v44, v45);
              if ( v33 )
              {
                v34 = 0xFFFFFFFFFFFFFFFFui64;
                do
                  ++v34;
                while ( v49[v34] );
                sub_1400082A0(v48, v49);
                v44 = ++v14;
              }
            }
          }
          else if ( v50 == 0x40 )
          {
            for ( i = (__int64 *)v15; ; i = v37 )
            {
              v36 = *i;
              if ( !*i )
                break;
              v37 = i + 1;
              v38 = !i[1] && !v20[8];
              LOBYTE(v41) = v38;
              if ( v36 >= 0 )
                v39 = sub_140038794(v24, (_BYTE *)(a1 + v36 + 2), v49, v23, v41, v42, v43, v44, v45);
              else
                v39 = sub_140038678(v24, v36, v49, v23, v41, v42, v43, v44, v45);
              if ( v39 )
              {
                v40 = 0xFFFFFFFFFFFFFFFFui64;
                do
                  ++v40;
                while ( v49[v40] );
                sub_1400082A0(v48, v49);
                v44 = ++v14;
              }
            }
          }
        }
        sub_140051220((__int64)v24);
        v21 = v46;
      }
      v19 = v47;
    }
    v20 += 5;
  }
  if ( v14 )
  {
    sub_14000835C(v48, v51);
    if ( a10 )
      *a10 = v14;
    LOBYTE(v43) = 1;
  }
  return v43;
}
// 140038AB2: variable 'v23' is possibly undefined
// 140038AB2: variable 'v41' is possibly undefined
// 140038AB2: variable 'v42' is possibly undefined
// 140038AB2: variable 'v43' is possibly undefined
// 140038AB2: variable 'v44' is possibly undefined
// 140038AB2: variable 'v45' is possibly undefined
// 1400082A0: using guessed type __int64 __fastcall sub_1400082A0(_QWORD, _QWORD);
// 14000835C: using guessed type __int64 __fastcall sub_14000835C(_QWORD, _QWORD);

//----- (0000000140038FB8) ----------------------------------------------------
char __fastcall sub_140038FB8(unsigned __int16 *a1, __int64 a2)
{
  char result; // al
  __int64 v4; // r8
  __int64 v5; // rcx
  _WORD *v6; // r11
  unsigned __int64 i; // rdx
  unsigned __int64 v8; // r10
  unsigned __int16 v9[4]; // [rsp+20h] [rbp-18h] BYREF
  __int64 v10; // [rsp+28h] [rbp-10h]

  result = 0;
  if ( a1 && a2 )
  {
    v4 = (__int64)(a1 + 1);
    v5 = *a1;
    if ( v4 )
    {
      v6 = (_WORD *)v4;
      for ( i = (unsigned __int64)(unsigned int)v5 >> 1; i; --i )
      {
        if ( !*v6 )
          break;
        ++v6;
      }
      if ( i )
        v8 = ((unsigned __int64)(unsigned int)v5 >> 1) - i;
      else
        v8 = 0i64;
      if ( i )
        v5 = 2 * v8;
    }
    if ( v5 )
    {
      v10 = v4;
      v9[0] = v5;
      v9[1] = v5;
      if ( v4 )
      {
        if ( (_WORD)v5 )
          result = sub_140007178(a2, v9, v5);
      }
    }
    else
    {
      *(_DWORD *)a2 = 0;
      *(_QWORD *)(a2 + 8) = 0i64;
      result = 1;
    }
  }
  return result;
}

//----- (000000014003927C) ----------------------------------------------------
void __fastcall sub_14003927C(__int64 a1)
{
  _WORD *v2; // rcx
  _WORD *v3; // rcx
  _WORD *v4; // rcx

  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) && *(_WORD *)a1 && *(_WORD *)(a1 + 2) )
      sub_14000724C(a1);
    v2 = (_WORD *)(a1 + 0x10);
    if ( a1 != 0xFFFFFFFFFFFFFFF0ui64 && *(_QWORD *)(a1 + 0x18) && *v2 && *(_WORD *)(a1 + 0x12) )
      sub_14000724C((__int64)v2);
    v3 = (_WORD *)(a1 + 0x20);
    if ( a1 != 0xFFFFFFFFFFFFFFE0ui64 && *(_QWORD *)(a1 + 0x28) && *v3 && *(_WORD *)(a1 + 0x22) )
      sub_14000724C((__int64)v3);
    v4 = (_WORD *)(a1 + 0x30);
    if ( a1 != 0xFFFFFFFFFFFFFFD0ui64 && *(_QWORD *)(a1 + 0x38) && *v4 )
    {
      if ( *(_WORD *)(a1 + 0x32) )
        sub_14000724C((__int64)v4);
    }
  }
}

//----- (0000000140039538) ----------------------------------------------------
void __fastcall sub_140039538(__int64 a1)
{
  _WORD *v2; // rcx
  _WORD *v3; // rcx
  _WORD *v4; // rcx
  _WORD *v5; // rcx

  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) && *(_WORD *)a1 && *(_WORD *)(a1 + 2) )
      sub_14000724C(a1);
    v2 = (_WORD *)(a1 + 0x10);
    if ( a1 != 0xFFFFFFFFFFFFFFF0ui64 && *(_QWORD *)(a1 + 0x18) && *v2 && *(_WORD *)(a1 + 0x12) )
      sub_14000724C((__int64)v2);
    v3 = (_WORD *)(a1 + 0x20);
    if ( a1 != 0xFFFFFFFFFFFFFFE0ui64 && *(_QWORD *)(a1 + 0x28) && *v3 && *(_WORD *)(a1 + 0x22) )
      sub_14000724C((__int64)v3);
    v4 = (_WORD *)(a1 + 0x30);
    if ( a1 != 0xFFFFFFFFFFFFFFD0ui64 && *(_QWORD *)(a1 + 0x38) && *v4 && *(_WORD *)(a1 + 0x32) )
      sub_14000724C((__int64)v4);
    v5 = (_WORD *)(a1 + 0x40);
    if ( a1 != 0xFFFFFFFFFFFFFFC0ui64 && *(_QWORD *)(a1 + 0x48) && *v5 )
    {
      if ( *(_WORD *)(a1 + 0x42) )
        sub_14000724C((__int64)v5);
    }
  }
}

//----- (000000014003981C) ----------------------------------------------------
char __fastcall sub_14003981C(__int64 a1, __int64 a2, void *a3)
{
  if ( a3 )
    memset(a3, 0, 0x200ui64);
  return 0;
}
// 1400398D4: control flows out of bounds to 1400398DA
// 140039C41: control flows out of bounds to 140039C46
// 140039CC2: control flows out of bounds to 140039CC6
// 140039DA4: control flows out of bounds to 140039DA8
// 140039F8F: control flows out of bounds to 140039F93
// 14003A1D5: control flows out of bounds to 14003A1D7
// 14003A244: control flows out of bounds to 14003A248
// 14003A567: control flows out of bounds to 14003A56C
// 14003A5DE: control flows out of bounds to 14003A5E2
// 14003A735: control flows out of bounds to 14003A739
// 14003AACD: control flows out of bounds to 14003AAD2
// 14003AB50: control flows out of bounds to 14003AB55
// 14003ADC2: control flows out of bounds to 14003ADC7
// 14003AE22: control flows out of bounds to 14003AE26
// 14003AEC4: control flows out of bounds to 14003AEC9
// 14003B153: control flows out of bounds to 14003B155
// 14003B1CE: control flows out of bounds to 14003B1D3
// 14003B49E: control flows out of bounds to 14003B4A5
// 14003988B: control flows out of bounds to 140039EC3
// 14003985E: conditional instruction was optimized away because of 'ecx.4==0'
// 140039867: conditional instruction was optimized away because of 'ecx.4==0'
// 140039870: conditional instruction was optimized away because of 'ecx.4==0'
// 140039879: conditional instruction was optimized away because of 'ecx.4==0'
// 140039882: conditional instruction was optimized away because of 'ecx.4==0'
// 14003988B: conditional instruction was optimized away because of 'ecx.4==0'
// 140039894: conditional instruction was optimized away because of 'ecx.4==0'
// 14003989D: conditional instruction was optimized away because of 'ecx.4==0'
// 1400398A6: conditional instruction was optimized away because of 'ecx.4==0'
// 1400398AF: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A6DB: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A6E4: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A6ED: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A6F6: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A6FF: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A708: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A711: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A71A: conditional instruction was optimized away because of 'ecx.4==0'
// 14003A723: conditional instruction was optimized away because of 'ecx.4==0'

//----- (000000014003B930) ----------------------------------------------------
char __fastcall sub_14003B930(__int64 a1)
{
  __int64 v3; // rax
  int v4[6]; // [rsp+38h] [rbp-C8h] BYREF
  char v5[72]; // [rsp+50h] [rbp-B0h] BYREF
  int v6; // [rsp+98h] [rbp-68h]
  char v7[2]; // [rsp+C0h] [rbp-40h] BYREF

  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v7, 0i64, 0x80i64);
  if ( a1 )
  {
    v4[0] = 0x67452301;
    v4[1] = 0xEFCDAB89;
    v4[2] = 0x98BADCFE;
    v4[3] = 0x10325476;
    v4[4] = 0xC3D2E1F0;
    ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v5, 0i64, 0x48i64);
    v6 = 0;
    v3 = sub_140003C4C((__int64)v4, 0xFFFFF78000000274ui64, 0x40ui64);
    sub_140003B10(v3);
    JUMPOUT(0x14003B9D3i64);
  }
  return 0;
}
// 14003B9CF: control flows out of bounds to 14003B9D3

//----- (000000014003C698) ----------------------------------------------------
char __fastcall sub_14003C698(__int64 a1, __int64 a2)
{
  __int64 v4; // rdi
  unsigned int v5; // ecx
  unsigned __int64 v6; // rax
  unsigned int v7; // edx
  char result; // al

  if ( *(_DWORD *)(a1 + 0x10) != 2 )
    return 0;
  v4 = *(_QWORD *)(a1 + 0x18);
  if ( !v4 )
    return 0;
  v5 = *(_DWORD *)(a1 + 0x20);
  if ( v5 <= 0x10 )
    return 0;
  v6 = 0xFFFFFFFFFFFFFFFFui64;
  do
    ++v6;
  while ( *(_WORD *)(a2 + 2 * v6) );
  v7 = 2 * v6 + 2;
  if ( v7 > v5 - 0x10 )
    return 0;
  *(_DWORD *)(v4 + 8) = v7;
  *(_DWORD *)(v4 + 4) = 1;
  ((void (__fastcall *)(__int64, __int64, _QWORD))loc_14006F000)(v4 + 0xC, a2, v7);
  result = 1;
  **(_DWORD **)(a1 + 0x28) = *(_DWORD *)(v4 + 8) + 0x10;
  return result;
}

//----- (000000014003C714) ----------------------------------------------------
char __fastcall sub_14003C714(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 v4; // rbx
  __int64 *v5; // rsi
  unsigned __int64 v7; // rdi
  unsigned __int64 i; // rbx

  v4 = a3;
  v5 = (__int64 *)off_1400D8090;
  v7 = 0i64;
  while ( 1 )
  {
    LOBYTE(a3) = 1;
    if ( !sub_140006F00(v4, *v5, a3, a4) )
      break;
    v7 += 0x78i64;
    v5 += 0xF;
    if ( v7 >= 0xF0 )
      return 0;
  }
  for ( i = 0i64; i < 0xE; i += 2i64 )
  {
    LOBYTE(a3) = 1;
    if ( !sub_140006F00(a2, v5[i + 1], a3, a4) )
      JUMPOUT(0x14003C7AEi64);
  }
  return 0;
}
// 14003C7AB: control flows out of bounds to 14003C7AE
// 14003C74A: variable 'a3' is possibly undefined
// 14003C74A: variable 'a4' is possibly undefined
// 1400D8090: using guessed type wchar_t *off_1400D8090[30];

//----- (000000014003C84C) ----------------------------------------------------
char __fastcall sub_14003C84C(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // r9
  unsigned int v5; // edx
  unsigned __int64 v6; // rdi
  unsigned __int64 i; // r8
  unsigned __int64 j; // r8
  char v9; // cl
  char v10; // si
  __int64 v11; // r9
  unsigned int v12; // edx
  unsigned __int64 k; // r8
  int v14; // ecx
  unsigned __int64 l; // r8
  char v16; // cl
  __int64 v17; // r9
  unsigned int v18; // edx
  unsigned __int64 m; // r8
  char v20; // cl
  char v21; // dl
  int v23[18]; // [rsp+AAh] [rbp-5Eh]
  __int16 v24; // [rsp+F2h] [rbp-16h]
  int v25[18]; // [rsp+F4h] [rbp-14h]
  __int16 v26; // [rsp+13Ch] [rbp+34h]
  int v27[18]; // [rsp+13Eh] [rbp+36h]
  __int16 v28; // [rsp+186h] [rbp+7Eh]
  char v29[74]; // [rsp+2EAh] [rbp+1E2h] BYREF
  char v30[74]; // [rsp+334h] [rbp+22Ch] BYREF
  char v31[74]; // [rsp+37Eh] [rbp+276h] BYREF

  v23[0] = 0x154BCCC7;
  v23[1] = 0xD9DFA695;
  v23[2] = 0x9448FFEA;
  v23[3] = 0xB7C79CB4;
  v23[4] = 0xB2A27BA9;
  v23[5] = 0x6B2913B7;
  v23[6] = 0xDCAFCB77;
  v23[7] = 0x55284F64;
  v23[8] = 0x9A7B8C25;
  v23[9] = 0x2A6E199E;
  v23[0xA] = 0x7B72762A;
  v23[0xB] = 0xD2041567;
  v23[0xC] = 0x481FDB0E;
  v23[0xD] = 0xBD8949A2;
  v23[0xE] = 0xC5EED695;
  v23[0xF] = 0x197E3347;
  v23[0x10] = 0x214F7136;
  v23[0x11] = 0x81CBF3FF;
  v24 = 0x76BC;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v31, 0i64, 0x4Ai64);
  v5 = 0x157DCC84;
  v6 = 0x48i64;
  for ( i = 0i64; i < 0x12; ++i )
  {
    *(_DWORD *)&v31[i * 4] = v23[i] ^ v5;
    v5 = __ROL4__(((v5 ^ (v5 >> 7)) << 9) ^ v5 ^ (v5 >> 7) ^ ((((v5 ^ (v5 >> 7)) << 9) ^ v5 ^ (v5 >> 7)) >> 0xD), 3);
  }
  for ( j = 0x48i64; j < 0x4A; ++j )
  {
    v9 = v5;
    v5 >>= 8;
    v31[j] = *((_BYTE *)v23 + j) ^ v9;
  }
  v10 = 1;
  LOBYTE(j) = 1;
  if ( !sub_140006F00(a3, (__int64)v31, j, v4) )
    goto LABEL_16;
  v25[0] = 0xC65E00F6;
  v26 = 0x8F32;
  v25[1] = 0x23D01B61;
  v25[2] = 0x3E11EB03;
  v25[3] = 0x7A8FDAE6;
  v25[4] = 0xB542299F;
  v25[5] = 0x302B9617;
  v25[6] = 0xAD7C5C0B;
  v25[7] = 0x568B2DE3;
  v25[8] = 0x65622F6;
  v25[9] = 0x8986817F;
  v25[0xA] = 0x7EF11D71;
  v25[0xB] = 0xC8FC70E5;
  v25[0xC] = 0x65EFEB82;
  v25[0xD] = 0xF3F7DC11;
  v25[0xE] = 0x2FF32E06;
  v25[0xF] = 0xE42FA391;
  v25[0x10] = 0xE10D848B;
  v25[0x11] = 0x1268A717;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v30, 0i64, 0x4Ai64);
  v12 = 0xC61B00B2;
  for ( k = 0i64; k < 0x12; ++k )
  {
    v14 = v25[k] ^ v12;
    v12 = ~(0x343FD * v12 + 0x269EC3);
    *(_DWORD *)&v30[k * 4] = v14;
  }
  for ( l = 0x48i64; l < 0x4A; ++l )
  {
    v16 = v12;
    v12 >>= 8;
    v30[l] = *((_BYTE *)v25 + l) ^ v16;
  }
  LOBYTE(l) = 1;
  v10 = 3;
  if ( !sub_140006F00(a3, (__int64)v30, l, v11) )
    goto LABEL_16;
  v27[0] = 0x6D9E02B3;
  v28 = 0x7932;
  v27[1] = 0x98AA6D87;
  v27[2] = 0xB0845DF8;
  v27[3] = 0xFCC12A59;
  v27[4] = 0x8944E;
  v27[5] = 0xE6A6D2C2;
  v27[6] = 0x95873B41;
  v27[7] = 0xA5A7CC53;
  v27[8] = 0x87F7BB06;
  v27[9] = 0x85903A60;
  v27[0xA] = 0x70D842A3;
  v27[0xB] = 0x228E7938;
  v27[0xC] = 0xBB97AEFD;
  v27[0xD] = 0x86F4C600;
  v27[0xE] = 0x45139EEA;
  v27[0xF] = 0x3EDECBD2;
  v27[0x10] = 0x87187ED2;
  v27[0x11] = 0xB05E4296;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v29, 0i64, 0x4Ai64);
  v18 = 0x6DDC028A;
  for ( m = 0i64; m < 0x48; m += 4i64 )
  {
    *(_DWORD *)&v29[m] = *(int *)((char *)v27 + m) ^ v18;
    v18 = __ROR4__(
            ((v18 ^ (v18 >> 7)) << 9) ^ v18 ^ (v18 >> 7) ^ ((((v18 ^ (v18 >> 7)) << 9) ^ v18 ^ (v18 >> 7)) >> 0xD),
            2);
  }
  do
  {
    v20 = v18;
    v18 >>= 8;
    v29[v6] = *((_BYTE *)v27 + v6) ^ v20;
    ++v6;
  }
  while ( v6 < 0x4A );
  LOBYTE(m) = 1;
  v10 = 7;
  if ( sub_140006F00(a3, (__int64)v29, m, v17) )
  {
    v21 = 1;
  }
  else
  {
LABEL_16:
    v21 = 0;
    if ( (v10 & 4) == 0 )
      goto LABEL_18;
  }
  memset(v29, 0, sizeof(v29));
LABEL_18:
  if ( (v10 & 2) != 0 )
    memset(v30, 0, sizeof(v30));
  memset(v31, 0, sizeof(v31));
  if ( !v21 )
    JUMPOUT(0x14003CCA5i64);
  return 0;
}
// 14003CCA0: control flows out of bounds to 14003CCA5
// 14003C9C5: variable 'v4' is possibly undefined
// 14003CB03: variable 'v11' is possibly undefined
// 14003CC46: variable 'v17' is possibly undefined

//----- (000000014003D284) ----------------------------------------------------
__int64 __fastcall sub_14003D284(unsigned __int16 *a1, __int64 a2, __int64 a3)
{
  unsigned __int16 v4; // di
  __int64 v7; // rcx
  __int64 v8; // rbx
  unsigned int v9; // edx
  unsigned __int64 i; // rdi
  int v11; // ecx
  unsigned __int64 v12; // rdi
  unsigned int v13; // er12
  char v14; // cl
  char *v15; // r14
  char *v16; // r8
  char *v17; // r8
  unsigned int v18; // edi
  unsigned __int64 j; // r9
  char *v20; // r8
  __int64 v21; // rax
  unsigned __int64 v22; // rax
  unsigned __int64 v23; // rcx
  __int64 result; // rax
  bool v25; // zf
  __int16 v26; // bx
  int v27[20]; // [rsp+28h] [rbp-D8h]
  __int16 v28; // [rsp+78h] [rbp-88h]
  int v29[22]; // [rsp+7Ah] [rbp-86h]
  char v30[82]; // [rsp+D2h] [rbp-2Eh] BYREF
  char v31[140]; // [rsp+124h] [rbp+24h] BYREF
  unsigned __int64 v32; // [rsp+1C0h] [rbp+C0h]

  v4 = *a1 >> 1;
  if ( v4 < 0x40u )
    return 0i64;
  v7 = *((_QWORD *)a1 + 1);
  if ( *(_WORD *)(v7 + 2i64 * v4 - 0x4C) != 0x7B )
    return 0i64;
  v32 = v4;
  if ( *(_WORD *)(v7 + 2i64 * v4 - 2) != 0x7D )
    return 0i64;
  v27[0] = 0xA73000D;
  v27[1] = 0x7084C0F7;
  v27[2] = 0x6B30EE25;
  v27[3] = 0x9D55B5C9;
  v27[4] = 0xACB7C76C;
  v27[5] = 0xAB82556D;
  v27[6] = 0x734AFC0A;
  v27[7] = 0x4D36CBF5;
  v27[8] = 0x32ECBA0D;
  v27[9] = 0x2727D32C;
  v27[0xA] = 0x66A2E24B;
  v27[0xB] = 0x5E81214E;
  v27[0xC] = 0x96471264;
  v27[0xD] = 0x837FD749;
  v27[0xE] = 0xE5C6EC1D;
  v27[0xF] = 0x8373CA57;
  v27[0x10] = 0x28B4F20E;
  v27[0x11] = 0xBBB174D8;
  v27[0x12] = 0x1FDEDD6;
  v27[0x13] = 0xD6F9E95A;
  v28 = 0xAD7A;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v30, 0i64, 0x52i64);
  v8 = 0i64;
  v9 = 0xA3E0051;
  for ( i = 0i64; i < 0x14; ++i )
  {
    v11 = v27[i] ^ v9;
    v9 = __ROR4__(0x194B * v9 + 0x4A092C, 4);
    *(_DWORD *)&v30[i * 4] = v11;
  }
  v12 = 0x50i64;
  v13 = 1;
  do
  {
    v14 = v9;
    v9 >>= 8;
    v30[v12] = *((_BYTE *)v27 + v12) ^ v14;
    ++v12;
  }
  while ( v12 < 0x52 );
  v15 = (char *)*((_QWORD *)a1 + 1);
  v16 = sub_140007598(v15, v30, v32);
  memset(v30, 0, sizeof(v30));
  if ( !v16 )
  {
    v29[0] = 0x2ACE6877;
    v29[1] = 0x547A1A21;
    v29[2] = 0x7FDACD8F;
    v29[3] = 0x86D96D6A;
    v29[4] = 0x57D1F09;
    v29[5] = 0xD73537D2;
    v29[6] = 0x309CF671;
    v29[7] = 0x4CEED167;
    v29[8] = 0xD5C3A880;
    v29[9] = 0xC6BDA38C;
    v29[0xA] = 0x260B4529;
    v29[0xB] = 0x17326E2E;
    v29[0xC] = 0xCB0CEDB8;
    v29[0xD] = 0xDF31EE5F;
    v29[0xE] = 0x4B83A04B;
    v29[0xF] = 0x230E6EB0;
    v29[0x10] = 0x58146BAD;
    v29[0x11] = 0x11325783;
    v29[0x12] = 0x8F90110B;
    v29[0x13] = 0xCDC1B4A4;
    v29[0x14] = 0xEE879A28;
    v29[0x15] = 0x78E03E49;
    ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v31, 0i64, 0x58i64);
    v18 = 0xC83AB1CE;
    for ( j = 0i64; j < 0x16; ++j )
    {
      v18 = __ROR4__(0x343FD * v18 + 0x269EC3, 3);
      *(_DWORD *)&v31[j * 4] = v29[j] ^ v18;
    }
    v15 = (char *)*((_QWORD *)a1 + 1);
    v20 = sub_140007598(v15, v31, v32);
    memset(v31, 0, 0x58ui64);
    if ( v20 )
    {
      v13 = 2;
      v17 = v20 + 0x56;
      goto LABEL_14;
    }
    return 0i64;
  }
  v17 = v16 + 0x50;
LABEL_14:
  v21 = *a1 - (_QWORD)v17;
  *(_WORD *)a2 = 0;
  v22 = (unsigned __int64)&v15[v21] >> 1;
  if ( !v22 )
    return 0i64;
  while ( 1 )
  {
    v23 = v8 + 1;
    if ( *(_WORD *)&v17[2 * v8] == 0x5C )
      break;
    ++v8;
    if ( v23 >= v22 )
      return 0i64;
  }
  v25 = 2 * (_WORD)v8 == 0;
  v26 = 2 * v8;
  *(_QWORD *)(a2 + 8) = v17;
  *(_WORD *)a2 = v26;
  *(_WORD *)(a2 + 2) = v26;
  if ( v25 || v22 - v23 < 0x26 || *(_WORD *)&v17[2 * v23] != 0x7B || *(_WORD *)&v17[2 * v23 + 0x4A] != 0x7D )
    return 0i64;
  *(_DWORD *)a3 = 0x480048;
  result = v13;
  *(_QWORD *)(a3 + 8) = &v17[2 * v23 + 2];
  return result;
}

//----- (000000014003E9D8) ----------------------------------------------------
__int64 __fastcall sub_14003E9D8(__int64 a1)
{
  __int64 (__fastcall *v3)(); // rax
  __int64 v4; // rcx
  _DWORD *v5; // rax

  if ( !a1 )
    return 0xFFFFFFFEi64;
  *(_DWORD *)(a1 + 0x48) = 0;
  *(_DWORD *)(a1 + 0x4C) = 0;
  *(_QWORD *)(a1 + 0x20) = 0i64;
  *(_DWORD *)(a1 + 0xC) = 0;
  *(_DWORD *)(a1 + 0x1C) = 0;
  *(_DWORD *)(a1 + 0x50) = 0;
  v3 = *(__int64 (__fastcall **)())(a1 + 0x30);
  if ( !v3 )
  {
    *(_QWORD *)(a1 + 0x30) = sub_14003E9C4;
    v3 = sub_14003E9C4;
  }
  if ( !*(_QWORD *)(a1 + 0x38) )
    *(_QWORD *)(a1 + 0x38) = sub_14003E9D0;
  v4 = *(_QWORD *)(a1 + 0x40);
  if ( v3 == sub_14003E9C4 )
    v5 = (_DWORD *)sub_140051084(0xAB10ui64);
  else
    v5 = (_DWORD *)((__int64 (__fastcall *)(__int64, __int64, __int64))v3)(v4, 1i64, 0xAB10i64);
  if ( !v5 )
    return 0xFFFFFFFCi64;
  *(_QWORD *)(a1 + 0x28) = v5;
  *v5 = 0;
  v5[0xABE] = 0;
  v5[0xABF] = 0;
  v5[0xAC1] = 0;
  v5[0x2AC3] = 1;
  v5[0xAC0] = 1;
  v5[0xAC2] = 0xFFFFFFF1;
  return 0i64;
}
// 14003E9C4: using guessed type __int64 __fastcall sub_14003E9C4();
// 14003E9D0: using guessed type __int64 __fastcall sub_14003E9D0();

//----- (000000014003EAA0) ----------------------------------------------------
__int64 __fastcall sub_14003EAA0(__int64 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  _DWORD *v8; // rsi
  int v9; // eax
  __int64 v10; // r9
  __int64 v11; // rdx
  int v12; // eax
  unsigned int v13; // edx
  int v14; // ecx
  unsigned int v15; // edx
  __int64 v17; // rdx
  unsigned int v18; // edx

  if ( !a1 )
    return 0xFFFFFFFEi64;
  v8 = (_DWORD *)a1[5];
  if ( !v8 )
    return 0xFFFFFFFEi64;
  v9 = v8[0xAC0];
  v8[0xAC0] = 0;
  if ( (int)v8[0x2AC3] < 0 )
    return 0xFFFFFFFDi64;
  v8[0xAC1] |= 1u;
  if ( !v9 )
  {
    if ( v8[0xABF] )
      JUMPOUT(0x14003EBA6i64);
    a7 = *((unsigned int *)a1 + 2);
    v17 = *a1;
    a5 = (unsigned int)(0x8000 - v8[0xABE]);
    v8[0x2AC3] = ((__int64 (__fastcall *)(_DWORD, _DWORD, unsigned int, int, __int64, unsigned int))sub_14003ED2C)(
                   (_DWORD)v8,
                   v17,
                   (unsigned int)&a7,
                   (int)v8 + 0x2B0C,
                   (__int64)v8 + (unsigned int)v8[0xABE] + 0x2B0C,
                   (unsigned int)&a5);
    v18 = a7;
    *((_DWORD *)a1 + 2) -= a7;
    *((_DWORD *)a1 + 3) += v18;
    *a1 += v18;
    *((_DWORD *)a1 + 0x13) = v8[7];
    v8[0xABF] = a5;
    JUMPOUT(0x14003EC85i64);
  }
  v10 = a1[2];
  v11 = *a1;
  a7 = *((unsigned int *)a1 + 2);
  a5 = *((unsigned int *)a1 + 6);
  v12 = ((__int64 (__fastcall *)(_DWORD, _DWORD, unsigned int, _DWORD, __int64, unsigned int))sub_14003ED2C)(
          (_DWORD)v8,
          v11,
          (unsigned int)&a7,
          v10,
          v10,
          (unsigned int)&a5);
  v8[0x2AC3] = v12;
  v13 = a7;
  *((_DWORD *)a1 + 2) -= a7;
  *((_DWORD *)a1 + 3) += v13;
  *a1 += v13;
  v14 = v8[7];
  v15 = a5;
  *((_DWORD *)a1 + 6) -= a5;
  *((_DWORD *)a1 + 7) += v15;
  *((_DWORD *)a1 + 0x13) = v14;
  a1[2] += v15;
  if ( v12 < 0 )
    return 0xFFFFFFFDi64;
  if ( !v12 )
    return 1i64;
  v8[0x2AC3] = 0xFFFFFFFF;
  return 0xFFFFFFFBi64;
}
// 14003EBA4: control flows out of bounds to 14003EBA6
// 14003EC83: control flows out of bounds to 14003EC85
// 14003ED2C: using guessed type __int64 __fastcall __far sub_14003ED2C(_DWORD, _DWORD, _DWORD, _DWORD, __int64, _DWORD);

//----- (000000014003ED2C) ----------------------------------------------------
#error "14003ED2C: function frame is wrong (funcsize=0)"

//----- (00000001400402AC) ----------------------------------------------------
__int64 __fastcall sub_1400402AC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  __int64 v5; // rbx
  __int64 v6; // rbp
  __int64 v7; // r14
  __int64 v8; // rdx
  __int64 v9; // r8
  __int64 v10; // r9
  struct _FAST_MUTEX *v11; // r13
  unsigned int v12; // eax
  __int64 v13; // rdi
  unsigned int v14; // eax
  unsigned int v15; // esi
  unsigned int v16; // er15
  __int64 *v17; // r12
  __int64 v18; // rsi
  __int64 *v19; // r15
  __int64 v20; // r12
  unsigned int v21; // esi
  __int64 v22; // rax
  unsigned int v23; // edx
  _QWORD *v24; // rcx
  PVOID *v25; // rsi
  void *v27; // [rsp+20h] [rbp-28h]

  v5 = 0i64;
  v6 = sub_140051084(0x1000ui64);
  if ( v6 )
  {
    v7 = sub_140051084(0x1000ui64);
    if ( v7 )
    {
      v11 = (struct _FAST_MUTEX *)sub_14001F828(1);
      if ( v11 )
      {
        v12 = sub_140014384(v6, v8, v9, v10, v27);
        v13 = v12;
        if ( v12 )
        {
          v14 = sub_140014308(v7, 0x200i64);
          v15 = v14;
          if ( v14 )
          {
            if ( (_DWORD)v13 != 0x200 && v14 != 0x200 )
            {
              v16 = 0;
              v17 = (__int64 *)v7;
              while ( sub_14001F904(v11, *v17, 0i64, 0) )
              {
                ++v16;
                ++v17;
                if ( v16 >= v15 )
                {
                  v18 = 0i64;
                  if ( (_DWORD)v13 )
                  {
                    v19 = (__int64 *)v6;
                    while ( 1 )
                    {
                      v20 = sub_14004888C(*v19);
                      if ( (int)sub_1400488FC(v20, (__int64)&Object) < 0 )
                        break;
                      ObfDereferenceObject(Object);
                      if ( !sub_14001FAD4(v11, v20) )
                        break;
                      v18 = (unsigned int)(v18 + 1);
                      ++v19;
                      if ( (unsigned int)v18 >= (unsigned int)v13 )
                        goto LABEL_25;
                    }
                    v5 = *(_QWORD *)(v6 + 8 * v18);
                    if ( v5 )
                    {
                      v21 = sub_140014308(v7, 0x200i64);
                      if ( v21 )
                      {
                        v22 = sub_14004888C(v5);
                        v23 = 0;
                        v24 = (_QWORD *)v7;
                        while ( *v24 != v22 )
                        {
                          ++v23;
                          ++v24;
                          if ( v23 >= v21 )
                          {
                            if ( sub_140013D4C(v5) )
                              goto LABEL_25;
                            break;
                          }
                        }
                      }
                      v5 = 0i64;
                    }
                  }
                  break;
                }
              }
            }
          }
        }
LABEL_25:
        sub_14001FBDC(v11);
      }
      else
      {
        v13 = (unsigned int)Object;
      }
      sub_140051220(v7);
    }
    else
    {
      v13 = (unsigned int)Object;
    }
    if ( (_DWORD)v13 )
    {
      v25 = (PVOID *)v6;
      do
      {
        if ( *v25 != (PVOID)v5 )
          ObfDereferenceObject(*v25);
        ++v25;
        --v13;
      }
      while ( v13 );
    }
    sub_140051220(v6);
  }
  return v5;
}
// 14004034C: conditional instruction was optimized away because of 'eax.4 in (1..1FF|>=201u)'
// 14004030B: variable 'v8' is possibly undefined
// 14004030B: variable 'v9' is possibly undefined
// 14004030B: variable 'v10' is possibly undefined
// 14004030B: variable 'v27' is possibly undefined
// 140014308: using guessed type __int64 __fastcall sub_140014308(_QWORD, _QWORD);

//----- (0000000140040474) ----------------------------------------------------
struct _KPROCESS *__fastcall sub_140040474(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  __int64 v5; // rdi
  __int64 v6; // rsi
  struct _KPROCESS *i; // rcx
  __int64 v8; // rax
  __int64 v9; // rax
  struct _KPROCESS *v10; // rbx

  v5 = 0i64;
  v6 = sub_140059080(0i64);
  for ( i = (struct _KPROCESS *)v6; ; i = v10 )
  {
    v9 = sub_140059080(i);
    v10 = (struct _KPROCESS *)v9;
    if ( !v9 || v9 == v6 )
      break;
    v8 = sub_14004888C(v9);
    if ( (int)sub_1400488FC(v8, (__int64)&Object) < 0 )
      return v10;
    ObfDereferenceObject(Object);
  }
  return (struct _KPROCESS *)v5;
}

//----- (000000014004059C) ----------------------------------------------------
char __fastcall sub_14004059C(__int64 a1)
{
  unsigned __int16 *v1; // rdi
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rsi
  unsigned __int64 v5; // r14

  if ( !a1 )
    return 0;
  v1 = (unsigned __int16 *)(a1 + 0x10);
  if ( a1 == 0xFFFFFFFFFFFFFFF0ui64 )
    return 0;
  if ( !*(_QWORD *)(a1 + 0x18) )
    return 0;
  v2 = *v1;
  if ( !(_WORD)v2 || !*(_WORD *)(a1 + 0x12) || (unsigned __int16)v2 > 0x200u )
    return 0;
  v3 = sub_140051084(v2 + 2);
  v4 = v3;
  if ( v3 )
  {
    v5 = (unsigned __int64)*v1 >> 1;
    if ( sub_14000746C(v3, *v1 + 2i64, v1) == v5 )
      JUMPOUT(0x14004065Ci64);
    sub_140051220(v4);
  }
  return 0;
}
// 140040658: control flows out of bounds to 14004065C

//----- (000000014004082C) ----------------------------------------------------
void sub_14004082C()
{
  JUMPOUT(0x14004084Bi64);
}
// 140040844: control flows out of bounds to 14004084B

//----- (0000000140040928) ----------------------------------------------------
char __fastcall sub_140040928(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  char v7; // bl
  int v10; // eax
  __int64 v11; // r8
  char v13[48]; // [rsp+30h] [rbp-38h] BYREF

  v7 = 0;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !*(_QWORD *)(a2 + 0x18) )
    return 0;
  if ( !*(_DWORD *)(a2 + 0x20) )
    return 0;
  v10 = *(_DWORD *)(a2 + 0x24);
  if ( !v10 || (v10 & 0xF0) != 0 || *(_QWORD *)(a2 + 8) )
    return 0;
  if ( sub_140015378(a1, (__int64)v13) )
  {
    v11 = *(_QWORD *)(a2 + 0x10);
    a5 = *(_QWORD *)(a2 + 8);
    a7 = *(_QWORD *)(a2 + 0x18);
    if ( (int)sub_1400616FC(0xFFFFFFFFFFFFFFFFui64, (__int64)&a5, v11, (__int64)&a7) >= 0 )
    {
      v7 = 1;
      *(_QWORD *)(a2 + 8) = a5;
      *(_QWORD *)(a2 + 0x18) = a7;
    }
    ((void (__fastcall *)(__int64, char *))loc_140015528)(a1, v13);
  }
  return v7;
}

//----- (0000000140040A04) ----------------------------------------------------
char __fastcall sub_140040A04(__int64 a1, _QWORD *a2)
{
  char v4; // r15
  char v5; // al
  __int64 v6; // r14
  __int64 v7; // rbx
  ULONG64 v8; // rdi
  __int64 v9; // rax
  void *v11; // [rsp+20h] [rbp-28h]

  v4 = 0;
  LOBYTE(v11) = 0;
  if ( !a1 || !a2 || !a2[1] || !a2[2] || !a2[3] )
    return 0;
  if ( MEMORY[0xFFFFF7800000026C] == 0xA )
    sub_14004388C();
  sub_14004082C();
  if ( !v5 )
    return 0;
  sub_140052288(a2[3], a2[2]);
  v6 = sub_140051084(a2[2]);
  if ( v6 )
  {
    v7 = a2[2];
    v8 = a2[1];
    v9 = sub_14004888C(a1);
    if ( sub_1400149C0(v9, v8, v6, v7, v11) )
    {
      ((void (__fastcall *)(_QWORD, __int64, _QWORD))loc_14006F000)(a2[3], v6, a2[2]);
      a2[4] = a2[2];
      v4 = 1;
    }
  }
  if ( v6 )
    sub_140051220(v6);
  return v4;
}
// 140040A9B: variable 'v5' is possibly undefined
// 140040AE0: variable 'v11' is possibly undefined

//----- (0000000140040B44) ----------------------------------------------------
char __fastcall sub_140040B44(__int64 a1, _QWORD *a2)
{
  char v4; // r14
  char v5; // al
  __int64 v6; // rax
  __int64 v7; // r15
  __int64 v8; // rbx
  unsigned __int64 v9; // rdi
  __int64 v10; // rax
  void *v12; // [rsp+20h] [rbp-28h]

  v4 = 0;
  LOBYTE(v12) = 0;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !a2[1] )
    return 0;
  if ( !a2[2] )
    return 0;
  if ( !a2[3] )
    return 0;
  sub_14004082C();
  if ( !v5 )
    return 0;
  sub_14005221C(a2[1], a2[2], 1);
  v6 = sub_140051084(a2[2]);
  v7 = v6;
  if ( v6 )
  {
    ((void (__fastcall *)(__int64, _QWORD, _QWORD))loc_14006F000)(v6, a2[1], a2[2]);
    v8 = a2[2];
    v9 = a2[3];
    v10 = sub_14004888C(a1);
    if ( sub_140014A78(v10, v9, v7, v8, v12) )
    {
      a2[4] = a2[2];
      v4 = 1;
    }
  }
  if ( v7 )
    sub_140051220(v7);
  return v4;
}
// 140040BB3: variable 'v5' is possibly undefined
// 140040C0E: variable 'v12' is possibly undefined

//----- (0000000140040C64) ----------------------------------------------------
char __fastcall sub_140040C64(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  char v7; // bl
  int v10; // eax
  char v11; // al
  unsigned int v12; // er9
  char v14[48]; // [rsp+30h] [rbp-38h] BYREF

  v7 = 0;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !*(_QWORD *)(a2 + 8) )
    return 0;
  if ( !*(_QWORD *)(a2 + 0x10) )
    return 0;
  v10 = *(_DWORD *)(a2 + 0x18);
  if ( !v10 )
    return 0;
  if ( (v10 & 0xF0) != 0 )
    return 0;
  sub_14004082C();
  if ( !v11 )
    return 0;
  if ( sub_140015378(a1, (__int64)v14) )
  {
    v12 = *(_DWORD *)(a2 + 0x18);
    a5 = *(_QWORD *)(a2 + 8);
    a7 = *(_QWORD *)(a2 + 0x10);
    if ( (int)sub_140061928(0xFFFFFFFFFFFFFFFFui64, (__int64)&a5, (__int64)&a7, v12) >= 0 )
    {
      v7 = 1;
      *(_QWORD *)(a2 + 8) = a5;
      *(_QWORD *)(a2 + 0x10) = a7;
    }
    ((void (__fastcall *)(__int64, char *))loc_140015528)(a1, v14);
  }
  return v7;
}
// 140040CC4: variable 'v11' is possibly undefined

//----- (0000000140040D50) ----------------------------------------------------
char __fastcall sub_140040D50(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  char v7; // bl
  char v10; // al
  unsigned int v11; // er9
  char v13[56]; // [rsp+20h] [rbp-38h] BYREF

  v7 = 0;
  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  if ( !*(_QWORD *)(a2 + 8) )
    return 0;
  if ( ((*(_DWORD *)(a2 + 0x18) - 0x4000) & 0xFFFFBFFF) != 0 )
    return 0;
  sub_14004082C();
  if ( !v10 )
    return 0;
  if ( sub_140015378(a1, (__int64)v13) )
  {
    v11 = *(_DWORD *)(a2 + 0x18);
    a5 = *(_QWORD *)(a2 + 8);
    a7 = *(_QWORD *)(a2 + 0x10);
    if ( (int)sub_140061870(0xFFFFFFFFFFFFFFFFui64, (__int64)&a5, (__int64)&a7, v11) >= 0 )
    {
      v7 = 1;
      *(_QWORD *)(a2 + 8) = a5;
      *(_QWORD *)(a2 + 0x10) = a7;
    }
    ((void (__fastcall *)(__int64, char *))loc_140015528)(a1, v13);
  }
  return v7;
}
// 140040DA6: variable 'v10' is possibly undefined

//----- (0000000140040E20) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140040E20()
{
  JUMPOUT(0x140040E31i64);
}
// 140040EE2: positive sp value 10 has been found
// 140040E2F: control flows out of bounds to 140040E31

//----- (0000000140040EE4) ----------------------------------------------------
void __fastcall sub_140040EE4(__int64 a1, __int64 a2, _DWORD *a3)
{
  __int64 *v3; // rsi
  __int64 v4; // rdi
  ULONG64 v5; // r13
  __int64 v6; // r14
  __int64 v7; // rax
  __int64 v8; // rax
  __int64 v9; // r8
  __int64 v10; // r9
  __int64 v11; // r12
  char v12; // r15
  __int64 v13; // rcx
  bool v14; // zf
  __int64 v15; // r12
  char v16; // al
  __int64 v17; // [rsp+20h] [rbp-88h]
  __int64 v18; // [rsp+28h] [rbp-80h]
  __int64 v19; // [rsp+30h] [rbp-78h]
  char v20[96]; // [rsp+48h] [rbp-60h] BYREF

  v3 = 0i64;
  v4 = 0i64;
  v5 = *(_QWORD *)(a2 + 0x20);
  if ( !v5 )
    goto LABEL_50;
  v6 = *(unsigned int *)(a2 + 0x10);
  if ( (unsigned int)v6 <= 8 )
    goto LABEL_50;
  if ( *(_QWORD *)(a1 + 0x70) != v5 )
    goto LABEL_50;
  if ( *(_DWORD *)(a2 + 8) != (_DWORD)v6 )
    goto LABEL_50;
  sub_14005221C(v5, (unsigned int)v6, 1);
  v7 = sub_140051084((unsigned int)v6);
  v4 = v7;
  if ( !v7 )
    goto LABEL_50;
  ((void (__fastcall *)(__int64, ULONG64, _QWORD))loc_14006F000)(v7, v5, (unsigned int)v6);
  v3 = sub_140062BF4(*(unsigned int *)(v4 + 4));
  if ( !v3 )
    goto LABEL_50;
  v8 = sub_140048808();
  if ( !(unsigned __int8)((__int64 (__fastcall *)(__int64))loc_14000C954)(v8) )
    goto LABEL_50;
  if ( *(_DWORD *)v4 == 1 )
  {
    if ( (_DWORD)v6 != 0x28 )
      goto LABEL_50;
    v16 = sub_140040928(v3[1], v4, v9, v10, v17, v18, v19);
  }
  else if ( *(_DWORD *)v4 == 2 )
  {
    if ( (_DWORD)v6 != 0x28 )
      goto LABEL_50;
    v16 = sub_140040A04(v3[1], (_QWORD *)v4);
  }
  else if ( *(_DWORD *)v4 == 3 )
  {
    if ( (_DWORD)v6 != 0x28 )
      goto LABEL_50;
    v16 = sub_140040B44(v3[1], (_QWORD *)v4);
  }
  else if ( *(_DWORD *)v4 == 4 )
  {
    if ( (_DWORD)v6 != 0x20 )
      goto LABEL_50;
    v16 = sub_140040C64(v3[1], v4, v9, v10, v17, v18, v19);
  }
  else if ( *(_DWORD *)v4 == 5 )
  {
    if ( (_DWORD)v6 != 0x1C )
      goto LABEL_50;
    v16 = sub_140040D50(v3[1], v4, v9, v10, v17, v18, v19);
  }
  else
  {
    if ( *(_DWORD *)v4 != 6 )
    {
      if ( *(_DWORD *)v4 == 7 )
      {
        if ( (_DWORD)v6 != 0x24 )
          goto LABEL_50;
        v15 = v3[1];
        v12 = 0;
        if ( v15 )
        {
          if ( !*(_QWORD *)(v4 + 8) || !*(_QWORD *)(v4 + 0x14) || !*(_DWORD *)(v4 + 0x1C) )
            goto LABEL_50;
          if ( sub_140015378(v15, (__int64)v20) )
          {
            if ( (int)sub_140061C1C(
                        0xFFFFFFFFFFFFFFFFui64,
                        *(_QWORD *)(v4 + 8),
                        *(_DWORD *)(v4 + 0x10),
                        *(_QWORD *)(v4 + 0x14)) >= 0 )
            {
              *(_DWORD *)(v4 + 0x20) = 0;
              v12 = 1;
            }
            ((void (__fastcall *)(__int64, char *))loc_140015528)(v15, v20);
          }
        }
      }
      else
      {
        if ( *(_DWORD *)v4 != 8 || (_DWORD)v6 != 0x24 )
          goto LABEL_50;
        v11 = v3[1];
        v12 = 0;
        if ( v11 )
        {
          if ( !*(_QWORD *)(v4 + 0xC) || !*(_DWORD *)(v4 + 0x14) || !*(_QWORD *)(v4 + 0x18) || *(_DWORD *)(v4 + 0x20) )
            goto LABEL_50;
          if ( sub_140015378(v11, (__int64)v20) )
          {
            sub_1400619E8(v13, *(_DWORD *)(v4 + 8), *(unsigned int *)(v4 + 0x14), *(_QWORD *)(v4 + 0xC));
            JUMPOUT(0x140041068i64);
          }
        }
      }
      v14 = v12 == 0;
      goto LABEL_48;
    }
    if ( (_DWORD)v6 != 0x24 )
      goto LABEL_50;
    sub_140040E20();
  }
  v14 = v16 == 0;
LABEL_48:
  if ( !v14 )
  {
    ((void (__fastcall *)(ULONG64, __int64, __int64))loc_14006F000)(v5, v4, v6);
    *a3 = v6;
  }
LABEL_50:
  if ( v4 )
    sub_140051220(v4);
  if ( v3 )
    sub_140062D30((__int64)v3);
}
// 140041064: control flows out of bounds to 140041068
// 140041059: variable 'v13' is possibly undefined
// 14004114C: variable 'v9' is possibly undefined
// 14004114C: variable 'v10' is possibly undefined
// 14004114C: variable 'v17' is possibly undefined
// 14004114C: variable 'v18' is possibly undefined
// 14004114C: variable 'v19' is possibly undefined
// 1400411A1: variable 'v16' is possibly undefined

//----- (0000000140042030) ----------------------------------------------------
char __fastcall sub_140042030(__int64 a1, __int64 a2, __int64 a3, __int64 a4, int a5)
{
  char v5; // di
  unsigned __int64 v8; // r15
  void *v9; // rax
  __int64 v10; // r14
  unsigned __int64 v11; // r12
  void *v12; // rax
  __int64 v13; // r8
  __int64 v14; // r9
  unsigned __int64 v15; // rax
  int v16; // eax
  ULONG v18; // [rsp+20h] [rbp-30h]
  int v19; // [rsp+30h] [rbp-20h] BYREF
  int v20; // [rsp+34h] [rbp-1Ch]
  __int64 v21; // [rsp+38h] [rbp-18h]
  int v22; // [rsp+40h] [rbp-10h]

  a5 = 0;
  v5 = 0;
  v20 = 0;
  switch ( *(_DWORD *)a1 )
  {
    case 0xC:
      if ( qword_1400DB4E0
        || (v19 = 0xF537C24C,
            v20 = 0x882966AF,
            v21 = 0x19B503139E71C068i64,
            v22 = 0x215718EA,
            (qword_1400DB4E0 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))((__int64 (__fastcall *)(int *))loc_1400061CC)(&v19)) != 0i64) )
      {
        if ( sub_140007090(a2, 2 * (*(_WORD *)(a1 + 0x10) + 1)) )
        {
          v16 = qword_1400DB4E0(*(_QWORD *)(a2 + 8), *(unsigned __int16 *)(a2 + 2), &a5, *(_QWORD *)(a1 + 8));
          v5 = v16 >= 0;
          if ( v16 >= 0 )
            *(_WORD *)a2 = a5;
          else
            sub_14000724C(a2);
        }
      }
      break;
    case 0x13:
    case 0x14:
    case 0x16:
    case 0x1C:
      v11 = (unsigned int)(*(_DWORD *)(a1 + 0x10) + 1);
      v12 = (void *)sub_140051084(v11);
      v10 = (__int64)v12;
      if ( !v12 )
        return v5;
      memset(v12, 0, (unsigned int)v11);
      ((void (__fastcall *)(void *, _QWORD, _QWORD))loc_14006F000)(
        v12,
        *(_QWORD *)(a1 + 8),
        *(unsigned int *)(a1 + 0x10));
      v15 = 0xFFFFFFFFFFFFFFFFui64;
      v21 = v10;
      do
        ++v15;
      while ( *(_BYTE *)(v10 + v15) );
      LOWORD(v19) = v15;
      HIWORD(v19) = v15 + 1;
      v5 = (int)sub_140007274((unsigned __int16 *)a2, (unsigned __int16 *)&v19, v13, v14, v18) >= 0;
      goto LABEL_9;
    case 0x1E:
      v8 = (unsigned int)(*(_DWORD *)(a1 + 0x10) + 2);
      v9 = (void *)sub_140051084(v8);
      v10 = (__int64)v9;
      if ( v9 )
      {
        memset(v9, 0, (unsigned int)v8);
        ((void (__fastcall *)(void *, _QWORD, _QWORD))loc_14006F000)(
          v9,
          *(_QWORD *)(a1 + 8),
          *(unsigned int *)(a1 + 0x10));
        v5 = sub_1400070E0(a2, v10);
LABEL_9:
        sub_140051220(v10);
        return v5;
      }
      break;
  }
  return v5;
}
// 140042134: variable 'v13' is possibly undefined
// 140042134: variable 'v14' is possibly undefined
// 140042134: variable 'v18' is possibly undefined
// 1400DB4E0: using guessed type __int64 (__fastcall *qword_1400DB4E0)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (00000001400421F0) ----------------------------------------------------
void sub_1400421F0()
{
  JUMPOUT(0x1400421FBi64);
}
// 1400421F7: control flows out of bounds to 1400421FB

//----- (0000000140042300) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140042300()
{
  JUMPOUT(0x14004232Ai64);
}
// 140042415: positive sp value 58 has been found
// 140042326: control flows out of bounds to 14004232A

//----- (0000000140042418) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_140042418(__int64 a1, __int64 a2, __int64 a3, int a4)
{
  JUMPOUT(0x140042431i64);
}
// 140042736: positive sp value 28 has been found
// 14004242F: control flows out of bounds to 140042431

//----- (0000000140042738) ----------------------------------------------------
void sub_140042738()
{
  JUMPOUT(0x140042747i64);
}
// 140042743: control flows out of bounds to 140042747

//----- (0000000140043058) ----------------------------------------------------
__int64 __fastcall sub_140043058(__int64 a1, __int64 a2)
{
  unsigned __int64 i; // rbx

  if ( a1 && a2 )
  {
    for ( i = 0i64; i < 0x100; ++i )
    {
      if ( !*(_BYTE *)(i + a2) )
        break;
    }
    JUMPOUT(0x140043099i64);
  }
  return 0i64;
}
// 140043096: control flows out of bounds to 140043099

//----- (00000001400430D8) ----------------------------------------------------
__int64 __fastcall sub_1400430D8(__int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rsi
  __int64 v7; // rax
  unsigned int v8; // er12
  __int64 v9; // rax
  __int64 v10; // rcx
  __int64 v11; // rdi
  __int64 v12; // rbx

  v3 = 0i64;
  if ( !a1 || !a2 || !a3 )
    return 0i64;
  v7 = sub_140051084(0x220 * a3);
  *a1 = v7;
  if ( v7 )
  {
    v8 = 0;
    if ( a3 )
    {
      v9 = 0i64;
      do
      {
        v10 = *a1;
        v11 = 0x220 * v9;
        *(_QWORD *)(v10 + v3) = *(_QWORD *)(0x220 * v9 + a2);
        v12 = sub_140043058(v3 + v10 + 8, 0x220 * v9 + a2 + 8) + 8;
        ++v8;
        v3 += v12 + sub_140043058(v3 + v12 + *a1, v11 + a2 + 0x114);
        v9 = v8;
      }
      while ( v8 < a3 );
    }
  }
  return v3;
}

//----- (00000001400435A0) ----------------------------------------------------
char __fastcall sub_1400435A0(__int64 a1, __int64 a2, _QWORD *a3, _DWORD *a4)
{
  char v7; // bl
  unsigned int v8; // eax
  _DWORD *v9; // rax
  _DWORD *v10; // rdx
  __int64 v11; // rax

  v7 = 0;
  if ( a1 )
  {
    if ( a2 )
    {
      if ( a3 )
      {
        if ( a4 )
        {
          v8 = *(_DWORD *)(a1 + 0x98);
          if ( v8 )
          {
            if ( *(_DWORD *)(a1 + 0x9C) )
            {
              v9 = sub_140052460(v8, a1);
              v10 = v9;
              if ( v9 )
              {
                v11 = (unsigned int)v9[5];
                if ( __PAIR64__(v11, v10[4]) )
                {
                  *a3 = a2 + v11;
                  *a4 = v10[4];
                  v7 = 1;
                }
              }
            }
          }
        }
      }
    }
  }
  return v7;
}

//----- (0000000140043638) ----------------------------------------------------
char __fastcall sub_140043638(__int64 a1, unsigned int a2)
{
  __int64 v2; // r14
  __int64 v4; // rax
  __int64 v5; // rdx
  int v7[7]; // [rsp+22h] [rbp-C6h] BYREF
  __int16 v8; // [rsp+3Eh] [rbp-AAh]
  char v9[160]; // [rsp+40h] [rbp-A8h] BYREF

  v2 = a2;
  v7[0] = 0x58D10E3A;
  v7[1] = 0x7EF6169B;
  v7[2] = 0xA8359F48;
  v7[3] = 0xC93487E6;
  v7[4] = 0x72D6D69C;
  v7[5] = 0x5F4B5FA9;
  v7[6] = 0x6F73D40D;
  v8 = 0x5053;
  v4 = ((__int64 (__fastcall *)(int *, char *))loc_140043754)(v7, v9);
  v5 = ((__int64 (__fastcall *)(__int64, _QWORD, __int64, __int64))loc_140015908)(a1, (unsigned int)v2, v4, 0x1Ei64);
  memset(v9, 0, 0x1Eui64);
  if ( v5 && v5 + 0x3C < (unsigned __int64)(a1 + v2) )
    JUMPOUT(0x1400436E7i64);
  return 0;
}
// 1400436E5: control flows out of bounds to 1400436E7

//----- (000000014004388C) ----------------------------------------------------
__int64 sub_14004388C()
{
  __int64 result; // rax
  struct _OSVERSIONINFOW VersionInformation; // [rsp+20h] [rbp-128h] BYREF

  result = (unsigned int)dword_1400DB4E8;
  if ( !dword_1400DB4E8 )
  {
    ((void (__fastcall *)(DWORD *, _QWORD, __int64))loc_14006F2C0)(&VersionInformation.dwMajorVersion, 0i64, 0x118i64);
    VersionInformation.dwOSVersionInfoSize = 0x11C;
    RtlGetVersion(&VersionInformation);
    result = VersionInformation.dwBuildNumber;
    dword_1400DB4E8 = VersionInformation.dwBuildNumber;
  }
  return result;
}
// 1400DB4E8: using guessed type int dword_1400DB4E8;

//----- (00000001400438D4) ----------------------------------------------------
char __fastcall sub_1400438D4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int64 a7)
{
  __int64 v7; // rsi
  unsigned __int64 v8; // rbx
  unsigned int v9; // eax
  _DWORD *v10; // rax
  __int64 v11; // rdx
  unsigned __int64 v12; // rsi
  unsigned __int64 v13; // rcx
  _DWORD *v14; // rax
  unsigned __int16 v16[24]; // [rsp+28h] [rbp-30h] BYREF

  if ( !a1 || !a2 )
    return 0;
  LOBYTE(a2) = 1;
  if ( sub_140014874(v16, a2, a3, a4) )
  {
    if ( sub_1400593BC((__int64)v16, &a7, &a5) )
    {
      v7 = (unsigned int)a5;
      v8 = a7;
      if ( sub_14005240C(a7, (unsigned int)a5, 0i64, &a5) )
      {
        v9 = *(_DWORD *)(a5 + 0xB8);
        if ( v9 )
        {
          v10 = sub_1400524BC(v9, a5, v8);
          if ( v10 )
          {
            if ( (unsigned __int64)v10 >= v8 && v10 + 7 > v10 )
            {
              v12 = v8 + v7;
              if ( (unsigned __int64)(v10 + 7) <= v12 )
              {
                v13 = (unsigned int)v10[5];
                if ( (_DWORD)v13 )
                {
                  if ( v10[3] == 2 )
                  {
                    v14 = sub_1400524BC(v13, v11, v8);
                    if ( v14 )
                    {
                      if ( (unsigned __int64)v14 >= v8
                        && (_DWORD *)((char *)v14 + 0x19) > v14
                        && (unsigned __int64)v14 + 0x19 <= v12
                        && *v14 == 0x53445352 )
                      {
                        JUMPOUT(0x1400439C2i64);
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ( v8 )
        sub_140051220(v8);
    }
    sub_14000724C((__int64)v16);
  }
  return 0;
}
// 1400439C0: control flows out of bounds to 1400439C2
// 14004399D: variable 'v11' is possibly undefined

//----- (0000000140043A18) ----------------------------------------------------
unsigned __int64 sub_140043A18()
{
  return __readmsr(0x40000001u);
}

//----- (0000000140043ADC) ----------------------------------------------------
__int64 __fastcall sub_140043ADC(unsigned int a1, unsigned int a2, unsigned int a3, int *a4, __int64 a5, int a6)
{
  __int64 v6; // rbx
  unsigned int v9; // edi
  __int64 v11; // rax
  int v12; // er14
  int v13; // eax

  v6 = 0i64;
  v9 = a2;
  if ( a2 <= a3 )
  {
    do
    {
      v11 = sub_140051084(v9);
      v6 = v11;
      if ( !v11 )
        break;
      v12 = sub_140061B64(a1, v11, v9, (__int64)&a6);
      if ( v12 >= 0 )
      {
        v13 = a6;
        if ( !a6 )
        {
          sub_140051220(v6);
          v13 = a6;
          v6 = 0i64;
        }
        if ( a4 )
          *a4 = v13;
        return v6;
      }
      sub_140051220(v6);
      v6 = 0i64;
      v9 *= 2;
    }
    while ( v12 == 0xC0000004 && v9 <= a3 );
  }
  return v6;
}

//----- (0000000140043E38) ----------------------------------------------------
void __fastcall sub_140043E38(__int64 a1)
{
  __int64 v2; // rcx
  char v3; // al
  char v4[56]; // [rsp+20h] [rbp-38h] BYREF

  if ( a1 && *(_QWORD *)(a1 + 0x148) && *(_QWORD *)(a1 + 0x150) && sub_140015378(*(_QWORD *)(a1 + 8), (__int64)v4) )
  {
    sub_14005221C(*(_QWORD *)(a1 + 0x150), 0xCi64, 1);
    v2 = *(_QWORD *)(a1 + 0x150);
    if ( *(_WORD *)v2 == 0xB948 && *(_QWORD *)(v2 + 2) == *(_QWORD *)(a1 + 0x148) && *(_WORD *)(v2 + 0xA) == 0xE1FF )
      goto LABEL_15;
    v3 = sub_1400197A0();
    if ( v3 )
      goto LABEL_15;
    if ( *(_DWORD *)a1 == 0x9A )
    {
      v3 = 1;
    }
    else if ( *(_DWORD *)a1 == 0xD9 )
    {
LABEL_15:
      ((void (__fastcall *)(_QWORD, char *))loc_140015528)(*(_QWORD *)(a1 + 8), v4);
      return;
    }
    if ( !v3 )
      ((void (__fastcall *)(__int64, __int64, __int64))loc_14004EC1C)(a1, 0xBi64, 1i64);
    goto LABEL_15;
  }
}

//----- (00000001400443D0) ----------------------------------------------------
__int64 __fastcall sub_1400443D0(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // rax
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAD68,
                                          &qword_1400DAD68,
                                          0i64);
  if ( v2 )
    result = v2(a1);
  else
    result = qword_1400D8250;
  return result;
}
// 1400D8250: using guessed type __int64 qword_1400D8250;
// 1400DAD68: using guessed type __int64 qword_1400DAD68;

//----- (000000014004440C) ----------------------------------------------------
__int64 __fastcall sub_14004440C(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAD98,
                                          &qword_1400DAD98,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAD98: using guessed type __int64 qword_1400DAD98;

//----- (0000000140044444) ----------------------------------------------------
__int64 __fastcall sub_140044444(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAD70,
                                          &qword_1400DAD70,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAD70: using guessed type __int64 qword_1400DAD70;

//----- (000000014004447C) ----------------------------------------------------
__int64 __fastcall sub_14004447C(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 (__fastcall *v6)(__int64, __int64, _QWORD); // r9
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(__int64, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                           qword_1400DAD78,
                                                           &qword_1400DAD78,
                                                           0i64);
  result = 0i64;
  if ( v6 )
    result = v6(a1, a2, a3);
  return result;
}
// 1400DAD78: using guessed type __int64 qword_1400DAD78;

//----- (00000001400444D0) ----------------------------------------------------
__int64 __fastcall sub_1400444D0(__int64 a1, __int64 a2, unsigned int a3)
{
  __int64 (__fastcall *v6)(__int64, __int64, _QWORD); // r9
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(__int64, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                           qword_1400DAD80,
                                                           &qword_1400DAD80,
                                                           0i64);
  result = 0i64;
  if ( v6 )
    result = v6(a1, a2, a3);
  return result;
}
// 1400DAD80: using guessed type __int64 qword_1400DAD80;

//----- (0000000140044524) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_140044524(__int64 a1, __int64 a2))(__int64, __int64)
{
  __int64 (__fastcall *result)(__int64, __int64); // rax

  result = (__int64 (__fastcall *)(__int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                       qword_1400DAD88,
                                                       &qword_1400DAD88,
                                                       0i64);
  if ( result )
    result = (__int64 (__fastcall *)(__int64, __int64))result(a1, a2);
  return result;
}
// 1400DAD88: using guessed type __int64 qword_1400DAD88;

//----- (0000000140044564) ----------------------------------------------------
__int64 __fastcall sub_140044564(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  __int64 (__fastcall *v8)(__int64, __int64, __int64, _QWORD); // rax
  __int64 result; // rax

  v8 = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                    qword_1400DADA0,
                                                                    &qword_1400DADA0,
                                                                    0i64);
  if ( v8 )
    result = v8(a1, a2, a3, a4);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DADA0: using guessed type __int64 qword_1400DADA0;

//----- (00000001400445D4) ----------------------------------------------------
__int64 __fastcall sub_1400445D4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int64 (__fastcall *v8)(__int64, __int64, __int64, __int64); // r10
  __int64 result; // rax

  v8 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DADD0,
                                                                     &qword_1400DADD0,
                                                                     0i64);
  result = 0i64;
  if ( v8 )
    result = v8(a1, a2, a3, a4);
  return result;
}
// 1400DADD0: using guessed type __int64 qword_1400DADD0;

//----- (000000014004463C) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14004463C(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                              qword_1400DADD8,
                                              &qword_1400DADD8,
                                              0i64);
  if ( result )
    result = (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}
// 1400DADD8: using guessed type __int64 qword_1400DADD8;

//----- (0000000140044F80) ----------------------------------------------------
char __fastcall sub_140044F80(__int64 a1, __int64 a2, unsigned int *a3)
{
  if ( !a2 || !a3 )
    return 0;
  if ( (unsigned __int8)((__int64 (__fastcall *)(_QWORD, __int64, _QWORD))loc_1400447C0)(*a3, a2, *((_QWORD *)a3 + 1)) == 1 )
  {
    *((_BYTE *)a3 + 0x10) = 1;
    return 0;
  }
  return 1;
}

//----- (0000000140044FB4) ----------------------------------------------------
char __fastcall sub_140044FB4(__int64 a1, void *a2, __int64 a3, __int64 a4)
{
  char v4; // bl
  __int64 v6; // [rsp+20h] [rbp-28h] BYREF
  PVOID v7; // [rsp+28h] [rbp-20h]
  char v8; // [rsp+30h] [rbp-18h]

  v4 = 0;
  LODWORD(v6) = a1;
  v7 = a2;
  v8 = 0;
  if ( !a2 || (_DWORD)a1 != 6 )
    return 0;
  if ( sub_1400465DC(a1, a2, (unsigned int *)&v6, a4, v6, v7) )
  {
    if ( v8 )
      v4 = 1;
  }
  return v4;
}

//----- (0000000140044FF4) ----------------------------------------------------
#error "14004502A: call analysis failed (funcsize=28)"

//----- (0000000140045050) ----------------------------------------------------
char __fastcall sub_140045050(__int64 a1, unsigned int a2)
{
  if ( a2 >= 0x80 )
    JUMPOUT(0x14004507Ai64);
  return 0;
}
// 140045074: control flows out of bounds to 14004507A

//----- (00000001400451F0) ----------------------------------------------------
char __fastcall sub_1400451F0(__int64 a1, _DWORD *a2, _QWORD *a3)
{
  char v3; // bl
  char v7; // al

  v3 = 0;
  if ( !a1 || !a3 )
    return 0;
  if ( qword_1400D82B0 )
  {
    if ( *(_BYTE *)(a1 + 0xC) && sub_140045050(*(_QWORD *)a1, *(_DWORD *)(a1 + 8)) || (sub_1400306D0(), v7) )
    {
      *a2 = 0;
      *a3 = 0i64;
      v3 = 1;
    }
    else if ( *(_BYTE *)(a1 + 0xC) )
    {
      JUMPOUT(0x14004529Fi64);
    }
  }
  return v3;
}
// 140045299: control flows out of bounds to 14004529F
// 140045376: control flows out of bounds to 140045378
// 1400453CA: control flows out of bounds to 1400453CF
// 140045366: conditional instruction was optimized away because of 'bl.1==0'
// 140045294: variable 'v7' is possibly undefined
// 1400D82B0: using guessed type __int64 qword_1400D82B0;

//----- (0000000140045418) ----------------------------------------------------
#error "140045461: call analysis failed (funcsize=50)"

//----- (00000001400454C4) ----------------------------------------------------
char __fastcall sub_1400454C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int64 a6, __int64 a7)
{
  struct _KTHREAD *v8; // rdi
  char v9; // bl
  unsigned int v10; // eax
  char v11; // si
  __int64 (__fastcall *v12)(unsigned __int64 *, __int64, _QWORD, __int64 *); // rbp
  int v13; // ebp

  a7 = 1i64;
  v8 = KeGetCurrentThread();
  v9 = 0;
  v10 = sub_140065008();
  if ( v8 && v10 )
    v11 = *((_BYTE *)v8 + v10);
  else
    v11 = 0;
  v12 = (__int64 (__fastcall *)(unsigned __int64 *, __int64, _QWORD, __int64 *))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                                  qword_1400DB3F8,
                                                                                  &qword_1400DB3F8,
                                                                                  0i64);
  sub_140065AB8((__int64)v8, 0);
  if ( v12 )
    v13 = v12(&a6, 0xF001Fi64, 0i64, &a7);
  else
    v13 = 0xC0000002;
  sub_140065AB8((__int64)v8, v11);
  if ( v13 >= 0 )
  {
    v9 = sub_140045418(a6, a1);
    sub_1400612D4(a6);
  }
  return v9;
}
// 140045418: using guessed type __int64 __fastcall sub_140045418(_QWORD, _QWORD);
// 1400DB3F8: using guessed type __int64 qword_1400DB3F8;

//----- (0000000140045970) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140045970()
{
  JUMPOUT(0x140045997i64);
}
// 140045C0B: positive sp value 18 has been found
// 140045994: control flows out of bounds to 140045997

//----- (0000000140045C14) ----------------------------------------------------
void __fastcall sub_140045C14(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  if ( a1 )
  {
    if ( (int)sub_1400489AC(a1, (__int64)&Object) >= 0 )
    {
      sub_140065814((__int64)Object);
      ObfDereferenceObject(Object);
    }
  }
}

//----- (0000000140045C48) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140045C48()
{
  JUMPOUT(0x140045C60i64);
}
// 140045DCB: positive sp value 18 has been found
// 140045C5D: control flows out of bounds to 140045C60

//----- (0000000140045DCC) ----------------------------------------------------
void sub_140045DCC()
{
  JUMPOUT(0x140045DF9i64);
}
// 140045DF5: control flows out of bounds to 140045DF9

//----- (0000000140045FCC) ----------------------------------------------------
__int64 __fastcall sub_140045FCC(__int64 a1)
{
  _QWORD *v2; // rax
  __int64 v3; // rbx
  __int64 v4; // rax

  v2 = (_QWORD *)sub_140051084(0x20ui64);
  v3 = (__int64)v2;
  if ( v2 )
  {
    v2[1] = 0i64;
    *v2 = a1;
    v2[2] = 0x64i64;
    v4 = sub_140051084(0x64 * a1);
    *(_QWORD *)(v3 + 0x18) = v4;
    if ( !v4 )
    {
      sub_140051220(v3);
      v3 = 0i64;
    }
  }
  return v3;
}

//----- (0000000140046028) ----------------------------------------------------
char __fastcall sub_140046028(_QWORD *a1, __int64 a2)
{
  __int64 v2; // rax
  __int64 v4; // rcx
  char v5; // di
  unsigned __int64 v7; // rsi
  __int64 v8; // rax
  __int64 v9; // rbp

  v2 = a1[1];
  v4 = a1[2];
  v5 = 0;
  if ( v2 != v4 )
    goto LABEL_4;
  v7 = (unsigned __int64)(3 * v4) >> 1;
  v8 = sub_140051084(*a1 * v7);
  v9 = v8;
  if ( v8 )
  {
    ((void (__fastcall *)(__int64, _QWORD, _QWORD))loc_14006F000)(v8, a1[3], *a1 * a1[1]);
    sub_140051220(a1[3]);
    v2 = a1[1];
    a1[2] = v7;
    a1[3] = v9;
LABEL_4:
    ((void (__fastcall *)(__int64, __int64))loc_14006F000)(a1[3] + v2 * *a1, a2);
    ++a1[1];
    v5 = 1;
  }
  return v5;
}

//----- (00000001400460D8) ----------------------------------------------------
char __fastcall sub_1400460D8(char a1, char **a2, int *a3, unsigned int *a4)
{
  char *v7; // r10
  int v8; // edx
  unsigned int v9; // eax
  bool v10; // r15
  int v11; // edi
  char *v12; // rsi
  char v13; // cl
  int *v14; // r10
  unsigned int v15; // er9
  char v16; // al
  unsigned __int64 v17; // rbp
  int v18; // edx
  char v19; // cl
  unsigned int v20; // er9
  __int64 v21; // r10
  char *v22; // rdx

  if ( a2 )
  {
    v7 = *a2;
    if ( *a2 )
    {
      if ( a3 )
      {
        v8 = *a3;
        if ( *a3 )
        {
          if ( a4 )
          {
            memset(a4, 0, 0x28ui64);
            v9 = *v7 & 0x1F;
            *a4 = v9;
            v10 = (*v7 & 0x20) == 0;
            if ( v9 < 0x1F )
            {
              v11 = v8 - 1;
              *((_QWORD *)a4 + 3) = v7;
              *a3 = v8 - 1;
              v12 = v7 + 1;
              *a2 = v7 + 1;
              if ( v8 == 1 )
                return 1;
              v13 = 0;
              v14 = (int *)(a4 + 4);
              if ( v12 )
              {
                if ( a4 != (unsigned int *)0xFFFFFFFFFFFFFFF0i64 )
                {
                  v15 = 0;
                  *v14 = 0;
                  v16 = *v12;
                  if ( *v12 >= 0 )
                  {
                    *v14 = v16 & 0x7F;
                  }
                  else
                  {
                    if ( (v16 & 0x7F) == 0 || (v15 = v16 & 0x7F, v15 > 4) || v15 > v8 - 2 )
                    {
LABEL_19:
                      v20 = v15 + 1;
                      if ( v13 )
                      {
                        v21 = (unsigned int)*v14;
                        if ( (unsigned int)v21 <= v11 - v20 )
                        {
                          v22 = &v12[v20];
                          a4[8] = v20 + 1;
                          *((_QWORD *)a4 + 1) = v22;
                          if ( v10 || !a1 )
                          {
                            *a2 = &v22[v21];
                            *a3 = v11 - v21 - v20;
                          }
                          else
                          {
                            *a2 = v22;
                            *a3 = v11 - v20;
                          }
                          return 1;
                        }
                      }
                      return 0;
                    }
                    v17 = 0i64;
                    if ( (v16 & 0x7F) != 0 )
                    {
                      do
                      {
                        v18 = (unsigned __int8)v12[v17 + 1];
                        v19 = v15 - v17++;
                        *v14 += v18 << (8 * v19 - 8);
                      }
                      while ( v17 < (v16 & 0x7Fu) );
                    }
                  }
                  v13 = 1;
                  goto LABEL_19;
                }
              }
            }
          }
        }
      }
    }
  }
  return 0;
}

//----- (0000000140046248) ----------------------------------------------------
void __fastcall sub_140046248(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  __int64 v9; // rax
  __int64 v10; // rdi
  int v11; // eax
  _WORD *v12; // rax
  __int64 v13; // rcx
  __int64 v14; // rsi
  __int64 v15; // rdx

  if ( a1 )
  {
    a7 = a3;
    a8 = a4;
    if ( a2 )
    {
      if ( KeGetCurrentIrql() <= 1u && !*(_BYTE *)(a1 + 0x20) )
      {
        v9 = sub_140051084(0x800ui64);
        v10 = v9;
        if ( v9 )
        {
          sub_140005BC8(v9, 0x3FFi64, a2, (__int64)&a7);
          if ( v11 < 0 || (unsigned __int64)v11 > 0x3FF )
          {
            *(_WORD *)(v10 + 0x7FE) = 0;
          }
          else
          {
            if ( v11 == 0x3FFi64 )
              *(_WORD *)(v10 + 0x7FE) = 0;
            v12 = (_WORD *)v10;
            v13 = 0x400i64;
            do
            {
              if ( !*v12 )
                break;
              ++v12;
              --v13;
            }
            while ( v13 );
            v14 = (0x400 - v13) & -(__int64)(v13 != 0);
            if ( v13 && v14 )
            {
              ExAcquireFastMutex((PFAST_MUTEX)(a1 + 0x28));
              if ( !*(_BYTE *)(a1 + 0x20) )
              {
                v15 = *(_QWORD *)(a1 + 8);
                if ( v14 + 2 <= (unsigned __int64)(*(_QWORD *)(a1 + 0x10) - v15) )
                {
                  ((void (__fastcall *)(__int64, __int64, __int64))loc_14006F000)(*(_QWORD *)a1 + 2 * v15, v10, 2 * v14);
                  *(_QWORD *)(a1 + 8) += v14;
                  *(_WORD *)(*(_QWORD *)a1 + 2i64 * (*(_QWORD *)(a1 + 8))++) = 0xA;
                  *(_WORD *)(*(_QWORD *)a1 + 2i64 * *(_QWORD *)(a1 + 8)) = 0;
                }
              }
              ExReleaseFastMutex((PFAST_MUTEX)(a1 + 0x28));
            }
          }
          sub_140051220(v10);
        }
      }
    }
  }
}
// 1400462C0: variable 'v11' is possibly undefined

//----- (0000000140046390) ----------------------------------------------------
char __fastcall sub_140046390(_BYTE *a1)
{
  char v1; // bl
  __int64 (__fastcall *v3)(_QWORD); // rax
  int v5; // [rsp+20h] [rbp-20h] BYREF
  int v6; // [rsp+24h] [rbp-1Ch]
  int v7; // [rsp+28h] [rbp-18h]
  int v8; // [rsp+2Ch] [rbp-14h]
  int v9; // [rsp+30h] [rbp-10h]

  v1 = 0;
  if ( a1 )
  {
    if ( MEMORY[0xFFFFF7800000026C] >= 6u && (MEMORY[0xFFFFF7800000026C] != 6 || MEMORY[0xFFFFF78000000270]) )
      return v1;
    v3 = (__int64 (__fastcall *)(_QWORD))qword_1400DADE8;
    if ( qword_1400DADE8
      || (v5 = 0xF9B57F7B,
          v6 = 0x89CBA00B,
          v7 = 0x77DB46B8,
          v8 = 0xD7A68FE2,
          v9 = 0x8DBB2F76,
          v3 = (__int64 (__fastcall *)(_QWORD))((__int64 (__fastcall *)(int *))loc_1400061CC)(&v5),
          (qword_1400DADE8 = (__int64)v3) != 0) )
    {
      if ( qword_1400DADF0 )
      {
LABEL_10:
        *a1 = v3(0i64);
        return 1;
      }
      v5 = 0x130966FE;
      v6 = 0x31680111;
      v7 = 0x4AA754F;
      v8 = 0x8C34956F;
      v9 = 0x8EA948D;
      qword_1400DADF0 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(&v5);
      if ( qword_1400DADF0 )
      {
        v3 = (__int64 (__fastcall *)(_QWORD))qword_1400DADE8;
        goto LABEL_10;
      }
    }
  }
  return 0;
}
// 1400DADE8: using guessed type __int64 qword_1400DADE8;
// 1400DADF0: using guessed type __int64 qword_1400DADF0;

//----- (0000000140046480) ----------------------------------------------------
__int64 __fastcall sub_140046480(__int64 a1)
{
  if ( a1 && *(_QWORD *)(a1 + 8) && *(_WORD *)a1 && *(_WORD *)(a1 + 2) )
    JUMPOUT(0x1400464BBi64);
  return 0i64;
}
// 1400464B5: control flows out of bounds to 1400464BB

//----- (00000001400465DC) ----------------------------------------------------
char __fastcall sub_1400465DC(__int64 a1, void *a2, unsigned int *a3, __int64 a4, __int64 a5, PVOID P)
{
  int (__fastcall *v7)(void *, _QWORD, __int64, PVOID *); // rax
  __int64 v8; // r8
  _WORD *v9; // rcx
  unsigned __int64 v10; // r8
  __int64 v11; // rdi
  char v12; // al
  unsigned __int64 v13; // rdx
  char v15[48]; // [rsp+40h] [rbp-30h] BYREF

  P = a2;
  if ( KeGetCurrentIrql() )
    return 0;
  v7 = (int (__fastcall *)(void *, _QWORD, __int64, PVOID *))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                               qword_1400DAB60,
                                                               &qword_1400DAB60,
                                                               0i64);
  if ( !v7 || v7(&unk_1400D2D90, 0i64, v8, &P) < 0 )
    return 0;
  v9 = P;
  if ( *(_WORD *)P )
  {
    v10 = 0xFFFFFFFFFFFFFFFFui64;
    do
      ++v10;
    while ( *((_WORD *)P + v10) );
    JUMPOUT(0x140046680i64);
  }
  v11 = 0i64;
  do
  {
    if ( !v9[v11] )
      break;
    ((void (__fastcall *)(char *))loc_140007050)(v15);
    v12 = sub_140044F80(2i64, (__int64)v15, a3);
    v9 = P;
    v13 = 0xFFFFFFFFFFFFFFFFui64;
    do
      ++v13;
    while ( *((_WORD *)P + v11 + v13) );
    v11 += v13 + 1;
  }
  while ( v12 );
  ExFreePoolWithTag(v9, 0);
  return 1;
}
// 140046679: control flows out of bounds to 140046680
// 140046769: control flows out of bounds to 140046770
// 140046641: variable 'v8' is possibly undefined
// 1400DAB60: using guessed type __int64 qword_1400DAB60;

//----- (00000001400468A0) ----------------------------------------------------
NTSTATUS __fastcall sub_1400468A0(unsigned int a1, struct _DEVICE_OBJECT *a2, __int64 a3, unsigned int a4)
{
  NTSTATUS result; // eax
  __int64 (__fastcall *v9)(_QWORD, struct _DEVICE_OBJECT *, __int64, _QWORD); // rax
  IRP *v10; // rax
  NTSTATUS v11; // [rsp+50h] [rbp-38h]
  struct _KEVENT Event; // [rsp+60h] [rbp-28h] BYREF

  if ( !a2 )
    return 0xC000000D;
  if ( KeGetCurrentIrql() || (unsigned __int8)sub_14000ECDC() )
    return 0xC0000148;
  KeInitializeEvent(&Event, NotificationEvent, 0);
  v9 = (__int64 (__fastcall *)(_QWORD, struct _DEVICE_OBJECT *, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                                   qword_1400DAB48,
                                                                                   &qword_1400DAB48,
                                                                                   0i64);
  if ( !v9 )
    return 0xC0000017;
  v10 = (IRP *)v9(a1, a2, a3, a4);
  if ( !v10 )
    return 0xC0000017;
  result = IofCallDriver(a2, v10);
  if ( result == 0x103 )
  {
    sub_14000ED48((__int64)&Event);
    result = v11;
  }
  return result;
}
// 14004697B: variable 'v11' is possibly undefined
// 1400DAB48: using guessed type __int64 qword_1400DAB48;

//----- (000000014004771C) ----------------------------------------------------
char __fastcall sub_14004771C(__int64 a1)
{
  if ( *(_BYTE *)(a1 + 0x1F) != 0xFE )
    JUMPOUT(0x140047771i64);
  return 0;
}
// 14004776E: control flows out of bounds to 140047771

//----- (0000000140047850) ----------------------------------------------------
__int64 __fastcall sub_140047850(__int64 a1, __int64 a2)
{
  __int64 v2; // rbx
  _WORD *v5; // rdx
  char v6; // al
  unsigned __int64 v7; // r11
  _BYTE *v8; // rbx
  unsigned int v9; // ecx
  _BYTE *v10; // r10
  unsigned int v11; // eax
  char v12; // r9
  unsigned int v13; // er8
  char v14; // al
  __int64 v15; // rax
  _BYTE *v16; // rbx

  v2 = *(_QWORD *)(a2 + 8);
  *(_BYTE *)a1 = 0;
  *(_BYTE *)(a1 + 0x1F) = 0;
  if ( sub_14004771C(a1) )
  {
    v5 = *(_WORD **)a2;
    v6 = *(_BYTE *)(a1 + 0x1F);
    v7 = *(_QWORD *)a2 + 2 * v2;
    if ( v6 == (char)0xFF )
      v8 = *(_BYTE **)(a1 + 0x10);
    else
      v8 = (_BYTE *)a1;
    if ( (unsigned __int64)v5 < v7 )
    {
      do
      {
        v9 = (unsigned __int16)*v5++;
        if ( v9 - 0xD800 <= 0x3FF && (unsigned __int64)v5 < v7 && (unsigned __int16)(*v5 + 0x2400) <= 0x3FFu )
          v9 = (((v9 & 0x3FF) << 0xA) | *v5++ & 0x3FF) + 0x10000;
        v10 = v8 + 1;
        if ( v9 > 0x7F )
        {
          v11 = v9 >> 6;
          v12 = v9 & 0x3F | 0x80;
          if ( v9 > 0x7FF )
          {
            v13 = v9 >> 0xC;
            v14 = v11 & 0x3F | 0x80;
            if ( v9 > 0xFFFF )
            {
              *v8 = (v9 >> 0x12) | 0xF0;
              *v10 = v13 & 0x3F | 0x80;
              v8 += 4;
              v10[1] = v14;
              v10[2] = v12;
            }
            else
            {
              *v8 = v13 | 0xE0;
              v8 += 3;
              *v10 = v14;
              v10[1] = v12;
            }
          }
          else
          {
            *v8 = v11 | 0xC0;
            v8 += 2;
            *v10 = v12;
          }
        }
        else
        {
          *v8++ = v9;
        }
      }
      while ( (unsigned __int64)v5 < v7 );
      v6 = *(_BYTE *)(a1 + 0x1F);
    }
    if ( v6 == (char)0xFF )
      v15 = *(_QWORD *)(a1 + 0x10);
    else
      v15 = a1;
    v16 = &v8[-v15];
    if ( sub_14004771C(a1) )
    {
      if ( *(_BYTE *)(a1 + 0x1F) == 0xFF )
      {
        v16[*(_QWORD *)(a1 + 0x10)] = 0;
        *(_QWORD *)(a1 + 8) = v16;
      }
      else
      {
        v16[a1] = 0;
        *(_BYTE *)(a1 + 0x1F) = (_BYTE)v16;
      }
    }
  }
  return a1;
}

//----- (00000001400479D0) ----------------------------------------------------
void sub_1400479D0()
{
  JUMPOUT(0x1400479E4i64);
}
// 1400479DD: control flows out of bounds to 1400479E4

//----- (0000000140048808) ----------------------------------------------------
__int64 sub_140048808()
{
  __int64 (*v0)(void); // rax

  v0 = (__int64 (*)(void))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                            qword_1400DAE38,
                            &qword_1400DAE38,
                            0i64);
  return v0();
}
// 1400DAE38: using guessed type __int64 qword_1400DAE38;

//----- (000000014004882C) ----------------------------------------------------
__int64 sub_14004882C()
{
  __int64 (*v0)(void); // rax

  v0 = (__int64 (*)(void))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                            qword_1400DAE40,
                            &qword_1400DAE40,
                            0i64);
  return v0();
}
// 1400DAE40: using guessed type __int64 qword_1400DAE40;

//----- (0000000140048850) ----------------------------------------------------
__int64 __fastcall sub_140048850(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // rax
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAE68,
                                          &qword_1400DAE68,
                                          0i64);
  if ( v2 )
    result = v2(a1);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DAE68: using guessed type __int64 qword_1400DAE68;

//----- (000000014004888C) ----------------------------------------------------
__int64 __fastcall sub_14004888C(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAE70,
                                          &qword_1400DAE70,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAE70: using guessed type __int64 qword_1400DAE70;

//----- (00000001400488C4) ----------------------------------------------------
__int64 __fastcall sub_1400488C4(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAE78,
                                          &qword_1400DAE78,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAE78: using guessed type __int64 qword_1400DAE78;

//----- (00000001400488FC) ----------------------------------------------------
__int64 __fastcall sub_1400488FC(__int64 a1, __int64 a2)
{
  __int64 (__fastcall *v4)(__int64, __int64); // rax
  __int64 result; // rax

  v4 = (__int64 (__fastcall *)(__int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                   qword_1400DAEB8,
                                                   &qword_1400DAEB8,
                                                   0i64);
  if ( v4 )
    result = v4(a1, a2);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DAEB8: using guessed type __int64 qword_1400DAEB8;

//----- (0000000140048944) ----------------------------------------------------
__int64 __fastcall sub_140048944(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAEC0,
                                          &qword_1400DAEC0,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAEC0: using guessed type __int64 qword_1400DAEC0;

//----- (000000014004897C) ----------------------------------------------------
__int64 (__fastcall *__fastcall sub_14004897C(__int64 a1))(__int64)
{
  __int64 (__fastcall *result)(__int64); // rax

  result = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                              qword_1400DAEC8,
                                              &qword_1400DAEC8,
                                              0i64);
  if ( result )
    result = (__int64 (__fastcall *)(__int64))result(a1);
  return result;
}
// 1400DAEC8: using guessed type __int64 qword_1400DAEC8;

//----- (00000001400489AC) ----------------------------------------------------
__int64 __fastcall sub_1400489AC(__int64 a1, __int64 a2)
{
  __int64 (__fastcall *v4)(__int64, __int64); // rax
  __int64 result; // rax

  v4 = (__int64 (__fastcall *)(__int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                   qword_1400DAEF8,
                                                   &qword_1400DAEF8,
                                                   0i64);
  if ( v4 )
    result = v4(a1, a2);
  else
    result = 0xC0000002i64;
  return result;
}
// 1400DAEF8: using guessed type __int64 qword_1400DAEF8;

//----- (00000001400489F4) ----------------------------------------------------
__int64 __fastcall sub_1400489F4(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAF00,
                                          &qword_1400DAF00,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAF00: using guessed type __int64 qword_1400DAF00;

//----- (0000000140048A2C) ----------------------------------------------------
__int64 __fastcall sub_140048A2C(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAF08,
                                          &qword_1400DAF08,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAF08: using guessed type __int64 qword_1400DAF08;

//----- (0000000140048A64) ----------------------------------------------------
__int64 __fastcall sub_140048A64(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAF10,
                                          &qword_1400DAF10,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAF10: using guessed type __int64 qword_1400DAF10;

//----- (0000000140048A9C) ----------------------------------------------------
__int64 __fastcall sub_140048A9C(__int64 a1)
{
  __int64 (__fastcall *v2)(__int64); // r8
  __int64 result; // rax

  v2 = (__int64 (__fastcall *)(__int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                          qword_1400DAF20,
                                          &qword_1400DAF20,
                                          0i64);
  result = 0i64;
  if ( v2 )
    result = v2(a1);
  return result;
}
// 1400DAF20: using guessed type __int64 qword_1400DAF20;

//----- (0000000140049EEC) ----------------------------------------------------
void sub_140049EEC()
{
  if ( byte_1400DABE9 )
  {
    if ( qword_1400DADF8 )
    {
      sub_14001FBDC(qword_1400DADF8);
      qword_1400DADF8 = 0i64;
    }
    byte_1400DABE9 = 0;
  }
  if ( byte_1400DABEA )
  {
    if ( qword_1400DAF40 )
    {
      sub_14001FBDC(qword_1400DAF40);
      qword_1400DAF40 = 0i64;
    }
    byte_1400DABEA = 0;
  }
}
// 1400DABE9: using guessed type char byte_1400DABE9;
// 1400DABEA: using guessed type char byte_1400DABEA;

//----- (0000000140049F48) ----------------------------------------------------
void __fastcall sub_140049F48(__int64 a1, char a2)
{
  __int64 v4; // rax
  __int64 v5; // rdi
  __int64 v6; // r8
  __int64 v7; // r9
  char v8; // si
  __int64 v9; // rbx
  __int64 v10; // r8
  unsigned __int64 v11; // rdx
  unsigned __int64 i; // rcx
  void *v13; // [rsp+20h] [rbp-48h]
  char v14[16]; // [rsp+40h] [rbp-28h] BYREF
  char v15[16]; // [rsp+50h] [rbp-18h] BYREF

  if ( a1 )
  {
    v4 = sub_140051084(0x330ui64);
    v5 = v4;
    if ( v4 )
    {
      ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(v4, 0i64, 0x330i64);
      if ( !a2 || (v8 = 1, !sub_1400147FC(a1, (__int64)v15, v6, v7, v13)) )
        v8 = 0;
      sub_14004888C(a1);
      sub_140013EF0(a1);
      v9 = sub_140055ECC(0i64, 0, 0i64, 0x801);
      if ( v9 )
      {
        if ( !v8 )
        {
          if ( sub_1400144E4(a1, v14) )
          {
            v10 = v9 + 0x20;
            if ( v9 != 0xFFFFFFFFFFFFFFE0ui64 )
            {
              v11 = 0xFFFFFFFFFFFFFFFFui64;
              do
                ++v11;
              while ( v14[v11] );
              for ( i = 0i64; i < 0xFF; ++i )
              {
                if ( i >= v11 )
                  break;
                *(_WORD *)(v10 + 2 * i) = v14[i];
              }
              *(_WORD *)(v10 + 2 * i) = 0;
            }
          }
        }
        *(_QWORD *)v5 = v9;
        *(_DWORD *)(v5 + 0x28) = 1;
        *(_DWORD *)(v5 + 0x30) = 0x25650CE1;
        *(_DWORD *)(v5 + 0x40) = 0;
        *(_QWORD *)(v5 + 0x38) = 0i64;
        ((void (__fastcall *)(__int64, _QWORD))loc_14001FCD0)(v5, 0i64);
        sub_140051220(v9);
      }
      if ( v8 )
        sub_14000724C((__int64)v15);
      sub_140051220(v5);
    }
  }
}
// 140049FA3: variable 'v6' is possibly undefined
// 140049FA3: variable 'v7' is possibly undefined
// 140049FA3: variable 'v13' is possibly undefined

//----- (000000014004AF64) ----------------------------------------------------
bool __fastcall sub_14004AF64(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v7; // rdi
  __int64 *v8; // rax
  __int64 v9; // rax
  __int64 v10; // rbx

  a6 = 0i64;
  v7 = sub_14004888C(a1);
  ExAcquireFastMutex(&stru_1400DB0A0);
  v8 = sub_14001FA54(qword_1400DAF98, v7);
  if ( v8 )
  {
    v10 = *v8;
  }
  else
  {
    v9 = sub_14001449C(a1);
    if ( v9 && v9 == qword_1400D82F8 )
      JUMPOUT(0x14004AFC9i64);
    sub_14001F904(qword_1400DAF98, v7, (__int64)&a6, 8u);
    v10 = a6;
  }
  ExReleaseFastMutex(&stru_1400DB0A0);
  return v10 != 0;
}
// 14004AFC6: control flows out of bounds to 14004AFC9
// 1400D82F0: using guessed type int dword_1400D82F0;
// 1400D82F8: using guessed type __int64 qword_1400D82F8;

//----- (000000014004B014) ----------------------------------------------------
__int64 __usercall sub_14004B014@<rax>(_DWORD *a1@<rdx>, __int64 a2@<rcx>, int a3@<ebx>, __int16 a4@<r8w>, unsigned int a5@<r9d>)
{
  char v5; // si
  __int64 v9; // rdx
  char v10; // r12
  unsigned int v11; // edi
  unsigned __int64 v12; // rdx
  char v13; // dl
  char v14; // di
  unsigned int v15; // edi
  unsigned __int64 i; // rdx
  char v17; // dl
  unsigned int v18; // edx
  unsigned __int64 v19; // rdi
  unsigned __int64 j; // rdi
  char v21; // cl
  char v22; // dl
  unsigned int v23; // edx
  unsigned __int64 v24; // rdi
  unsigned __int64 k; // rdi
  char v26; // cl
  char v27; // dl
  int v28; // edx
  unsigned __int64 v29; // rdi
  int v30; // ecx
  int v32[2]; // [rsp+38h] [rbp-C8h]
  __int16 v33; // [rsp+40h] [rbp-C0h]
  char v34; // [rsp+42h] [rbp-BEh]
  int v35[3]; // [rsp+43h] [rbp-BDh]
  char v36; // [rsp+4Fh] [rbp-B1h]
  int v37[3]; // [rsp+50h] [rbp-B0h]
  __int16 v38; // [rsp+5Ch] [rbp-A4h]
  char v39; // [rsp+5Eh] [rbp-A2h]
  int v40[3]; // [rsp+5Fh] [rbp-A1h] BYREF
  int v41[3]; // [rsp+6Bh] [rbp-95h]
  __int64 v42[2]; // [rsp+77h] [rbp-89h] BYREF
  int *v43; // [rsp+88h] [rbp-78h]
  int v44; // [rsp+90h] [rbp-70h]
  int v45; // [rsp+94h] [rbp-6Ch]
  int v46; // [rsp+A0h] [rbp-60h]
  _BYTE v47[13]; // [rsp+B8h] [rbp-48h] BYREF
  _BYTE v48[15]; // [rsp+C5h] [rbp-3Bh] BYREF
  _BYTE v49[12]; // [rsp+D4h] [rbp-2Ch] BYREF
  __int64 v50[2]; // [rsp+E0h] [rbp-20h] BYREF
  char v51[48]; // [rsp+F0h] [rbp-10h] BYREF
  __int64 v52; // [rsp+120h] [rbp+20h]
  char v53[16]; // [rsp+128h] [rbp+28h] BYREF
  char v54[16]; // [rsp+138h] [rbp+38h] BYREF
  char v55[56]; // [rsp+148h] [rbp+48h] BYREF

  v5 = 0;
  LODWORD(v43) = 0;
  if ( sub_1400144E4(a2, v51) )
  {
    v10 = 1;
    if ( (char)a4 >= 0 )
      goto LABEL_7;
    v40[0] = 0xD1EF453B;
    *(_QWORD *)v49 = 0i64;
    v11 = 0x160C531B;
    *(_DWORD *)&v49[8] = 0;
    v12 = 0i64;
    v40[1] = 0x7B8A7970;
    v40[2] = 0x48A376F1;
    v43 = v40;
    do
    {
      v11 = 0xFFFFCFC7 - 0x41C64E6D * v11;
      *(_DWORD *)&v49[v12 * 4] = v43[v12] ^ v11;
      ++v12;
    }
    while ( v12 < 3 );
    v5 = 1;
    if ( sub_140007538((__int64)v51, v49, 0xBui64) )
      v13 = 1;
    else
LABEL_7:
      v13 = 0;
    if ( (v5 & 1) != 0 )
    {
      v5 &= 0xFEu;
      memset(v49, 0, sizeof(v49));
    }
    if ( v13 )
    {
      LOBYTE(a3) = 0;
      v14 = 0;
      LODWORD(v43) = a3;
      if ( a2 )
      {
        LOBYTE(v9) = 1;
        if ( sub_140014648(a2, v9, (__int64)v53) )
        {
          v14 = sub_14000ADD4((__int64)v53, (__int64)v54);
          sub_14000724C((__int64)v53);
        }
        if ( v14 )
        {
          v44 = 0xBF1BF1CA;
          v45 = 0x15922A69;
          JUMPOUT(0x14004B163i64);
        }
      }
      if ( sub_140015378(a2, (__int64)v55) )
      {
        v46 = 0x3A45343D;
        v52 = 0i64;
        JUMPOUT(0x14004B20Ei64);
      }
    }
    if ( !a1 || *a1 != 0x118 && *a1 != 0x17F && *a1 != 0x1EA )
      goto LABEL_28;
    v41[0] = 0x51934D1C;
    v50[0] = 0i64;
    v5 |= 2u;
    LODWORD(v50[1]) = 0;
    v15 = 0x63C2FB66;
    v41[1] = 0x3DE4E4E5;
    v41[2] = 0xF02E07BE;
    for ( i = 0i64; i < 3; ++i )
    {
      v15 = 0xFF3C613D - 0x43FD43FD * v15;
      *(_DWORD *)((char *)v50 + i * 4) = v41[i] ^ v15;
    }
    if ( sub_140007538((__int64)v51, v50, 0xBui64) )
      v17 = 1;
    else
LABEL_28:
      v17 = 0;
    if ( (v5 & 2) != 0 )
    {
      v5 &= 0xFDu;
      memset(v50, 0, 0xCui64);
    }
    if ( v17 )
      JUMPOUT(0x14004B3ADi64);
    if ( *a1 != 0x14 )
      goto LABEL_40;
    v32[0] = 0x423129A1;
    v42[0] = 0i64;
    v5 |= 4u;
    LOWORD(v42[1]) = 0;
    v18 = 0x127A7EF4;
    BYTE2(v42[1]) = 0;
    v19 = 0i64;
    v32[1] = 0x3CAC616A;
    v33 = 0x58F7;
    v34 = 0x33;
    do
    {
      *(_DWORD *)((char *)v42 + v19 * 4) = v32[v19] ^ v18;
      ++v19;
      v18 = 0xFF3C613C - 0x43FD43FD * v18;
    }
    while ( v19 < 2 );
    for ( j = 8i64; j < 0xB; ++j )
    {
      v21 = v18;
      v18 >>= 8;
      *((_BYTE *)v42 + j) = *((_BYTE *)v32 + j) ^ v21;
    }
    if ( sub_140007538((__int64)v51, v42, 0xAui64) )
      v22 = 1;
    else
LABEL_40:
      v22 = 0;
    if ( (v5 & 4) != 0 )
    {
      v5 &= 0xFBu;
      memset(v42, 0, 0xBui64);
    }
    if ( v22 )
      JUMPOUT(0x14004B4E9i64);
    if ( *a1 != 0x14A )
      goto LABEL_52;
    v37[0] = 0x315E8BF7;
    *(_QWORD *)v48 = 0i64;
    v5 |= 8u;
    *(_DWORD *)&v48[8] = 0;
    v23 = 0x562CEAA0;
    *(_WORD *)&v48[0xC] = 0;
    v24 = 0i64;
    v48[0xE] = 0;
    v37[1] = 0xC67274D9;
    v37[2] = 0xB2987BB2;
    v38 = 0x82CD;
    v39 = 0x41;
    do
    {
      *(_DWORD *)&v48[v24 * 4] = v37[v24] ^ v23;
      ++v24;
      v23 = ~(((v23 ^ (v23 >> 7)) << 9) ^ v23 ^ (v23 >> 7) ^ ((((v23 ^ (v23 >> 7)) << 9) ^ v23 ^ (v23 >> 7)) >> 0xD));
    }
    while ( v24 < 3 );
    for ( k = 0xCi64; k < 0xF; ++k )
    {
      v26 = v23;
      v23 >>= 8;
      v48[k] = *((_BYTE *)v37 + k) ^ v26;
    }
    if ( sub_140007538((__int64)v51, v48, 0xEui64) )
      v27 = 1;
    else
LABEL_52:
      v27 = 0;
    if ( (v5 & 8) != 0 )
    {
      v5 &= 0xF7u;
      memset(v48, 0, sizeof(v48));
    }
    if ( v27 )
      JUMPOUT(0x14004B614i64);
    if ( MEMORY[0xFFFFF7800000026C] < 0xAu )
      goto LABEL_62;
    if ( (a4 & 0x400) == 0 )
      goto LABEL_62;
    v35[0] = 0x687345EA;
    *(_QWORD *)v47 = 0i64;
    v5 |= 0x10u;
    *(_DWORD *)&v47[8] = 0;
    v28 = 0x1B122688;
    v47[0xC] = 0;
    v29 = 0i64;
    v35[1] = 0x3E32D6CB;
    v35[2] = 0x547C4D49;
    v36 = 0xE0;
    do
    {
      v30 = v35[v29] ^ v28;
      v28 = __ROL4__(0x343FD * v28 + 0x269EC3, 4);
      *(_DWORD *)&v47[v29 * 4] = v30;
      ++v29;
    }
    while ( v29 < 3 );
    v47[0xC] = v36 ^ v28;
    if ( !sub_140007538((__int64)v51, v47, 0xCui64) )
LABEL_62:
      v10 = 0;
    if ( (v5 & 0x10) != 0 )
      memset(v47, 0, sizeof(v47));
    if ( v10 )
      a5 |= 0x400u;
  }
  return a5;
}
// 14004B15C: control flows out of bounds to 14004B163
// 14004B20A: control flows out of bounds to 14004B20E
// 14004B3AA: control flows out of bounds to 14004B3AD
// 14004B4E5: control flows out of bounds to 14004B4E9
// 14004B611: control flows out of bounds to 14004B614
// 14004B126: variable 'v9' is possibly undefined

//----- (000000014004B770) ----------------------------------------------------
__int64 __fastcall sub_14004B770(__int64 a1, __int64 **a2)
{
  __int64 v4; // rax
  __int64 v5; // r8
  __int64 v7; // rax
  __int64 *v8; // rax

  v4 = sub_14004888C(a1);
  v5 = qword_1400D82F8;
  *a2 = 0i64;
  if ( v5 && v4 == v5 )
    return 1i64;
  if ( sub_14002FC18(v4) )
    return 2i64;
  v7 = sub_14004888C(a1);
  v8 = sub_140062BF4(v7);
  *a2 = v8;
  return v8 != 0i64 ? 3 : 0;
}
// 1400D82F8: using guessed type __int64 qword_1400D82F8;

//----- (000000014004CB24) ----------------------------------------------------
__int64 __fastcall sub_14004CB24(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 v4; // rbx
  __int64 v5; // rax
  __int64 v7; // [rsp+20h] [rbp-48h]

  v4 = 0i64;
  if ( a1 )
  {
    v5 = sub_140014BD0(a1, 0x1000i64, a3, 0x40i64, v7);
    v4 = v5;
    if ( v5 )
    {
      sub_140052288(v5, 0x1000i64);
      if ( *(_DWORD *)(a1 + 0x28) == 0x40 )
        JUMPOUT(0x14004CB6Ei64);
      JUMPOUT(0x14004CBBDi64);
    }
  }
  return v4;
}
// 14004CB6C: control flows out of bounds to 14004CB6E
// 14004CB6C: control flows out of bounds to 14004CBBD
// 14004CB45: variable 'v7' is possibly undefined

//----- (000000014004CC04) ----------------------------------------------------
__int64 __fastcall sub_14004CC04(__int64 a1)
{
  if ( a1 && a1 != 0xFFFFFFFFFFFFFFC0ui64 && *(_QWORD *)(a1 + 0x48) && *(_WORD *)(a1 + 0x40) && *(_WORD *)(a1 + 0x42) )
    JUMPOUT(0x14004CC50i64);
  return 0i64;
}
// 14004CC4A: control flows out of bounds to 14004CC50

//----- (000000014004CD14) ----------------------------------------------------
char __fastcall sub_14004CD14(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, void *a6, __int64 a7)
{
  unsigned __int64 v8; // rbx
  __int64 v9; // rax
  void *v10; // rsi
  __int64 v12; // [rsp+20h] [rbp-28h]

  v8 = 0i64;
  LOBYTE(v12) = 0;
  v9 = sub_140014BD0(a1, 0x1000i64, a3, 4i64, v12);
  v10 = (void *)v9;
  a7 = v9;
  if ( v9 )
  {
    sub_14005221C(v9, 0x28i64, 1);
    memset(v10, 0, 0x28ui64);
    a6 = v10;
    if ( a1 )
    {
      while ( v8 < 8 )
      {
        *((_BYTE *)&a6 + v8) ^= 0x90u;
        *(_BYTE *)(a1 + 4 * v8 + 0x1C) = *((_BYTE *)&a6 + v8);
        ++v8;
      }
    }
    LOBYTE(v8) = 1;
  }
  return v8;
}
// 14004CD33: variable 'v12' is possibly undefined

//----- (000000014004D158) ----------------------------------------------------
void __fastcall sub_14004D158(_QWORD *a1)
{
  __int64 v2; // rax
  __int64 v3; // rax
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rax
  _BYTE *v7; // rsi
  __int64 v8; // rdi
  __int64 v9; // r14
  __int64 v10; // r9
  __int64 v11; // [rsp+20h] [rbp-88h] BYREF
  __int64 v12; // [rsp+28h] [rbp-80h]
  __int64 v13; // [rsp+30h] [rbp-78h]
  unsigned int v14; // [rsp+38h] [rbp-70h]
  int v15[24]; // [rsp+40h] [rbp-68h] BYREF

  if ( a1 )
  {
    if ( sub_140048808() == a1[1] )
    {
      v2 = sub_140048808();
      v3 = sub_140014260(v2);
      if ( v3 )
      {
        if ( !*(_BYTE *)(v3 + 2) )
        {
          v11 = 0x66FDE8CE67F3BFFFi64;
          v12 = 0x88D42534BEA6080Eui64;
          v13 = 0x4B7839C0A4E39AEAi64;
          LOWORD(v14) = 0x1A48;
          v4 = ((__int64 (__fastcall *)(__int64 *, int *))loc_14004D360)(&v11, v15);
          v5 = sub_140052728(v4);
          memset(v15, 0, 0x1Aui64);
          if ( v5 )
          {
            v15[0] = 0x44C9D8AB;
            v15[1] = 0x4D6F12BD;
            v15[2] = 0x94759150;
            LOBYTE(v15[3]) = 0xA1;
            v6 = sub_14004D3F4((__int64)v15, (__int64)&v11);
            v7 = (_BYTE *)v6;
            v8 = a1[0x17];
            v9 = a1[0x16];
            if ( v9 && v8 && v6 )
            {
              if ( (unsigned int)sub_140052894(a1[0x17]) == 0x40 )
                sub_140031DB4(v9, v8, v7, v10, v11, v12, v13, v14);
              else
                sub_140031BA0(v9, v8, v7, v10, v11, v12, v13, v14);
            }
            memset(&v11, 0, 0xDui64);
            sub_14005221C(a1[0x2C], 0x3Ci64, 1);
            JUMPOUT(0x14004D2B8i64);
          }
        }
      }
    }
  }
}
// 14004D2B1: control flows out of bounds to 14004D2B8
// 14004D284: variable 'v10' is possibly undefined

//----- (000000014004D3F4) ----------------------------------------------------
__int64 __fastcall sub_14004D3F4(__int64 a1, __int64 a2)
{
  int v2; // er8
  unsigned __int64 v3; // r10
  __int64 result; // rax

  *(_QWORD *)a2 = 0i64;
  v2 = 0x2ABBBDC0;
  *(_DWORD *)(a2 + 8) = 0;
  v3 = 0i64;
  *(_BYTE *)(a2 + 0xC) = 0;
  do
  {
    *(_DWORD *)(a2 + v3) = *(_DWORD *)(a1 + v3) ^ v2;
    v3 += 4i64;
    v2 = __ROR4__(
           ((v2 ^ (unsigned int)(v2 << 0xD)) >> 0x11) ^ v2 ^ (v2 << 0xD) ^ (0x20
                                                                          * (((v2 ^ (unsigned int)(v2 << 0xD)) >> 0x11) ^ v2 ^ (v2 << 0xD))),
           2);
  }
  while ( v3 < 0xC );
  result = a2;
  *(_BYTE *)(a2 + 0xC) = *(_BYTE *)(a1 + 0xC) ^ v2;
  return result;
}

//----- (000000014004D7B0) ----------------------------------------------------
__int64 __fastcall sub_14004D7B0(__int64 a1)
{
  __int64 result; // rax
  int v3[14]; // [rsp+60h] [rbp-F8h] BYREF
  char v4[16]; // [rsp+98h] [rbp-C0h] BYREF
  int v5; // [rsp+A8h] [rbp-B0h]
  __int64 v6; // [rsp+B0h] [rbp-A8h]
  char *v7; // [rsp+B8h] [rbp-A0h]
  int v8; // [rsp+C0h] [rbp-98h]
  char v9[128]; // [rsp+D8h] [rbp-80h] BYREF

  v3[0] = 0x8074D699;
  v3[1] = 0xB76791E9;
  v3[2] = 0xFE08E588;
  v3[3] = 0x3F4F4E85;
  v3[4] = 0x843CD98;
  v3[5] = 0x8EF416A7;
  v3[6] = 0x252155F8;
  v3[7] = 0x39F93E1C;
  v3[8] = 0x76F97C36;
  v3[9] = 0x1F21C2F9;
  v3[0xA] = 0x1213965;
  ((void (__fastcall *)(int *, char *))loc_14004D9E4)(v3, v9);
  if ( a1 && !KeGetCurrentIrql() && !(unsigned __int8)sub_14000ECDC() )
  {
    ((void (__fastcall *)(char *, char *))loc_140007050)(v4, v9);
    v5 = 0x30;
    v6 = 0i64;
    v8 = 0x40;
    v7 = v4;
    JUMPOUT(0x14004D899i64);
  }
  result = 0i64;
  memset(v9, 0, 0x2Cui64);
  return result;
}
// 14004D891: control flows out of bounds to 14004D899

//----- (000000014004DA3C) ----------------------------------------------------
void __fastcall sub_14004DA3C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object)
{
  void *v5; // rbx
  PVOID v6; // rbx
  void (__fastcall *v7)(PVOID); // rax

  if ( a1 )
  {
    v5 = (void *)_InterlockedExchange64((volatile __int64 *)(a1 + 0xE0), 0i64);
    if ( v5 )
    {
      if ( ObReferenceObjectByHandle(v5, 0, 0i64, 1, &Object, 0i64) >= 0 )
      {
        ObCloseHandle(v5, 1);
        if ( qword_1400D8240 )
        {
          v6 = Object;
          v7 = (void (__fastcall *)(PVOID))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                             qword_1400DACE8,
                                             &qword_1400DACE8,
                                             0i64);
          if ( v7 )
            v7(v6);
        }
        else
        {
          ObfDereferenceObject(Object);
        }
      }
    }
  }
}
// 1400D8240: using guessed type __int64 qword_1400D8240;
// 1400DACE8: using guessed type __int64 qword_1400DACE8;

//----- (000000014004DACC) ----------------------------------------------------
void **__fastcall sub_14004DACC(__int64 a1)
{
  void **result; // rax
  ULONG64 v3; // rcx
  int *v4; // r15
  __int64 v5; // r12
  int v6; // [rsp+30h] [rbp-78h] BYREF
  int v7; // [rsp+34h] [rbp-74h]
  __int64 v8; // [rsp+38h] [rbp-70h]
  int v9; // [rsp+40h] [rbp-68h]
  int v10; // [rsp+44h] [rbp-64h]
  __int16 v11; // [rsp+48h] [rbp-60h]
  int v12; // [rsp+50h] [rbp-58h] BYREF
  _BYTE v13[20]; // [rsp+54h] [rbp-54h]
  int v14; // [rsp+68h] [rbp-40h]
  int v15; // [rsp+6Ch] [rbp-3Ch]
  __int16 v16; // [rsp+70h] [rbp-38h]
  void *retaddr; // [rsp+A8h] [rbp+0h] BYREF

  result = &retaddr;
  v12 = 0x48515756;
  *(_QWORD *)v13 = 0xBEi64;
  *(_QWORD *)&v13[8] = 0xBF4800i64;
  *(_DWORD *)&v13[0x10] = 0xB9000000;
  v14 = 8;
  v15 = 0x5F59A5F3;
  v16 = 0xC35E;
  v6 = 0xBE515756;
  v7 = 0;
  v8 = 0x8B900000000BFi64;
  v9 = 0xA5F30000;
  v10 = 0xC25E5F59;
  v11 = 4;
  if ( a1 )
  {
    v3 = *(_QWORD *)(a1 + 0x88);
    if ( v3 )
    {
      result = *(void ***)(a1 + 0x90);
      if ( result )
      {
        if ( *(_DWORD *)(a1 + 0x28) == 0x40 )
        {
          v4 = &v12;
          v5 = 0x22i64;
          *(_QWORD *)&v13[1] = result + 0x20;
          *(_QWORD *)&v13[0xB] = v3;
        }
        else
        {
          v4 = &v6;
          v5 = 0x1Ai64;
          v7 = (_DWORD)result + 0x100;
          *(_DWORD *)((char *)&v8 + 1) = v3;
        }
        sub_14005221C(v3, 0x20i64, 1);
        sub_14005221C(*(_QWORD *)(a1 + 0x90), 0x1000i64, 1);
        ((void (__fastcall *)(_QWORD, int *, __int64))loc_14006F000)(*(_QWORD *)(a1 + 0x90), v4, v5);
        JUMPOUT(0x14004DC0Ei64);
      }
    }
  }
  return result;
}
// 14004DC07: control flows out of bounds to 14004DC0E

//----- (000000014004EAEC) ----------------------------------------------------
char __fastcall sub_14004EAEC(__int64 a1, __int64 a2, __int64 a3, __int64 a4, _DWORD *a5)
{
  _DWORD *v6; // rbx
  ULONG64 v7; // rcx
  __int64 v8; // rdx
  unsigned __int64 i; // rcx

  v6 = 0i64;
  if ( a1 )
  {
    v7 = *(_QWORD *)(a1 + 0x160);
    if ( v7 )
    {
      sub_14005221C(v7, 0x3Ci64, 1);
      v8 = *(_QWORD *)(a1 + 0x160);
      a5 = 0i64;
      if ( v8 )
      {
        for ( i = 0i64; i < 8; ++i )
        {
          *((_BYTE *)&a5 + i) = *(_BYTE *)(v8 + 4 * i + 0x1C) ^ 0x90;
          v6 = a5;
        }
      }
      sub_14005221C((ULONG64)v6, 0x28i64, 1);
      LOBYTE(v6) = *v6 == 0x40031000;
    }
  }
  return (char)v6;
}

//----- (000000014004EC50) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_14004EC50()
{
  JUMPOUT(0x14004EC6Ci64);
}
// 14004ED7E: positive sp value 38 has been found
// 14004EC69: control flows out of bounds to 14004EC6C

//----- (000000014004F004) ----------------------------------------------------
__int64 __fastcall sub_14004F004(__int64 a1)
{
  struct _FAST_MUTEX *v2; // rdi
  __int64 v3; // rsi
  __int64 v4; // rax

  if ( !a1 || KeGetCurrentIrql() > 1u )
    return 0i64;
  v2 = (struct _FAST_MUTEX *)(a1 + 0x178);
  ExAcquireFastMutex((PFAST_MUTEX)(a1 + 0x178));
  v3 = *(_QWORD *)(a1 + 0x170);
  v4 = *(_QWORD *)(a1 + 0x168);
  *(_QWORD *)(a1 + 0x170) = v3 + 0x230;
  if ( v3 + 0x460 > (unsigned __int64)(v4 + 0x10000) )
    *(_QWORD *)(a1 + 0x170) = v4;
  ExReleaseFastMutex(v2);
  return v3;
}

//----- (000000014004FA88) ----------------------------------------------------
__int64 __fastcall sub_14004FA88(__int64 a1)
{
  __int64 result; // rax

  if ( a1 )
    result = sub_14000ED48(a1);
  return result;
}

//----- (0000000140050F30) ----------------------------------------------------
__int64 sub_140050F30()
{
  __int64 v0; // rax
  __int64 v1; // r8
  __int64 v2; // rax
  __int64 v3; // r8
  __int64 result; // rax
  int v5; // [rsp+20h] [rbp-20h] BYREF
  int v6; // [rsp+24h] [rbp-1Ch]
  int v7; // [rsp+28h] [rbp-18h]
  int v8; // [rsp+2Ch] [rbp-14h]
  int v9; // [rsp+30h] [rbp-10h]

  v5 = 0xEC1D6664;
  v6 = 0x55DF4CB1;
  v7 = 0xAA1713F5;
  v8 = 0xBC2BF4D2;
  v9 = 0xD00AD319;
  qword_1400D8260 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(&v5);
  v5 = 0x822C34AB;
  v6 = 0xC3475763;
  v7 = 0x2665F28B;
  v8 = 0x9928B059;
  v9 = 0xD45DE437;
  qword_1400D8268 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(&v5);
  v5 = 0x79ADFB62;
  v6 = 0xEE1D9CA3;
  v7 = 0x68520599;
  v8 = 0x96B26451;
  v9 = 0x8C0CFA2F;
  v0 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(&v5);
  LOBYTE(v1) = 1;
  qword_1400DB1B8 = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v0, &qword_1400DB1B8, v1);
  v5 = 0xF35E042B;
  v6 = 0x9300E8D7;
  v7 = 0x91DA3EE5;
  v8 = 0x34E9AF5F;
  v9 = 0x31CF0D71;
  v2 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(&v5);
  LOBYTE(v3) = 1;
  result = ((__int64 (__fastcall *)(__int64, __int64 *, __int64))loc_1400404E8)(v2, &qword_1400DB1C0, v3);
  qword_1400DB1C0 = result;
  return result;
}
// 140050FD8: variable 'v1' is possibly undefined
// 14005101D: variable 'v3' is possibly undefined
// 1400D8260: using guessed type __int64 qword_1400D8260;
// 1400D8268: using guessed type __int64 qword_1400D8268;
// 1400DB1B8: using guessed type __int64 qword_1400DB1B8;
// 1400DB1C0: using guessed type __int64 qword_1400DB1C0;

//----- (0000000140051030) ----------------------------------------------------
__int64 __fastcall sub_140051030(__int64 a1, __int64 a2, __int64 a3)
{
  __int64 (__fastcall *v6)(__int64, __int64, __int64); // r9
  __int64 result; // rax

  v6 = (__int64 (__fastcall *)(__int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                            qword_1400DB1B8,
                                                            &qword_1400DB1B8,
                                                            0i64);
  result = 0i64;
  if ( v6 )
    result = v6(a1, a2, a3);
  return result;
}
// 1400DB1B8: using guessed type __int64 qword_1400DB1B8;

//----- (0000000140051084) ----------------------------------------------------
__int64 __fastcall sub_140051084(unsigned __int64 a1)
{
  int v2; // eax

  v2 = sub_14000A890(0, 0x2D);
  return sub_140051108(a1, *(_DWORD *)&aClfcclficlfocl[4 * v2]);
}

//----- (00000001400510B4) ----------------------------------------------------
void *__fastcall sub_1400510B4(__int64 a1, __int64 a2)
{
  int v4; // eax
  unsigned __int64 v5; // rbx
  void *result; // rax

  v4 = sub_14000A890(0, 0x2D);
  v5 = a2 * a1;
  result = (void *)sub_140051108(v5, *(_DWORD *)&aClfcclficlfocl[4 * v4]);
  if ( result )
    memset(result, 0, v5);
  return result;
}

//----- (0000000140051108) ----------------------------------------------------
__int64 __fastcall sub_140051108(unsigned __int64 a1, unsigned int a2)
{
  unsigned __int64 v2; // rbp
  unsigned int v5; // esi
  __int64 (__fastcall *v6)(_QWORD, unsigned __int64, _QWORD); // rax
  __int64 v7; // rax

  v2 = a1 + 0x10;
  if ( a1 && v2 > a1 && a2 )
  {
    if ( MEMORY[0xFFFFF7800000026C] > 6u
      || MEMORY[0xFFFFF7800000026C] == 6 && (unsigned int)(MEMORY[0xFFFFF78000000270] - 2) <= 1 )
    {
      v5 = 0x200;
    }
    else
    {
      v5 = 0;
    }
    v6 = (__int64 (__fastcall *)(_QWORD, unsigned __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400D8760,
                                                                     &qword_1400D8760,
                                                                     0i64);
    if ( v6 )
    {
      v7 = v6(v5, v2, a2);
      if ( v7 )
      {
        *(_DWORD *)v7 = a2;
        *(_QWORD *)(v7 + 8) = a1;
      }
    }
    _InterlockedIncrement(dword_1400DAF64);
    _InterlockedExchangeAdd(dword_1400DB1C8, a1);
    JUMPOUT(0x1400511BEi64);
  }
  return 0i64;
}
// 1400511B7: control flows out of bounds to 1400511BE
// 1400D8760: using guessed type __int64 qword_1400D8760;

//----- (0000000140051220) ----------------------------------------------------
void __fastcall sub_140051220(__int64 a1)
{
  __int64 v1; // rbx
  unsigned int v2; // edi
  void (__fastcall *v3)(__int64, _QWORD); // rax

  if ( a1 )
  {
    v1 = a1 - 0x10;
    _InterlockedExchangeAdd(dword_1400DB1C8, -*(_DWORD *)(a1 - 0x10 + 8));
    _InterlockedDecrement(dword_1400DAF64);
    v2 = *(_DWORD *)(a1 - 0x10);
    v3 = (void (__fastcall *)(__int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                 qword_1400D8768,
                                                 &qword_1400D8768,
                                                 0i64);
    if ( v3 )
      v3(v1, v2);
  }
}
// 1400D8768: using guessed type __int64 qword_1400D8768;

//----- (00000001400521EC) ----------------------------------------------------
char sub_1400521EC()
{
  __int64 v0; // rax

  v0 = ((__int64 (*)(void))loc_140052148)();
  if ( v0 && (*(_BYTE *)v0 & 1) != 0 && (*(_DWORD *)(v0 + 4) & 1) != 0 )
    JUMPOUT(0x140052211i64);
  return 0;
}
// 14005220E: control flows out of bounds to 140052211

//----- (000000014005221C) ----------------------------------------------------
ULONG64 __fastcall sub_14005221C(ULONG64 a1, __int64 a2, int a3)
{
  ULONG64 v4; // rcx
  ULONG64 result; // rax

  if ( a2 )
  {
    if ( a3 != 1 && a3 != 8 )
      ExRaiseDatatypeMisalignment();
    if ( ((a3 - 1) & (unsigned int)a1) != 0 )
      ExRaiseDatatypeMisalignment();
    v4 = a1 + a2 - 1;
    if ( v4 < a1 || (result = MmUserProbeAddress, v4 >= MmUserProbeAddress) )
      ExRaiseAccessViolation();
  }
  return result;
}

//----- (0000000140052288) ----------------------------------------------------
char __fastcall sub_140052288(unsigned __int64 a1, __int64 a2)
{
  unsigned __int64 v2; // rbx
  ULONG64 v3; // rdi
  unsigned __int64 v4; // rdi
  char result; // al

  if ( a2 )
  {
    v2 = a1;
    v3 = a1 + a2 - 1;
    if ( v3 < a1 || v3 >= MmUserProbeAddress )
      ExRaiseAccessViolation();
    v4 = (v3 & 0xFFFFFFFFFFFFF000ui64) + 0x1000;
    do
    {
      result = *(_BYTE *)v2;
      *(_BYTE *)v2 = *(_BYTE *)v2;
      v2 = (v2 & 0xFFFFFFFFFFFFF000ui64) + 0x1000;
    }
    while ( v2 != v4 );
  }
  return result;
}

//----- (00000001400522E4) ----------------------------------------------------
__int64 __fastcall sub_1400522E4(__int64 a1, unsigned __int64 a2)
{
  __int64 v3; // rdx
  __int64 v4; // r8
  __int16 v5; // cx
  bool v6; // zf

  if ( a1 )
  {
    if ( a2 >= 0x1000 && *(_WORD *)a1 == 0x5A4D )
    {
      v3 = *(int *)(a1 + 0x3C);
      if ( (int)v3 > 0 && (unsigned int)v3 <= a2 - 0x108 )
      {
        v4 = v3 + a1;
        if ( *(_DWORD *)(v3 + a1) == 0x4550 )
        {
          v5 = *(_WORD *)(v4 + 0x18);
          if ( v5 == 0x10B && *(_WORD *)(v4 + 0x14) == 0xE0 && *(_WORD *)(v4 + 4) == 0x14C )
          {
            v6 = *(_DWORD *)(v4 + 0x74) == 0x10;
          }
          else
          {
            if ( v5 != 0x20B || *(_WORD *)(v4 + 0x14) != 0xF0 || *(_WORD *)(v4 + 4) != 0x8664 )
              return 0i64;
            v6 = *(_DWORD *)(v4 + 0x84) == 0x10;
          }
          if ( v6 )
            JUMPOUT(0x1400523B6i64);
        }
      }
    }
  }
  return 0i64;
}
// 1400523B3: control flows out of bounds to 1400523B6

//----- (00000001400523E4) ----------------------------------------------------
char __fastcall sub_1400523E4(__int64 a1)
{
  __int16 v1; // ax
  char result; // al

  if ( !a1 )
    goto LABEL_6;
  v1 = *(_WORD *)(a1 + 0x18);
  if ( v1 == 0x10B )
    return 0x20;
  if ( v1 == 0x20B )
    result = 0x40;
  else
LABEL_6:
    result = 0;
  return result;
}

//----- (000000014005240C) ----------------------------------------------------
char __fastcall sub_14005240C(__int64 a1, unsigned __int64 a2, __int64 *a3, __int64 *a4)
{
  char v7; // bl
  __int64 v8; // rax

  v7 = 0;
  v8 = sub_1400522E4(a1, a2);
  if ( v8 )
  {
    if ( a3 )
      *a3 = a1;
    if ( a4 )
      *a4 = v8;
    v7 = 1;
  }
  return v7;
}

//----- (0000000140052460) ----------------------------------------------------
_DWORD *__fastcall sub_140052460(unsigned __int64 a1, __int64 a2)
{
  unsigned __int16 v2; // r11
  _DWORD *v3; // r8
  bool v5; // cf
  unsigned __int16 v6; // r9
  int v7; // eax
  unsigned __int64 v8; // rcx

  v2 = *(_WORD *)(a2 + 6);
  v3 = (_DWORD *)(*(unsigned __int16 *)(a2 + 0x14) + a2 + 0x18);
  v5 = v2 != 0;
  v6 = 0;
  while ( v5 )
  {
    v7 = v3[2];
    if ( !v7 )
      v7 = v3[4];
    v8 = (unsigned int)v3[3];
    if ( a1 >= v8 && a1 < (unsigned int)(v7 + v8) )
      return v3;
    ++v6;
    v3 += 0xA;
    v5 = v6 < v2;
  }
  return 0i64;
}

//----- (00000001400524BC) ----------------------------------------------------
_DWORD *__fastcall sub_1400524BC(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  _DWORD *result; // rax

  result = sub_140052460(a1, a2);
  if ( result )
    result = (_DWORD *)(a3 + a1 - (unsigned int)(result[3] - result[5]));
  return result;
}

//----- (00000001400524F0) ----------------------------------------------------
__int64 __fastcall sub_1400524F0(unsigned __int64 a1, __int64 a2, __int64 a3)
{
  __int64 v3; // rax
  __int64 v4; // r9
  unsigned __int64 v5; // rdx
  unsigned int *v6; // r9
  unsigned __int64 v7; // r10
  unsigned __int64 v9; // rcx
  __int64 result; // rax

  v3 = *(unsigned __int16 *)(a2 + 0x14);
  v4 = a2 + 0x18;
  v5 = *(unsigned __int16 *)(a2 + 6);
  v6 = (unsigned int *)(v3 + v4);
  v7 = 0i64;
  if ( !v5 )
    goto LABEL_5;
  while ( 1 )
  {
    v9 = v6[5];
    if ( a1 >= v9 && a1 < (unsigned int)v9 + v6[4] )
      break;
    ++v7;
    v6 += 0xA;
    if ( v7 >= v5 )
      goto LABEL_5;
  }
  if ( v6 )
    result = a3 + a1 + v6[3] - (unsigned __int64)v6[5];
  else
LABEL_5:
    result = 0i64;
  return result;
}

//----- (0000000140052544) ----------------------------------------------------
__int64 __fastcall sub_140052544(__int64 a1)
{
  unsigned __int64 v2; // rbx
  PEPROCESS v3; // rax
  __int64 v4; // rax
  __int64 v5; // rdi
  __int64 v6; // rdi
  unsigned int *v7; // rdi
  ULONG64 v8; // rcx
  __int64 v9; // r8
  __int64 v10; // r9
  __int16 v12; // [rsp+28h] [rbp-20h] BYREF
  unsigned __int16 v13; // [rsp+2Ah] [rbp-1Eh]
  ULONG64 v14; // [rsp+30h] [rbp-18h]

  v2 = 0i64;
  v3 = IoGetCurrentProcess();
  v4 = sub_140014298((__int64)v3);
  v5 = v4;
  if ( v4 )
  {
    sub_14005221C(v4, 0x3Ci64, 1);
    v6 = *(unsigned int *)(v5 + 0xC);
    if ( v6 )
    {
      sub_14005221C((unsigned int)v6, 0x24i64, 1);
      v7 = (unsigned int *)*(unsigned int *)(v6 + 0xC);
      if ( v7 )
      {
        sub_14005221C((unsigned int)v7, 0x44i64, 1);
        if ( a1 )
        {
          while ( v7[6] )
          {
            v12 = *((_WORD *)v7 + 0x16);
            v13 = *((_WORD *)v7 + 0x17);
            v8 = v7[0xC];
            v14 = v8;
            sub_14005221C(v8, v13, 1);
            LOBYTE(v9) = 1;
            if ( !sub_140006F00((__int64)&v12, a1, v9, v10) )
              goto LABEL_7;
            v7 = (unsigned int *)*v7;
            sub_14005221C((unsigned int)v7, 0x44i64, 1);
          }
        }
        else
        {
LABEL_7:
          v2 = v7[6];
        }
      }
    }
  }
  return v2 & -(__int64)(v2 < (unsigned __int64)MmHighestUserAddress);
}
// 1400525F5: variable 'v9' is possibly undefined
// 1400525F5: variable 'v10' is possibly undefined

//----- (0000000140052648) ----------------------------------------------------
__int64 __fastcall sub_140052648(__int64 a1)
{
  unsigned __int64 v2; // rbx
  PEPROCESS v3; // rax
  __int64 v4; // rax
  __int64 v5; // rdi
  ULONG64 v6; // rdi
  __int64 v7; // r8
  __int64 v8; // r9

  v2 = 0i64;
  v3 = IoGetCurrentProcess();
  v4 = sub_140014260((__int64)v3);
  if ( v4 )
  {
    v5 = *(_QWORD *)(v4 + 0x18);
    if ( v5 )
    {
      sub_14005221C(*(_QWORD *)(v4 + 0x18), 0x40i64, 1);
      v6 = *(_QWORD *)(v5 + 0x10);
      if ( v6 )
      {
        sub_14005221C(v6, 0x88i64, 1);
        if ( a1 )
        {
          while ( *(_QWORD *)(v6 + 0x30) )
          {
            sub_14005221C(*(_QWORD *)(v6 + 0x60), *(unsigned __int16 *)(v6 + 0x5A), 1);
            LOBYTE(v7) = 1;
            if ( !sub_140006F00(v6 + 0x58, a1, v7, v8) )
              goto LABEL_7;
            v6 = *(_QWORD *)v6;
            sub_14005221C(v6, 0x88i64, 1);
          }
        }
        else
        {
LABEL_7:
          v2 = *(_QWORD *)(v6 + 0x30);
        }
      }
    }
  }
  return v2 & -(__int64)(v2 < (unsigned __int64)MmHighestUserAddress);
}
// 1400526D2: variable 'v7' is possibly undefined
// 1400526D2: variable 'v8' is possibly undefined

//----- (0000000140052728) ----------------------------------------------------
__int64 __fastcall sub_140052728(__int64 a1)
{
  __int64 v2; // rax
  __int64 result; // rax

  v2 = sub_140048808();
  if ( (unsigned int)sub_140013EF0(v2) == 0x20 )
    result = sub_140052544(a1);
  else
    result = sub_140052648(a1);
  return result;
}

//----- (000000014005275C) ----------------------------------------------------
unsigned int *__fastcall sub_14005275C(__int64 a1)
{
  PEPROCESS v2; // rax
  __int64 v3; // rax
  __int64 v4; // rbx
  __int64 v5; // rbx
  unsigned int *v6; // rbx
  __int64 v7; // rax

  if ( a1 )
  {
    v2 = IoGetCurrentProcess();
    v3 = sub_140014298((__int64)v2);
    v4 = v3;
    if ( v3 )
    {
      sub_14005221C(v3, 0x3Ci64, 1);
      v5 = *(unsigned int *)(v4 + 0xC);
      if ( v5 )
      {
        sub_14005221C((unsigned int)v5, 0x24i64, 1);
        v6 = (unsigned int *)*(unsigned int *)(v5 + 0xC);
        if ( v6 )
        {
          sub_14005221C((unsigned int)v6, 0x44i64, 1);
          while ( 1 )
          {
            v7 = v6[6];
            if ( !(_DWORD)v7 )
              break;
            if ( v7 == a1 )
              return v6;
            v6 = (unsigned int *)*v6;
            sub_14005221C((unsigned int)v6, 0x44i64, 1);
          }
        }
      }
    }
  }
  return 0i64;
}

//----- (00000001400527FC) ----------------------------------------------------
_QWORD *__fastcall sub_1400527FC(__int64 a1)
{
  PEPROCESS v2; // rax
  __int64 v3; // rax
  __int64 v4; // rbx
  _QWORD *v5; // rbx
  __int64 v6; // rax

  if ( a1 )
  {
    v2 = IoGetCurrentProcess();
    v3 = sub_140014260((__int64)v2);
    if ( v3 )
    {
      v4 = *(_QWORD *)(v3 + 0x18);
      if ( v4 )
      {
        sub_14005221C(*(_QWORD *)(v3 + 0x18), 0x40i64, 1);
        v5 = *(_QWORD **)(v4 + 0x10);
        if ( v5 )
        {
          sub_14005221C((ULONG64)v5, 0x88i64, 1);
          while ( 1 )
          {
            v6 = v5[6];
            if ( !v6 )
              break;
            if ( v6 == a1 )
              return v5;
            v5 = (_QWORD *)*v5;
            sub_14005221C((ULONG64)v5, 0x88i64, 1);
          }
        }
      }
    }
  }
  return 0i64;
}

//----- (0000000140052894) ----------------------------------------------------
__int64 __fastcall sub_140052894(ULONG64 a1)
{
  unsigned int v2; // ebx
  __int64 v3; // rax

  v2 = 0;
  sub_14005221C(a1, 0x1000i64, 1);
  v3 = sub_1400522E4(a1, 0x1000ui64);
  if ( v3 )
    v2 = (unsigned __int8)sub_1400523E4(v3);
  return v2;
}

//----- (00000001400528EC) ----------------------------------------------------
__int64 __fastcall sub_1400528EC(__int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  __int16 v5; // cx

  if ( a1 && a2 >= 0x1000 && sub_14005240C(a1, a2, 0i64, &a5) )
  {
    v5 = *(_WORD *)(a5 + 4);
    if ( v5 == 0x14C )
      return 0x20i64;
    if ( v5 == (__int16)0x8664 )
      return 0x40i64;
  }
  return 0i64;
}

//----- (0000000140052944) ----------------------------------------------------
ULONG64 __fastcall sub_140052944(ULONG64 a1)
{
  ULONG64 v2; // rbx
  __int64 v3; // rax

  v2 = 0i64;
  sub_14005221C(a1, 0x1000i64, 1);
  v3 = sub_1400522E4(a1, 0x1000ui64);
  if ( v3 )
    v2 = sub_1400529A0(a1, v3);
  return v2;
}

//----- (00000001400529A0) ----------------------------------------------------
ULONG64 __fastcall sub_1400529A0(__int64 a1, __int64 a2)
{
  ULONG64 v3; // [rsp+20h] [rbp-18h]

  v3 = a1 + *(unsigned int *)(a2 + 0x28);
  sub_14005221C(v3, 8i64, 1);
  return v3;
}

//----- (00000001400529D4) ----------------------------------------------------
__int64 __fastcall sub_1400529D4(ULONG64 a1, __int64 a2)
{
  if ( !a1 || !a2 )
    return 0i64;
  if ( (unsigned int)sub_140052894(a1) )
    JUMPOUT(0x140052A27i64);
  return 0i64;
}
// 140052A24: control flows out of bounds to 140052A27

//----- (0000000140052B44) ----------------------------------------------------
unsigned __int64 __fastcall sub_140052B44(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned __int64 v7; // rbx
  unsigned __int64 v8; // r14
  __int64 v9; // r8
  unsigned int v10; // er9
  unsigned __int16 *v11; // rdx
  char *v12; // rax
  __int64 v14; // [rsp+28h] [rbp-20h]
  __int64 v15; // [rsp+38h] [rbp-10h]
  _BYTE *v16; // [rsp+40h] [rbp-8h]

  v7 = 0i64;
  v8 = a1 + a2;
  if ( !a1 || !a2 || !a3 )
    return 0i64;
  if ( sub_14005240C(a1, a2, 0i64, &a5) )
  {
    v9 = *(unsigned int *)(a5 + 0x88);
    if ( (_DWORD)v9 )
    {
      v10 = *(_DWORD *)(a5 + 0x8C);
      if ( v10 )
      {
        v11 = (unsigned __int16 *)(a1 + v9);
        if ( a1 + v9 >= a1 )
        {
          v12 = (char *)v11 + v10;
          if ( v12 > (char *)v11 && (unsigned __int64)v12 <= v8 )
            v7 = sub_14005316C(a1, v11, v9, v10, a3, v14, 0i64, v15, v16);
        }
      }
    }
  }
  return v7;
}
// 140052BC6: variable 'v14' is possibly undefined
// 140052BC6: variable 'v15' is possibly undefined
// 140052BC6: variable 'v16' is possibly undefined

//----- (0000000140052BF8) ----------------------------------------------------
char __fastcall sub_140052BF8(__int64 a1, unsigned __int64 a2, void *a3, unsigned int *a4)
{
  char v4; // bl
  unsigned int v5; // er15
  __int64 v7; // rax
  unsigned __int64 v8; // rbp
  unsigned __int64 v9; // rdi
  unsigned int v10; // eax
  __int64 v11; // rax
  unsigned __int16 *v12; // rbx
  __int64 v13; // rax
  __int64 v14; // rcx
  int v15; // edx
  unsigned __int64 v16; // r8
  unsigned __int64 v17; // r14
  unsigned __int64 v18; // rsi
  unsigned __int64 v19; // r11
  unsigned int v20; // er12
  __int64 v21; // r10
  __int64 v22; // r13
  int v23; // ebp
  unsigned __int16 *v24; // rdx
  unsigned __int16 *v25; // rax
  unsigned int *v26; // r9
  __int64 v27; // rax
  __int64 v28; // rdx
  unsigned __int64 v29; // rdi
  unsigned __int64 v30; // rax
  unsigned __int64 v31; // rcx
  unsigned __int64 v32; // rdx
  unsigned __int64 v34; // [rsp+20h] [rbp-78h] BYREF
  __int64 v35; // [rsp+28h] [rbp-70h]
  __int64 v36; // [rsp+30h] [rbp-68h]
  __int64 v37; // [rsp+38h] [rbp-60h]
  __int64 v38; // [rsp+40h] [rbp-58h]
  char v39; // [rsp+A0h] [rbp+8h]

  v4 = 0;
  v39 = 0;
  v35 = 0i64;
  v5 = 0xFFFFFFFF;
  v36 = 0i64;
  if ( !a1 || !a2 || !a3 )
    return 0;
  memset(a3, 0, 0x10ui64);
  v7 = sub_140051084(0x1000ui64);
  v38 = v7;
  v8 = v7;
  if ( v7 )
  {
    if ( sub_14002FED0(a1, 0x1000i64, v7) == 0x1000 )
    {
      if ( sub_14005240C(v8, 0x1000ui64, 0i64, (__int64 *)&v34) )
      {
        v9 = v34;
        if ( v34 >= v8 && v34 + 0x108 > v34 && v34 + 0x108 <= v8 + 0x1000 )
        {
          if ( *(_DWORD *)(v34 + 0x88) )
          {
            v10 = *(_DWORD *)(v34 + 0x8C);
            if ( v10 )
            {
              v11 = sub_140051084(v10);
              v12 = (unsigned __int16 *)v11;
              if ( v11 )
              {
                v13 = sub_14002FED0(a1 + *(unsigned int *)(v9 + 0x88), *(unsigned int *)(v9 + 0x8C), v11);
                v14 = *(unsigned int *)(v9 + 0x8C);
                v37 = v14;
                if ( v13 == v14 )
                {
                  v15 = *(_DWORD *)(v9 + 0x88);
                  v16 = (unsigned __int64)v12 + v14;
                  v17 = (unsigned __int64)v12 + (unsigned int)(*((_DWORD *)v12 + 8) - v15);
                  v18 = (unsigned __int64)v12 + (unsigned int)(*((_DWORD *)v12 + 7) - v15);
                  v19 = (unsigned __int64)v12 + (unsigned int)(*((_DWORD *)v12 + 9) - v15);
                  if ( v17 >= (unsigned __int64)v12
                    && v17 + 4 > v17
                    && v17 + 4 <= v16
                    && v19 >= (unsigned __int64)v12
                    && v19 + 2 > v19
                    && v19 + 2 <= v16
                    && v18 >= (unsigned __int64)v12
                    && v18 + 4 > v18
                    && v18 + 4 <= v16 )
                  {
                    v20 = *((_DWORD *)v12 + 6);
                    v21 = 0i64;
                    if ( v20 )
                    {
                      v22 = (unsigned int)v14;
                      v23 = *(_DWORD *)(v9 + 0x88);
                      do
                      {
                        v24 = (unsigned __int16 *)(v17 + 4 * v21);
                        if ( v24 < v12 )
                          break;
                        if ( v24 + 2 <= v24 )
                          break;
                        if ( (unsigned __int64)(v24 + 2) > v16 )
                          break;
                        v25 = (unsigned __int16 *)(v19 + 2 * v21);
                        if ( v25 < v12 )
                          break;
                        if ( v25 + 1 <= v25 )
                          break;
                        if ( (unsigned __int64)(v25 + 1) > v16 )
                          break;
                        v26 = (unsigned int *)(v18 + 4i64 * *v25);
                        if ( v26 < (unsigned int *)v12 )
                          break;
                        if ( v26 + 1 <= v26 )
                          break;
                        if ( (unsigned __int64)(v26 + 1) > v16 )
                          break;
                        v27 = (unsigned int)(*(_DWORD *)v24 - v23);
                        v28 = v27;
                        v29 = (unsigned __int64)v12 + v27;
                        if ( (unsigned __int64)v12 + v27 >= v16 && (unsigned int)v27 < (unsigned int)v22 )
                          break;
                        v30 = 0i64;
                        if ( !v29 || v22 == v28 )
                          goto LABEL_41;
                        do
                        {
                          if ( !*(_BYTE *)(v30 + v29) )
                            break;
                          ++v30;
                        }
                        while ( v30 < v22 - v28 );
                        v31 = 0x100i64;
                        if ( v30 < 0x100 )
                        {
LABEL_41:
                          v31 = 0i64;
                          if ( v29 && v22 != v28 )
                          {
                            do
                            {
                              if ( !*(_BYTE *)(v31 + v29) )
                                break;
                              ++v31;
                            }
                            while ( v31 < v22 - v28 );
                          }
                        }
                        if ( v29 < (unsigned __int64)v12 )
                          break;
                        if ( v31 + v29 <= v29 )
                          break;
                        if ( v31 + v29 > v16 )
                          break;
                        v32 = *v26;
                        if ( v32 <= a2 && (int)a2 - (int)v32 < v5 )
                        {
                          v35 = v29;
                          v5 = a2 - v32;
                          v36 = v31;
                          v39 = 1;
                          if ( (_DWORD)a2 == (_DWORD)v32 )
                            break;
                        }
                        v21 = (unsigned int)(v21 + 1);
                      }
                      while ( (unsigned int)v21 < v20 );
                      v8 = v38;
                      if ( v35 )
                        sub_1400076F8((__int64)a3, v35, v36);
                    }
                  }
                  if ( a4 )
                  {
                    if ( v5 != 0xFFFFFFFF )
                      *a4 = v5;
                  }
                }
                sub_140051220((__int64)v12);
              }
              v4 = v39;
            }
          }
        }
      }
    }
    sub_140051220(v8);
  }
  return v4;
}

//----- (000000014005316C) ----------------------------------------------------
unsigned __int64 __fastcall sub_14005316C(__int64 a1, unsigned __int16 *a2, unsigned int a3, unsigned int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, _BYTE *a9)
{
  unsigned __int64 v9; // rbx
  unsigned __int64 v10; // rsi
  _DWORD *v15; // rcx
  char *v16; // rax
  char *v17; // rdx
  unsigned int *v18; // rax
  __int64 v19; // r15
  unsigned int *v20; // r13
  unsigned __int64 v21; // rax
  unsigned int v22; // edx
  unsigned __int64 v23; // rcx
  unsigned __int64 v24; // rax
  unsigned __int16 *v25; // rax
  unsigned int *v26; // rcx
  _BYTE *v27; // rax
  __int64 v28; // rsi
  _BYTE *v29; // rdi
  _BYTE *v30; // rax
  __int64 v31; // r8
  _BYTE *v32; // r14
  __int64 v33; // rax
  __int64 v34; // rbx
  char *v36; // [rsp+28h] [rbp-50h]
  char *v37; // [rsp+30h] [rbp-48h]
  __int64 v38; // [rsp+80h] [rbp+8h]
  _DWORD *v39; // [rsp+88h] [rbp+10h]
  unsigned int v40; // [rsp+98h] [rbp+20h]

  v38 = a1;
  v9 = 0i64;
  v10 = (unsigned __int64)a2 + a4;
  if ( !a1 || !a2 || !a3 || !a4 || !a9 )
    return 0i64;
  v15 = (_DWORD *)((char *)a2 + *((_DWORD *)a2 + 8) - a3);
  v16 = (char *)a2 + *((_DWORD *)a2 + 9) - a3;
  v39 = v15;
  v17 = (char *)a2 + *((_DWORD *)a2 + 7) - a3;
  v36 = v16;
  v37 = v17;
  if ( (unsigned __int64)a9 <= 0xFFFF )
  {
    if ( (unsigned int)a9 < *((_DWORD *)a2 + 5) )
    {
      v18 = (unsigned int *)&v17[4 * ((_DWORD)a9 - 1)];
      if ( v18 >= (unsigned int *)a2 && v18 + 1 > v18 && (unsigned __int64)(v18 + 1) <= v10 )
        v9 = a1 + *v18;
    }
    goto LABEL_33;
  }
  v19 = 0i64;
  v40 = *((_DWORD *)a2 + 6);
  if ( !v40 )
    goto LABEL_33;
  v20 = v15;
  while ( 1 )
  {
    v21 = (unsigned __int64)&v15[v19];
    if ( v21 >= (unsigned __int64)a2 )
      break;
LABEL_24:
    v19 = (unsigned int)(v19 + 1);
    ++v20;
    if ( (unsigned int)v19 >= v40 )
      goto LABEL_33;
  }
  if ( v21 + 4 <= v21
    || v21 + 4 > v10
    || *v20 <= a3
    || (v22 = *v20 - a3, v23 = (unsigned __int64)a2 + v22, v22 >= a4)
    || v23 < (unsigned __int64)a2
    || (v24 = v23 + a4 - v22, v24 <= v23)
    || v24 > v10
    || !sub_140007538(v23, a9, a4 - v22) )
  {
    v15 = v39;
    goto LABEL_24;
  }
  v25 = (unsigned __int16 *)&v36[2 * (unsigned int)v19];
  if ( v25 >= a2 && v25 + 1 > v25 && (unsigned __int64)(v25 + 1) <= v10 )
  {
    v26 = (unsigned int *)&v37[4 * *v25];
    if ( v26 >= (unsigned int *)a2 && v26 + 1 > v26 && (unsigned __int64)(v26 + 1) <= v10 )
      v9 = v38 + *v26;
  }
LABEL_33:
  if ( v9 >= (unsigned __int64)a2 && v9 <= v10 )
  {
    v27 = sub_1400510B4(1i64, 0x100i64);
    v28 = 0i64;
    v29 = v27;
    if ( !v27 )
      goto LABEL_41;
    sub_14002FED0(v9, 0x100i64, (__int64)v27);
    v30 = sub_14000761C(v29, (unsigned __int8 *)qword_14006F930, 0x100ui64);
    v32 = v30;
    if ( v30 )
    {
      *v30 = 0;
      LOBYTE(v31) = 1;
      v33 = ((__int64 (__fastcall *)(_BYTE *, signed __int64, __int64))loc_14000A544)(v29, v30 - v29, v31);
      v34 = v33;
      if ( v33 )
      {
        v28 = sub_140052B44(*(_QWORD *)(v33 + 0x10), *(unsigned int *)(v33 + 0x18), v32 + 1);
        sub_140051220(v34);
      }
    }
    sub_140051220((__int64)v29);
    if ( v28 )
      v9 = v28;
    else
LABEL_41:
      v9 = 0i64;
  }
  return v9;
}
// 140053378: variable 'v31' is possibly undefined
// 140052B44: using guessed type __int64 __fastcall sub_140052B44(_QWORD, _QWORD, _QWORD);
// 14006F930: using guessed type __int64 qword_14006F930[10];

//----- (00000001400533D4) ----------------------------------------------------
char *__fastcall sub_1400533D4(unsigned __int64 a1, unsigned __int64 a2, _BYTE *a3, __int64 a4, _DWORD *a5, __int64 a6, __int64 a7, _DWORD *a8)
{
  char *v8; // rdi
  __int64 v12; // rsi
  __int16 v13; // ax
  unsigned int *v14; // rax
  unsigned __int64 v15; // rcx
  _DWORD *v16; // rax
  __int64 v17; // rdx
  _DWORD *v18; // rbp
  _DWORD *v19; // r12
  __int64 v20; // rdx
  _DWORD *v21; // rax
  unsigned __int64 v22; // rcx
  _DWORD *v23; // r14
  __int64 v24; // rdx
  _DWORD *v25; // rax
  unsigned int v26; // ebp
  __int64 i; // r14
  _DWORD *v28; // rax
  char *v29; // rax

  v8 = 0i64;
  if ( !a1 || !a2 || (unsigned __int64)a3 < 0x10000 || !sub_14005240C(a1, a2, (__int64 *)&a8, (__int64 *)&a5) )
    return 0i64;
  v12 = (__int64)a5;
  v13 = *((_WORD *)a5 + 2);
  if ( v13 == 0x14C )
  {
    v14 = a5 + 0x1E;
  }
  else
  {
    if ( v13 != (__int16)0x8664 )
      return 0i64;
    v14 = a5 + 0x22;
  }
  v15 = *v14;
  if ( !(_DWORD)v15 )
    return 0i64;
  if ( !v14[1] )
    return 0i64;
  v16 = sub_1400524BC(v15, (__int64)a5, a1);
  v18 = v16;
  if ( !v16 )
    return 0i64;
  if ( !v16[5] )
    return 0i64;
  v19 = sub_1400524BC((unsigned int)v16[8], v17, a1);
  v21 = sub_1400524BC((unsigned int)v18[7], v20, a1);
  v22 = (unsigned int)v18[9];
  v23 = v21;
  a8 = v21;
  v25 = sub_1400524BC(v22, v24, a1);
  a5 = v25;
  if ( !v19 || !v23 || !v25 )
    return 0i64;
  v26 = v18[6];
  for ( i = 0i64; (unsigned int)i < v26; ++v19 )
  {
    v28 = sub_1400524BC((unsigned int)*v19, v12, a1);
    if ( !v28 )
      break;
    if ( sub_140007538((__int64)v28, a3, 0x100ui64) )
    {
      v29 = (char *)sub_1400524BC((unsigned int)a8[*((unsigned __int16 *)a5 + i)], v12, a1);
      v8 = v29;
      if ( v29 && (unsigned __int64)v29 >= a1 && (unsigned __int64)v29 < a1 + a2 )
        v8 = &v29[-a1];
      return v8;
    }
    i = (unsigned int)(i + 1);
  }
  return v8;
}
// 140053490: variable 'v17' is possibly undefined
// 14005349E: variable 'v20' is possibly undefined
// 1400534B1: variable 'v24' is possibly undefined

//----- (0000000140053568) ----------------------------------------------------
char __fastcall sub_140053568(ULONG64 a1, __int64 a2)
{
  unsigned __int64 v3; // rcx

  if ( a1 )
  {
    if ( a2 )
    {
      v3 = 0xFFFFFFFFFFFFFFFFui64;
      do
        ++v3;
      while ( *(_BYTE *)(a2 + v3) );
      if ( (_WORD)v3 && (unsigned int)sub_140052894(a1) )
        JUMPOUT(0x1400535F2i64);
    }
  }
  return 0;
}
// 1400535EF: control flows out of bounds to 1400535F2

//----- (0000000140053698) ----------------------------------------------------
__int64 __fastcall sub_140053698(__int64 a1)
{
  unsigned int v2; // ebx
  unsigned int *v3; // rax
  _QWORD *v4; // rax

  v2 = 0;
  if ( (unsigned int)sub_140013ED8() == 0x20 )
  {
    v3 = sub_14005275C(a1);
    if ( v3 )
      v2 = v3[0xD];
  }
  else
  {
    v4 = sub_1400527FC(a1);
    if ( v4 )
      v2 = *((_DWORD *)v4 + 0x1A);
  }
  return v2;
}

//----- (00000001400536EC) ----------------------------------------------------
char __fastcall sub_1400536EC(ULONG64 a1)
{
  if ( (unsigned int)sub_140052894(a1) )
    JUMPOUT(0x14005371Di64);
  return 0;
}
// 14005371A: control flows out of bounds to 14005371D

//----- (0000000140053740) ----------------------------------------------------
char __fastcall sub_140053740(ULONG64 a1, __int64 a2)
{
  if ( !a1 || !a2 )
    return 0;
  if ( (unsigned int)sub_140052894(a1) )
    JUMPOUT(0x140053798i64);
  return 0;
}
// 140053795: control flows out of bounds to 140053798

//----- (0000000140053848) ----------------------------------------------------
char __fastcall sub_140053848(__int64 a1, unsigned int a2, __int64 a3)
{
  if ( a3 && a1 && sub_1400522E4(a1, a2) )
    JUMPOUT(0x1400538A8i64);
  return 0;
}
// 1400538A3: control flows out of bounds to 1400538A8

//----- (0000000140053978) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140053978()
{
  JUMPOUT(0x1400539A1i64);
}
// 140053BB2: positive sp value 8 has been found
// 14005399C: control flows out of bounds to 1400539A1

//----- (0000000140053BB4) ----------------------------------------------------
__int64 __fastcall sub_140053BB4(ULONG64 a1)
{
  __int64 v2; // rbx
  __int64 v4; // rax
  __int64 v5; // rdx
  __int64 v6; // rax

  v2 = 0i64;
  if ( !a1 )
    return 0i64;
  sub_14005221C(a1, 0x1000i64, 1);
  v4 = sub_1400522E4(a1, 0x1000ui64);
  if ( v4 )
  {
    if ( sub_1400523E4(v4) == 0x40 )
    {
      sub_14005221C(a1, *(unsigned int *)(v5 + 0x50), 1);
      sub_140053978();
      v2 = v6;
    }
  }
  return v2;
}
// 140053C02: variable 'v5' is possibly undefined
// 140053C22: variable 'v6' is possibly undefined

//----- (0000000140053C40) ----------------------------------------------------
__int64 __fastcall sub_140053C40(unsigned __int64 a1, unsigned int a2)
{
  char *v4; // rsi
  _DWORD *v5; // rcx
  int v6; // edi
  _DWORD *v7; // rdx
  _DWORD *v8; // rcx
  __int64 v10; // rax
  int v11[6]; // [rsp+28h] [rbp-E0h] BYREF
  char v12[72]; // [rsp+40h] [rbp-C8h] BYREF
  int v13; // [rsp+88h] [rbp-80h]
  char v14[512]; // [rsp+A8h] [rbp-60h] BYREF

  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v14, 0i64, 0x200i64);
  v4 = v14;
  if ( a1 )
  {
    if ( a2 >= 0x200 )
    {
      v5 = (_DWORD *)sub_1400522E4(a1, a2);
      if ( v5 )
      {
        while ( (unsigned __int64)v5 > a1 )
        {
          v5 += 0xFFFFFFFF;
          if ( *v5 == 0x68636952 )
          {
            if ( (unsigned __int64)v5 > a1 )
            {
              v6 = v5[1];
              v7 = v5;
              while ( (unsigned __int64)v5 > a1 )
              {
                v5 += 0xFFFFFFFF;
                if ( (*v5 ^ v6) == 0x536E6144 )
                {
                  if ( (unsigned __int64)v5 > a1 && v5[1] == v6 && v5[2] == v6 && v5[3] == v6 )
                  {
                    v8 = v5 + 4;
                    if ( (unsigned __int64)(v7 - v8 - 2) <= 0x7E )
                    {
                      while ( v8 < v7 )
                      {
                        *(_DWORD *)v4 = *v8 ^ v6;
                        v4 += 4;
                        ++v8;
                      }
                      v11[0] = 0x67452301;
                      v11[1] = 0xEFCDAB89;
                      v11[2] = 0x98BADCFE;
                      v11[3] = 0x10325476;
                      v11[4] = 0xC3D2E1F0;
                      ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v12, 0i64, 0x48i64);
                      v13 = 0;
                      v10 = sub_140003C4C((__int64)v11, (__int64)v14, v4 - v14);
                      sub_140003B10(v10);
                      JUMPOUT(0x140053D81i64);
                    }
                  }
                  return 0i64;
                }
              }
            }
            return 0i64;
          }
        }
      }
    }
  }
  return 0i64;
}
// 140053D7C: control flows out of bounds to 140053D81

//----- (0000000140053DD0) ----------------------------------------------------
__int64 __fastcall sub_140053DD0(ULONG64 a1)
{
  if ( !a1 )
    return 0i64;
  sub_14005221C(a1, 0x1000i64, 1);
  return sub_140053C40(a1, 0x1000u);
}

//----- (0000000140053E18) ----------------------------------------------------
__int64 __fastcall sub_140053E18(__int64 a1, unsigned int a2)
{
  if ( a1 && a2 >= 0x200 && sub_1400522E4(a1, a2) )
    JUMPOUT(0x140053E60i64);
  return 0i64;
}
// 140053E5D: control flows out of bounds to 140053E60

//----- (0000000140053F00) ----------------------------------------------------
__int64 __fastcall sub_140053F00(ULONG64 a1)
{
  if ( !a1 )
    return 0i64;
  sub_14005221C(a1, 0x1000i64, 1);
  return sub_140053E18(a1, 0x1000u);
}

//----- (0000000140053F48) ----------------------------------------------------
bool __fastcall sub_140053F48(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  _QWORD *v5; // rax

  v5 = (_QWORD *)((__int64 (__fastcall *)(__int64, __int64, __int64, __int64))loc_140015908)(a1, 0x1000i64, a3, 8i64);
  if ( v5 )
    *v5 = *a4;
  return v5 != 0i64;
}

//----- (0000000140053F78) ----------------------------------------------------
__int16 *sub_140053F78()
{
  if ( !word_1400DB510 )
  {
    if ( MEMORY[0xFFFFF7800000026C] >= 6u && (MEMORY[0xFFFFF7800000026C] != 6 || MEMORY[0xFFFFF78000000270]) )
      JUMPOUT(0x140053FD4i64);
    JUMPOUT(0x1400540AFi64);
  }
  return &word_1400DB510;
}
// 140053FD0: control flows out of bounds to 140053FD4
// 1400540AB: control flows out of bounds to 1400540AF
// 1400DB510: using guessed type __int16 word_1400DB510;

//----- (00000001400541D0) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_1400541D0()
{
  JUMPOUT(0x1400541F2i64);
}
// 1400548A5: positive sp value 20 has been found
// 1400541EF: control flows out of bounds to 1400541F2

//----- (00000001400548A8) ----------------------------------------------------
char __fastcall sub_1400548A8(__int64 a1, __int64 a2)
{
  __int64 v4; // rcx
  unsigned __int16 *v5; // rax
  __int64 v6; // rdi
  char v8[56]; // [rsp+20h] [rbp-38h] BYREF

  if ( !a1 || !a2 || !sub_140013D4C(a1) )
    return 0;
  memset((void *)a2, 0, 0x338ui64);
  if ( sub_140015378(a1, (__int64)v8) )
  {
    LOBYTE(v4) = 1;
    v5 = (unsigned __int16 *)((__int64 (__fastcall *)(__int64))loc_14000E260)(v4);
    v6 = (__int64)v5;
    if ( v5 )
    {
      *(_BYTE *)(a2 + 0x100) = *(_BYTE *)(*(_QWORD *)v5 + 0x1Ei64);
      sub_1400074D4(a2, 0x100i64, v5 + 0xC);
      *(_DWORD *)(a2 + 0x104) = *(_DWORD *)(*(_QWORD *)v6 + 0x250i64);
      *(_DWORD *)(a2 + 0x10C) = *(_DWORD *)(*(_QWORD *)v6 + 0x240i64);
      *(_DWORD *)(a2 + 0x108) = *(_DWORD *)(*(_QWORD *)v6 + 0x234i64);
      *(_DWORD *)(a2 + 0x130) = *(_DWORD *)(*(_QWORD *)v6 + 0x24Ci64);
      *(_DWORD *)(a2 + 0x134) = *(_DWORD *)(*(_QWORD *)v6 + 0x248i64);
      sub_140053740(*(_QWORD *)(*(_QWORD *)v6 + 0xEi64), a2 + 0x138);
      *(_QWORD *)(a2 + 0x118) = sub_140053DD0(*(_QWORD *)(*(_QWORD *)v6 + 0xEi64));
      *(_QWORD *)(a2 + 0x120) = sub_140053BB4(*(_QWORD *)(*(_QWORD *)v6 + 0xEi64));
      *(_QWORD *)(a2 + 0x128) = sub_140053F00(*(_QWORD *)(*(_QWORD *)v6 + 0xEi64));
      sub_14000E6C4(v6);
    }
    ((void (__fastcall *)(__int64, char *))loc_140015528)(a1, v8);
  }
  return 1;
}
// 1400548FF: variable 'v4' is possibly undefined

//----- (00000001400549F8) ----------------------------------------------------
bool __fastcall sub_1400549F8(__int64 a1, int a2, int a3, int a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, int a11, __int64 a12)
{
  __int64 v17; // rax

  if ( *(_QWORD *)(a1 + 8i64 * (unsigned __int16)a9) )
    return 0;
  v17 = sub_140051084(0x28ui64);
  if ( v17 )
  {
    *(_DWORD *)(v17 + 4) = a10;
    *(_DWORD *)(v17 + 8) = a11;
    *(_QWORD *)(v17 + 0x10) = a12;
    *(_DWORD *)v17 = a9;
    *(_DWORD *)(v17 + 0x18) = a3;
    *(_DWORD *)(v17 + 0x1C) = a4;
    *(_DWORD *)(v17 + 0x20) = a2;
    *(_QWORD *)(a1 + 8i64 * (unsigned __int16)a9) = v17;
  }
  return v17 != 0;
}

//----- (0000000140054A84) ----------------------------------------------------
#error "140054ACA: call analysis failed (funcsize=54)"

//----- (0000000140054B4C) ----------------------------------------------------
__int64 __fastcall sub_140054B4C(__int64 a1, int a2, int a3, _BYTE *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int a9, int a10)
{
  _DWORD *v10; // r11
  int v11; // eax
  __int64 v12; // r11
  __int64 result; // rax

  if ( a1
    && (v10 = *(_DWORD **)(a1 + 8i64 * (unsigned __int16)a10)) != 0i64
    && *v10 == a10
    && v10[2] == a9
    && v10[6] == a2
    && v10[7] == a3
    && (v11 = sub_140025404(a4, a9), *(_DWORD *)(v12 + 4) == v11) )
  {
    result = *(unsigned int *)(v12 + 0x20);
  }
  else
  {
    result = 0i64;
  }
  return result;
}
// 140054B91: variable 'v12' is possibly undefined

//----- (0000000140054BAC) ----------------------------------------------------
__int64 __fastcall sub_140054BAC(__int64 a1, int a2, __int64 a3, unsigned int a4)
{
  __int64 v4; // r14
  int v8; // edi
  unsigned int *i; // rsi
  unsigned int v10; // ecx
  __int64 v11; // r11
  int v12; // eax
  int v13; // eax
  __int64 v15; // rdx
  int v16; // er8

  v4 = qword_1400D82B0;
  if ( !qword_1400D82B0 || !a3 || !a4 )
    return 0i64;
  v8 = 0;
  for ( i = (unsigned int *)(a3 + 0xC); ; i += 6 )
  {
    v10 = i[1];
    v11 = *(_QWORD *)(v4 + 8i64 * (unsigned __int16)v10);
    if ( !v11 || *(_DWORD *)v11 != v10 || *(_DWORD *)(v11 + 0x18) != a2 )
      goto LABEL_17;
    v12 = *(_DWORD *)(v11 + 0x1C);
    if ( v12 != 1 )
      break;
    if ( *(_DWORD *)(v11 + 8) == *i )
    {
      v13 = sub_140025404(*(_BYTE **)(i + 0xFFFFFFFD), *i);
      if ( *(_DWORD *)(v11 + 4) == v13 )
        return *(unsigned int *)(v11 + 0x20);
    }
LABEL_17:
    if ( ++v8 >= a4 )
      return 0i64;
  }
  if ( v12 != 4 )
    goto LABEL_17;
  v15 = (unsigned int)(v8 + 1);
  if ( (unsigned int)v15 >= a4 )
    goto LABEL_17;
  while ( 1 )
  {
    v16 = *(_DWORD *)(*(_QWORD *)(v11 + 0x10) + 4i64 * (unsigned int)(v15 + ~v8));
    if ( !v16 )
      return *(unsigned int *)(v11 + 0x20);
    if ( v16 == *(_DWORD *)(a3 + 0x18 * v15 + 0x10) )
    {
      v15 = (unsigned int)(v15 + 1);
      if ( (unsigned int)v15 < a4 )
        continue;
    }
    goto LABEL_17;
  }
}
// 140054BF2: conditional instruction was optimized away because of 'ebx.4!=0'
// 140054C30: variable 'v11' is possibly undefined
// 1400D82B0: using guessed type __int64 qword_1400D82B0;

//----- (0000000140054C98) ----------------------------------------------------
__int64 __fastcall sub_140054C98(__int64 a1, __int64 a2, unsigned __int64 a3, __int64 a4, __int64 a5)
{
  __int64 v7; // rax
  void *v8; // rsi
  __int64 v9; // rax
  int v11[6]; // [rsp+40h] [rbp-41h] BYREF
  char v12[72]; // [rsp+58h] [rbp-29h] BYREF
  int v13; // [rsp+A0h] [rbp+1Fh]

  a5 = a1;
  if ( !qword_1400D82B0 || !a2 || a3 - 0x148 > 0xFFFFFEB7 )
    return 0i64;
  v7 = sub_140051084(a3);
  v8 = (void *)v7;
  if ( v7 )
  {
    ((void (__fastcall *)(__int64, __int64, unsigned __int64))loc_14006F000)(v7, a2, a3);
    if ( sub_14005240C((__int64)v8, a3, 0i64, &a5) )
    {
      v11[0] = 0x67452301;
      v11[1] = 0xEFCDAB89;
      v11[2] = 0x98BADCFE;
      *(_QWORD *)(a5 + 0x30) = 0x10000i64;
      v11[3] = 0x10325476;
      v11[4] = 0xC3D2E1F0;
      ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v12, 0i64, 0x48i64);
      v13 = 0;
      v9 = sub_140003C4C((__int64)v11, (__int64)v8, 0x148ui64);
      sub_140003B10(v9);
      JUMPOUT(0x140054D8Di64);
    }
    memset(v8, 0, a3);
    sub_140051220((__int64)v8);
  }
  return 0i64;
}
// 140054D8B: control flows out of bounds to 140054D8D
// 1400D82B0: using guessed type __int64 qword_1400D82B0;

//----- (0000000140055068) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140055068()
{
  unsigned __int32 v0; // er8
  unsigned __int64 i; // rdx
  __int64 v2; // [rsp+20h] [rbp-69h] BYREF
  int v3[2]; // [rsp+28h] [rbp-61h] BYREF
  __int64 v4; // [rsp+30h] [rbp-59h]
  __int64 *v5; // [rsp+38h] [rbp-51h]
  int *v6; // [rsp+40h] [rbp-49h]

  v3[0] = 0xD02A62D7;
  v4 = 0i64;
  v3[1] = 0x21019B7F;
  v5 = &v2;
  v6 = v3;
  v0 = 0xA321E068;
  for ( i = 0i64; i < 2; ++i )
  {
    v0 = _byteswap_ulong(0xA321 * v0 + 0x21E068);
    v6[i] = *(_DWORD *)((char *)v5 + i * 4) ^ v0;
  }
  JUMPOUT(0x140055101i64);
}
// 1400551E9: positive sp value 8 has been found
// 1400550FE: control flows out of bounds to 140055101

//----- (00000001400551EC) ----------------------------------------------------
void sub_1400551EC()
{
  unsigned int v0; // er15
  __int64 v1; // r12
  __int64 v2; // rdx
  __int64 v3; // rcx
  __int64 v4; // r8
  __int64 v5; // r9
  __int64 v6; // r13
  unsigned int *v7; // rax
  unsigned int *v8; // rbx
  __int64 v9; // rdx
  __int64 v10; // r8
  __int64 v11; // r9
  unsigned int i; // edi
  __int64 v13; // rsi
  unsigned __int64 v14; // rcx
  unsigned __int64 v15; // rax
  unsigned __int64 v16; // r14
  __int64 v17; // r8
  unsigned __int64 v18; // rcx
  unsigned __int64 v19; // rsi
  unsigned int v20; // [rsp+20h] [rbp-40h]
  ULONG v21; // [rsp+20h] [rbp-40h]
  int v22; // [rsp+40h] [rbp-20h] BYREF
  unsigned __int16 v24; // [rsp+50h] [rbp-10h] BYREF

  v0 = 0;
  if ( qword_1400D82B0 )
  {
    v1 = sub_140051084(0x400000ui64);
    if ( v1 )
    {
      v6 = sub_140051084(0x6000ui64);
      if ( v6 )
      {
        v7 = (unsigned int *)sub_14002D72C(v3, v2, v4, v5, v20);
        v8 = v7;
        if ( v7 )
        {
          v9 = *v7;
          if ( (_DWORD)v9 )
          {
            sub_14002D880(
              (unsigned __int64)(v7 + 2),
              (unsigned __int64)&v7[0x4A * v9 + 2],
              0x14C1BACF914C1BADi64 * ((0x128 * v9) >> 3),
              0);
            for ( i = 0; i < *v8; ++i )
            {
              if ( byte_1400D877C )
                break;
              v13 = 0x4Ai64 * i;
              v14 = *(_QWORD *)&v8[v13 + 6];
              if ( v14 >= (unsigned __int64)MmSystemRangeStart && v14 != qword_1400D82B8 )
              {
                if ( &v8[v13 + 0xC] )
                {
                  v15 = 0xFFFFFFFFFFFFFFFFui64;
                  do
                    ++v15;
                  while ( *((_BYTE *)&v8[v13 + 0xC] + v15) );
                  LOWORD(v22) = v15;
                  HIWORD(v22) = v15 + 1;
                }
                else
                {
                  v22 = 0;
                }
                sub_140007274(&v24, (unsigned __int16 *)&v22, v10, v11, v21);
                JUMPOUT(0x14005532Ci64);
              }
            }
            v16 = HIDWORD(qword_1400D82B8);
            if ( *v8 != 1 )
            {
              do
              {
                if ( byte_1400D877C )
                  break;
                v17 = 0x4Ai64 * v0++;
                if ( HIDWORD(*(_QWORD *)&v8[v17 + 6]) == v16 )
                {
                  v18 = *(_QWORD *)&v8[0x4A * v0 + 6];
                  if ( HIDWORD(v18) == v16 )
                  {
                    v19 = *(_QWORD *)&v8[v17 + 6] + v8[v17 + 8];
                    if ( v19 < v18 && (((_DWORD)v18 - (_DWORD)v19) & 0xFFFFF000) <= 0x1000000 )
                    {
                      if ( !byte_1400D877C )
                      {
                        sub_140055068();
                        JUMPOUT(0x140055428i64);
                      }
                      v16 = HIDWORD(qword_1400D82B8);
                    }
                  }
                }
              }
              while ( v0 < *v8 - 1 );
            }
          }
          sub_140051220((__int64)v8);
        }
        sub_140051220(v6);
      }
      sub_140051220(v1);
    }
  }
}
// 140055327: control flows out of bounds to 14005532C
// 140055425: control flows out of bounds to 140055428
// 140055248: variable 'v3' is possibly undefined
// 140055248: variable 'v2' is possibly undefined
// 140055248: variable 'v4' is possibly undefined
// 140055248: variable 'v5' is possibly undefined
// 140055248: variable 'v20' is possibly undefined
// 140055313: variable 'v10' is possibly undefined
// 140055313: variable 'v11' is possibly undefined
// 140055313: variable 'v21' is possibly undefined
// 1400D82B0: using guessed type __int64 qword_1400D82B0;
// 1400D82B8: using guessed type __int64 qword_1400D82B8;
// 1400D877C: using guessed type char byte_1400D877C;

//----- (0000000140055DB4) ----------------------------------------------------
char __fastcall sub_140055DB4(unsigned __int64 a1, unsigned __int64 a2, __int64 a3)
{
  __int64 v5; // r14
  char v6; // bp
  __int64 v7; // rdi
  __int64 v9; // rax
  __int64 v10; // rax
  _DWORD *v11; // rcx
  int v12; // eax

  v5 = a1;
  v6 = 0;
  v7 = 0i64;
  if ( !a1 || a2 < 0x1000 )
    return 0;
  if ( a1 < (unsigned __int64)MmHighestUserAddress )
  {
    if ( a1 + a2 >= (unsigned __int64)MmHighestUserAddress )
      return 0;
    goto LABEL_10;
  }
  if ( a2 >= 0xA000 )
    return 0;
  v9 = sub_140051084(a2);
  v7 = v9;
  if ( v9 )
  {
    if ( sub_14002FED0(v5, a2, v9) != a2 )
    {
LABEL_16:
      sub_140051220(v7);
      return v6;
    }
    v5 = v7;
LABEL_10:
    v10 = sub_1400522E4(v5, a2);
    v11 = (_DWORD *)v10;
    if ( v10 )
    {
      *(_DWORD *)a3 = *(_DWORD *)(v10 + 8);
      *(_WORD *)(a3 + 4) = *(_WORD *)(v10 + 4);
      *(_WORD *)(a3 + 6) = *(_WORD *)(v10 + 0x16);
      if ( *(_WORD *)(v10 + 0x18) == 0x10B )
        v12 = *(_DWORD *)(v10 + 0x34);
      else
        v12 = *(_DWORD *)(v10 + 0x30);
      *(_DWORD *)(a3 + 8) = v12;
      v6 = 1;
      *(_DWORD *)(a3 + 0xC) = v11[0x14];
      *(_DWORD *)(a3 + 0x10) = v11[0xB];
      *(_DWORD *)(a3 + 0x14) = v11[7];
      *(_DWORD *)(a3 + 0x18) = v11[0xA];
      *(_DWORD *)(a3 + 0x1C) = v11[0x16];
      *(_WORD *)(a3 + 0x20) = 0;
    }
    if ( !v7 )
      return v6;
    goto LABEL_16;
  }
  return v6;
}

//----- (0000000140055ECC) ----------------------------------------------------
__int64 __fastcall sub_140055ECC(__int64 a1, int a2, unsigned __int64 a3, int a4)
{
  __int64 v7; // rax
  __int64 v8; // rdi

  if ( a3 <= 0x8000 )
  {
    v7 = sub_140051084(0x1260ui64);
    v8 = v7;
    if ( v7 )
    {
      ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(v7, 0i64, 0x260i64);
      *(_DWORD *)v8 = 0xA;
      *(_DWORD *)(v8 + 4) = 0x5045496D;
      *(_WORD *)(v8 + 8) = 2;
      *(_QWORD *)(v8 + 0xE) = a1;
      *(_DWORD *)(v8 + 0x16) = a2;
      *(_DWORD *)(v8 + 0x1A) = a4;
      JUMPOUT(0x140055F69i64);
    }
  }
  return 0i64;
}
// 140055F62: control flows out of bounds to 140055F69

//----- (00000001400562C4) ----------------------------------------------------
__int64 __fastcall sub_1400562C4(_WORD *a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  unsigned __int64 v8; // rdx
  unsigned int v10; // edi
  unsigned __int64 v11; // rsi
  int v12; // eax

  a8 = a4;
  v8 = a2 >> 1;
  if ( v8 - 1 <= 0x7FFFFFFE )
  {
    v11 = v8 - 1;
    v10 = 0;
    sub_140005BC8((__int64)a1, v8 - 1, a3, (__int64)&a8);
    if ( v12 < 0 || v12 > v11 )
    {
      v10 = 0x80000005;
    }
    else if ( v12 != v11 )
    {
      return v10;
    }
    a1[v11] = 0;
    return v10;
  }
  v10 = 0xC000000D;
  if ( v8 )
    *a1 = 0;
  return v10;
}
// 14005630F: variable 'v12' is possibly undefined

//----- (0000000140056D30) ----------------------------------------------------
char sub_140056D30(__int64 a1, __int64 a2, __int64 a3, __int64 a4, ...)
{
  va_list va; // [rsp+50h] [rbp+8h] BYREF

  va_start(va, a4);
  ((void (__fastcall *)(_QWORD, char *))loc_14006B180)(0i64, va);
  return 1;
}
// 140056D57: control flows out of bounds to 140056D5F

//----- (00000001400574EC) ----------------------------------------------------
__int64 __fastcall sub_1400574EC(_QWORD *a1, _QWORD *a2)
{
  unsigned __int64 v2; // rax
  __int64 v4; // rcx
  _QWORD *i; // rsi
  unsigned __int64 v7; // rcx
  __int64 *v8; // rdx
  __int64 v9; // r8
  _QWORD *v10; // rdx
  __int64 *v11; // rcx
  unsigned __int64 v12; // rdx
  __int64 v13; // r8
  _QWORD *v14; // rcx

  v2 = a1[1];
  v4 = a2[1];
  i = 0i64;
  if ( v2 == v4 )
  {
    v7 = 0i64;
    for ( i = a1; v7 < v2; v2 = a1[1] )
    {
      v8 = 0i64;
      if ( v7 < a2[1] )
        v8 = (__int64 *)(a2[3] + *a2 * v7);
      v9 = *v8;
      v10 = 0i64;
      if ( v7 < v2 )
        v10 = (_QWORD *)(a1[3] + *a1 * v7);
      *v10 += v9;
      ++v7;
    }
    goto LABEL_18;
  }
  if ( v4 == 1 )
  {
    v11 = (__int64 *)a2[3];
    i = a1;
    v12 = 0i64;
    v13 = *v11;
    if ( !v2 )
    {
LABEL_19:
      sub_140051220((__int64)v11);
      sub_140051220((__int64)a2);
      return (__int64)i;
    }
    do
    {
      v14 = 0i64;
      if ( v12 < v2 )
        v14 = (_QWORD *)(a1[3] + *a1 * v12);
      *v14 += v13;
      ++v12;
      v2 = a1[1];
    }
    while ( v12 < v2 );
LABEL_18:
    v11 = (__int64 *)a2[3];
    goto LABEL_19;
  }
  if ( v2 != 1 )
  {
    sub_140051220(a1[3]);
    sub_140051220((__int64)a1);
    goto LABEL_18;
  }
  return sub_1400574EC(a2, a1);
}

//----- (00000001400575DC) ----------------------------------------------------
__int64 __fastcall sub_1400575DC(__int64 a1, unsigned __int64 a2, __int64 a3, unsigned __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int a9)
{
  _QWORD *v10; // rsi
  _QWORD *v14; // rbx
  int v15; // er8
  int v16; // er8
  __int64 v17; // rax
  _QWORD *v18; // rcx
  __int64 v19; // rcx
  __int64 v20; // rax
  int v21; // edx
  _QWORD *v22; // rdi
  int v23; // edx
  __int64 v24; // rax
  unsigned __int64 v25; // rdx
  unsigned __int64 i; // rcx
  _QWORD *v27; // rax
  unsigned __int64 v28; // rax
  __int64 v29; // rcx
  unsigned __int64 j; // rcx
  __int64 *v31; // rdx
  __int64 v32; // r8
  _QWORD *v33; // rdx
  __int64 *v34; // rcx
  unsigned __int64 v35; // rdx
  __int64 v36; // r8
  _QWORD *v37; // rcx
  unsigned __int64 v38; // rdx
  unsigned __int64 k; // rcx
  _QWORD *v40; // rax
  _QWORD *v41; // r15
  unsigned __int64 v42; // rcx
  unsigned __int64 v43; // rdi
  unsigned __int64 v44; // rsi
  unsigned __int64 *v45; // rax
  __int64 v46; // rsi
  __int64 v47; // r12
  __int64 v49; // [rsp+28h] [rbp-8h]
  __int64 savedregs; // [rsp+30h] [rbp+0h]
  __int64 savedregs_8; // [rsp+38h] [rbp+8h]
  __int64 savedregs_16; // [rsp+40h] [rbp+10h]

  v10 = 0i64;
  v14 = 0i64;
  v15 = *(_DWORD *)(a3 + 4) - 1;
  if ( !v15 )
    return sub_1400579F8(a1, *(_DWORD *)(a3 + 0x20), a4, a9);
  v16 = v15 - 1;
  if ( v16 )
  {
    if ( v16 == 2 )
    {
      v14 = (_QWORD *)sub_140045FCC(8i64);
      if ( v14 )
      {
        v17 = *(_QWORD *)(a3 + 0x60);
        a7 = v17;
        if ( *(_BYTE *)(a3 + 0x59) )
          a7 = *(_QWORD *)a2 + v17 + *(unsigned __int8 *)(a2 + 0x10);
        v18 = v14;
LABEL_8:
        sub_140046028(v18, (__int64)&a7);
        return (__int64)v14;
      }
    }
    return (__int64)v14;
  }
  if ( ((*(_DWORD *)(a3 + 0x2C) - 0xC7) & 0xFFFFFFFD) == 0 && *(_WORD *)(a3 + 0x14) <= 0x40u )
  {
    if ( (int)sub_14006B2D8(a2 + 8, a3, *(_QWORD *)a2, &a7) >= 0 )
    {
      if ( *(_DWORD *)(a3 + 4) == 2 && *(_DWORD *)(a3 + 0x28) == 1 )
      {
        if ( !sub_1400135E4(
                *(_QWORD *)(a1 + 0x10),
                0x40000000,
                0x2000000,
                a2,
                8i64,
                v49,
                savedregs,
                savedregs_8,
                savedregs_16) )
        {
          sub_14002FED0(a2, 8i64, (__int64)&a7);
          JUMPOUT(0x1400576F4i64);
        }
        v19 = *(_QWORD *)a2;
      }
      else
      {
        v19 = a7;
      }
      a7 = v19;
      if ( v19 )
      {
        v20 = sub_140045FCC(8i64);
        v14 = (_QWORD *)v20;
        if ( !v20 )
          return (__int64)v14;
        v18 = (_QWORD *)v20;
        goto LABEL_8;
      }
    }
    v21 = *(_DWORD *)(a3 + 0x30);
    v22 = 0i64;
    if ( !v21 || (v22 = (_QWORD *)sub_1400579F8(a1, v21, a4, a9)) != 0i64 )
    {
      v23 = *(_DWORD *)(a3 + 0x34);
      if ( v23 )
      {
        v24 = sub_1400579F8(a1, v23, a4, a9);
        v10 = (_QWORD *)v24;
        if ( !v24 )
        {
          if ( v22 )
          {
            sub_140051220(v22[3]);
            sub_140051220((__int64)v22);
          }
          return (__int64)v14;
        }
        if ( *(_BYTE *)(a3 + 0x38) != 1 )
        {
          v25 = *(_QWORD *)(v24 + 8);
          for ( i = 0i64; i < v25; v25 = v10[1] )
          {
            v27 = 0i64;
            if ( i < v25 )
              v27 = (_QWORD *)(v10[3] + *v10 * i);
            ++i;
            *v27 *= *(unsigned __int8 *)(a3 + 0x38);
          }
        }
      }
      if ( v22 )
      {
        if ( v10 )
        {
          v28 = v22[1];
          v14 = 0i64;
          v29 = v10[1];
          if ( v28 == v29 )
          {
            v14 = v22;
            for ( j = 0i64; j < v28; v28 = v22[1] )
            {
              v31 = 0i64;
              if ( j < v10[1] )
                v31 = (__int64 *)(v10[3] + *v10 * j);
              v32 = *v31;
              v33 = 0i64;
              if ( j < v28 )
                v33 = (_QWORD *)(v22[3] + *v22 * j);
              *v33 += v32;
              ++j;
            }
          }
          else if ( v29 == 1 )
          {
            v34 = (__int64 *)v10[3];
            v14 = v22;
            v35 = 0i64;
            v36 = *v34;
            if ( !v28 )
            {
LABEL_53:
              sub_140051220((__int64)v34);
              sub_140051220((__int64)v10);
LABEL_54:
              if ( !v14 )
                return (__int64)v14;
              goto LABEL_59;
            }
            do
            {
              v37 = 0i64;
              if ( v35 < v28 )
                v37 = (_QWORD *)(v22[3] + *v22 * v35);
              *v37 += v36;
              ++v35;
              v28 = v22[1];
            }
            while ( v35 < v28 );
          }
          else
          {
            if ( v28 == 1 )
            {
              v14 = (_QWORD *)sub_1400574EC(v10, v22);
              goto LABEL_54;
            }
            sub_140051220(v22[3]);
            sub_140051220((__int64)v22);
          }
          v34 = (__int64 *)v10[3];
          goto LABEL_53;
        }
        v14 = v22;
      }
      else
      {
        if ( !v10 )
          return (__int64)v14;
        v14 = v10;
      }
LABEL_59:
      if ( *(_BYTE *)(a3 + 0x40) )
      {
        v38 = v14[1];
        for ( k = 0i64; k < v38; v38 = v14[1] )
        {
          v40 = 0i64;
          if ( k < v38 )
            v40 = (_QWORD *)(v14[3] + *v14 * k);
          *v40 += *(_QWORD *)(a3 + 0x48);
          ++k;
        }
      }
      if ( *(_DWORD *)(a3 + 0x28) != 1 )
        return (__int64)v14;
      v41 = (_QWORD *)sub_140045FCC(8i64);
      if ( !v41 || (v42 = v14[1], v43 = 0i64, !v42) )
      {
LABEL_74:
        sub_140051220(v14[3]);
        sub_140051220((__int64)v14);
        return (__int64)v41;
      }
      while ( 1 )
      {
        v44 = *(unsigned __int16 *)(a3 + 0x14);
        v45 = 0i64;
        a7 = 0i64;
        v46 = v44 >> 3;
        if ( v43 < v42 )
          v45 = (unsigned __int64 *)(v14[3] + *v14 * v43);
        v47 = *v45;
        if ( sub_1400135E4(
               *(_QWORD *)(a1 + 0x10),
               0x40000000,
               0x2000000,
               *v45,
               v46,
               v49,
               savedregs,
               savedregs_8,
               savedregs_16) )
        {
          break;
        }
        if ( sub_14002FED0(v47, v46, (__int64)&a7) == v46 )
          goto LABEL_72;
LABEL_73:
        v42 = v14[1];
        if ( ++v43 >= v42 )
          goto LABEL_74;
      }
      ((void (__fastcall *)(__int64 *, __int64, __int64))loc_14006F000)(&a7, v47, v46);
LABEL_72:
      sub_140046028(v41, (__int64)&a7);
      goto LABEL_73;
    }
  }
  return (__int64)v14;
}
// 1400576F1: control flows out of bounds to 1400576F4
// 1400576D0: variable 'v49' is possibly undefined
// 1400576D0: variable 'savedregs' is possibly undefined
// 1400576D0: variable 'savedregs_8' is possibly undefined
// 1400576D0: variable 'savedregs_16' is possibly undefined

//----- (00000001400579F8) ----------------------------------------------------
__int64 __fastcall sub_1400579F8(__int64 a1, int a2, unsigned __int64 a3, unsigned int a4)
{
  int v4; // ebx
  _QWORD *v5; // rdi
  __int64 v7; // r13
  __int64 v8; // r8
  __int64 v9; // r9
  _QWORD *v10; // rax
  __int64 v11; // r14
  int v12; // ebx
  int v13; // ebx
  int v14; // ebx
  int v15; // ebx
  int v16; // ebx
  int v17; // ebx
  int v18; // ebx
  int v19; // ebx
  int v20; // ebx
  int v21; // ebx
  int v22; // ebx
  int v23; // ebx
  int v24; // ebx
  _QWORD *v25; // rax
  __int64 v26; // rbp
  char v27; // al
  int v28; // edx
  int v29; // er12
  int v30; // eax
  unsigned __int64 v31; // rcx
  __int64 v32; // r12
  int v33; // er13
  int v34; // eax
  unsigned __int64 v35; // rax
  _QWORD *v36; // rcx
  __int64 v37; // rbp
  __int64 v38; // r12
  int v39; // er13
  int v40; // eax
  unsigned __int8 v41; // cl
  int v42; // eax
  _QWORD *v43; // rbx
  _QWORD *v44; // rsi
  __int64 v45; // rcx
  unsigned __int64 v46; // rax
  __int64 v47; // rcx
  unsigned __int64 j; // rcx
  __int64 *v49; // rdx
  __int64 v50; // r8
  _QWORD *v51; // rdx
  __int64 *v52; // rcx
  unsigned __int64 v53; // rdx
  __int64 v54; // r8
  _QWORD *v55; // rcx
  __int64 v57; // rax
  unsigned __int64 v58; // rax
  unsigned __int64 i; // rdx
  int *v60; // rcx
  int v61; // eax
  _QWORD *v62; // rsi
  unsigned __int64 v63; // rcx
  unsigned __int64 k; // rbx
  __int64 *v65; // rax
  _QWORD *v66; // rax
  __int64 v68; // [rsp+20h] [rbp-58h]
  __int64 v69; // [rsp+28h] [rbp-50h]
  int v70; // [rsp+30h] [rbp-48h] BYREF
  int v71; // [rsp+34h] [rbp-44h]
  __int64 v72[8]; // [rsp+38h] [rbp-40h] BYREF
  __int64 v73; // [rsp+80h] [rbp+8h]

  v73 = a1;
  v4 = 0;
  v5 = 0i64;
  v7 = a1;
  if ( a4 >= 5 || (unsigned __int16)sub_14006B588(0, a2) < 0x20u )
    return (__int64)v5;
  do
  {
    while ( 1 )
    {
      if ( !a3 )
        return (__int64)v5;
      v10 = *(_QWORD **)(v7 + 0x50);
      --a3;
      v11 = 0i64;
      if ( a3 < v10[1] )
        v11 = v10[3] + *v10 * a3;
      if ( *(_DWORD *)(v11 + 0x4B8) != 0x1C )
        break;
      v4 = *(_DWORD *)(v11 + 0xC);
      if ( !(unsigned __int8)((__int64 (__fastcall *)(__int64, unsigned __int64))loc_140056E38)(v7, a3) )
      {
        if ( v4 > 0x12C )
        {
          v19 = v4 - 0x12D;
          if ( v19 )
          {
            v20 = v19 - 1;
            if ( v20 )
            {
              v21 = v20 - 1;
              if ( v21 )
              {
                v22 = v21 - 1;
                if ( v22 )
                {
                  v23 = v22 - 1;
                  if ( v23 )
                  {
                    v24 = v23 - 2;
                    if ( v24 )
                    {
                      if ( v24 == 1 )
                        v4 = 0x12F;
                      else
LABEL_34:
                        v4 = 0;
                    }
                    else
                    {
                      v4 = 0x12E;
                    }
                  }
                  else
                  {
                    v4 = 0x12D;
                  }
                }
                else
                {
                  v4 = 0x12C;
                }
              }
              else
              {
                v4 = 0x134;
              }
            }
            else
            {
              v4 = 0x133;
            }
          }
          else
          {
            v4 = 0x131;
          }
        }
        else if ( v4 == 0x12C )
        {
          v4 = 0x130;
        }
        else
        {
          v12 = v4 - 0x11F;
          if ( v12 )
          {
            v13 = v12 - 1;
            if ( v13 )
            {
              v14 = v13 - 5;
              if ( v14 )
              {
                v15 = v14 - 1;
                if ( v15 )
                {
                  v16 = v15 - 2;
                  if ( v16 )
                  {
                    v17 = v16 - 1;
                    if ( v17 )
                    {
                      v18 = v17 - 1;
                      if ( v18 )
                      {
                        if ( v18 != 1 )
                          goto LABEL_34;
                        v4 = 0x126;
                      }
                      else
                      {
                        v4 = 0x125;
                      }
                    }
                    else
                    {
                      v4 = 0x120;
                    }
                  }
                  else
                  {
                    v4 = 0x11F;
                  }
                }
                else
                {
                  v4 = 0x12B;
                }
              }
              else
              {
                v4 = 0x12A;
              }
            }
            else
            {
              v4 = 0x129;
            }
          }
          else
          {
            v4 = 0x128;
          }
        }
      }
    }
    sub_14006B3F4(v11 + 8, &v70, v8, v9, v68, v69, v70);
    v25 = *(_QWORD **)(v7 + 0x50);
    v26 = 0i64;
    if ( a3 < v25[1] )
      v26 = v25[3] + *v25 * a3;
    if ( *(_DWORD *)(v26 + 0xC) != 0x3B )
      goto LABEL_51;
    v27 = ((__int64 (__fastcall *)(__int64, unsigned __int64))loc_140056E38)(v7, a3);
    v28 = a2;
    if ( !v27 && a2 )
    {
      if ( a2 != 0x35 )
      {
        v29 = sub_14006B4DC(0, a2);
        if ( !v29 || (v30 = sub_14006B4DC(0, 0x35)) == 0 || v29 != v30 )
        {
LABEL_51:
          v28 = a2;
          goto LABEL_52;
        }
      }
LABEL_82:
      v41 = *(_BYTE *)(v11 + 0x1E);
      if ( v41 < 0x20u )
        return (__int64)v5;
      v42 = *(_DWORD *)(v11 + 0xC);
      if ( v42 == 0x17C || v42 == 0x1A3 || v42 == 0x1CB )
        return sub_1400575DC(v7, v11, (int)v11 + 0x90, a3, a4 + 1);
      if ( v42 == 0x1C8 || v42 == 0x3E )
      {
        v57 = sub_1400575DC(v7, v11, (int)v11 + 0x90, a3, a4 + 1);
        v5 = (_QWORD *)v57;
        if ( v57 )
        {
          v58 = *(_QWORD *)(v57 + 8);
          for ( i = 0i64; i < v58; v58 = v5[1] )
          {
            v60 = 0i64;
            if ( i < v58 )
              v60 = (int *)(v5[3] + *v5 * i);
            ++i;
            *(_QWORD *)v60 = *v60;
          }
        }
        return (__int64)v5;
      }
      if ( v42 != 7 )
        return (__int64)v5;
      if ( v41 != 0x40 )
        return (__int64)v5;
      v43 = (_QWORD *)sub_1400575DC(v7, v11, (int)v11 + 0x28, a3, a4 + 1);
      if ( !v43 )
        return (__int64)v5;
      v44 = (_QWORD *)sub_1400575DC(v7, v11, (int)v11 + 0x90, a3, a4 + 1);
      if ( !v44 )
      {
        sub_140051220(v43[3]);
        v45 = (__int64)v43;
LABEL_93:
        sub_140051220(v45);
        return (__int64)v5;
      }
      v46 = v43[1];
      v5 = 0i64;
      v47 = v44[1];
      if ( v46 == v47 )
      {
        v5 = v43;
        for ( j = 0i64; j < v46; v46 = v43[1] )
        {
          v49 = 0i64;
          if ( j < v44[1] )
            v49 = (__int64 *)(v44[3] + *v44 * j);
          v50 = *v49;
          v51 = 0i64;
          if ( j < v46 )
            v51 = (_QWORD *)(v43[3] + *v43 * j);
          *v51 += v50;
          ++j;
        }
        goto LABEL_111;
      }
      if ( v47 == 1 )
      {
        v52 = (__int64 *)v44[3];
        v5 = v43;
        v53 = 0i64;
        v54 = *v52;
        if ( !v46 )
        {
LABEL_112:
          sub_140051220((__int64)v52);
          v45 = (__int64)v44;
          goto LABEL_93;
        }
        do
        {
          v55 = 0i64;
          if ( v53 < v46 )
            v55 = (_QWORD *)(v43[3] + *v43 * v53);
          *v55 += v54;
          ++v53;
          v46 = v43[1];
        }
        while ( v53 < v46 );
LABEL_111:
        v52 = (__int64 *)v44[3];
        goto LABEL_112;
      }
      if ( v46 != 1 )
      {
        sub_140051220(v43[3]);
        sub_140051220((__int64)v43);
        goto LABEL_111;
      }
      return sub_1400574EC(v44, v43);
    }
LABEL_52:
    v31 = 0i64;
    v72[0] = 0i64;
    if ( *(_BYTE *)(v26 + 0x20) )
    {
      v32 = v26 + 0x34;
      do
      {
        if ( *(_DWORD *)(v32 - 8) == 1 && (*(_BYTE *)v32 & 0xA) != 0 )
        {
          if ( v28 )
          {
            v33 = *(_DWORD *)(v32 + 0x14);
            if ( v33 )
            {
              if ( v28 == v33 || (v71 = sub_14006B4DC(0, v28)) != 0 && (v34 = sub_14006B4DC(0, v33)) != 0 && v71 == v34 )
              {
                LODWORD(v7) = v73;
                goto LABEL_82;
              }
              v31 = v72[0];
            }
          }
        }
        v35 = *(unsigned __int8 *)(v26 + 0x20);
        ++v31;
        v28 = a2;
        v32 += 0x68i64;
        v72[0] = v31;
      }
      while ( v31 < v35 );
      v7 = v73;
    }
    if ( !v4 )
      goto LABEL_80;
  }
  while ( !v70 );
  v36 = *(_QWORD **)(v7 + 0x50);
  v37 = 0i64;
  if ( a3 < v36[1] )
    v37 = v36[3] + *v36 * a3;
  v72[0] = 0i64;
  if ( !*(_BYTE *)(v37 + 0x20) )
LABEL_80:
    JUMPOUT(0x140057D59i64);
  v38 = v37 + 0x34;
  while ( 1 )
  {
    if ( *(_DWORD *)(v38 - 8) == 1 && (*(_BYTE *)v38 & 5) != 0 )
    {
      if ( a2 )
      {
        v39 = *(_DWORD *)(v38 + 0x14);
        if ( v39 )
        {
          if ( a2 == v39 )
            break;
          v71 = sub_14006B4DC(0, a2);
          if ( v71 )
          {
            v40 = sub_14006B4DC(0, v39);
            if ( v40 )
            {
              if ( v71 == v40 )
                break;
            }
          }
        }
      }
    }
    ++v72[0];
    v38 += 0x68i64;
    if ( v72[0] >= (unsigned __int64)*(unsigned __int8 *)(v37 + 0x20) )
      goto LABEL_80;
  }
  if ( *(_BYTE *)(v11 + 0x1E) >= 0x20u )
  {
    v61 = *(_DWORD *)(v11 + 0xC);
    if ( v61 == 0x5E )
    {
      if ( *(_DWORD *)(v11 + 0x94) == 4 && (v4 == 0x11F || v4 == 0x120) )
        JUMPOUT(0x140057FE4i64);
    }
    else if ( v61 == 0x2FE
           && *(_DWORD *)(v11 + 0x2C) == *(_DWORD *)(v11 + 0x94)
           && *(_DWORD *)(v11 + 0x48) == *(_DWORD *)(v11 + 0xB0) )
    {
      if ( v4 == 0x12F )
      {
        v5 = (_QWORD *)sub_1400575DC(v73, v11, (int)v11 + 0x28, a3, a4 + 1);
        if ( v5 )
        {
          v62 = (_QWORD *)sub_140045FCC(8i64);
          if ( v62 )
          {
            v63 = v5[1];
            for ( k = 0i64; k < v63; ++k )
            {
              v65 = 0i64;
              if ( k < v63 )
                v65 = (__int64 *)(v5[3] + *v5 * k);
              v72[0] = *v65;
              if ( v72[0] )
              {
                sub_140046028(v62, (__int64)v72);
                v63 = v5[1];
              }
            }
          }
          sub_140051220(v5[3]);
          sub_140051220((__int64)v5);
          v5 = v62;
        }
      }
      else if ( v4 == 0x134 )
      {
        v66 = (_QWORD *)sub_140045FCC(8i64);
        v5 = v66;
        if ( v66 )
        {
          v72[0] = 0i64;
          sub_140046028(v66, (__int64)v72);
        }
      }
    }
  }
  return (__int64)v5;
}
// 140057D57: control flows out of bounds to 140057D59
// 140057FE1: control flows out of bounds to 140057FE4
// 140057B9A: variable 'v8' is possibly undefined
// 140057B9A: variable 'v9' is possibly undefined
// 140057B9A: variable 'v68' is possibly undefined
// 140057B9A: variable 'v69' is possibly undefined
// 1400575DC: using guessed type __int64 __fastcall sub_1400575DC(_DWORD, _DWORD, _DWORD, _DWORD, _DWORD);

//----- (0000000140059014) ----------------------------------------------------
__int64 sub_140059014()
{
  __int64 result; // rax
  __int64 v1; // rcx
  int v2[8]; // [rsp+20h] [rbp-20h] BYREF

  result = (unsigned int)dword_1400D8064;
  if ( dword_1400D8064 == 0xFFFFFFFF )
  {
    v2[0] = 0x5848340E;
    v2[1] = 0xC978616D;
    v2[2] = 0xC3940464;
    v2[3] = 0xBBF59AA1;
    v2[4] = 0x4A74D1EB;
    v1 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v2);
    result = 0i64;
    if ( v1 && *(_BYTE *)v1 == 0x48 && *(_WORD *)(v1 + 1) == 0x818B )
      result = *(unsigned int *)(v1 + 3);
    dword_1400D8064 = result;
  }
  return result;
}
// 1400D8064: using guessed type int dword_1400D8064;

//----- (0000000140059080) ----------------------------------------------------
__int64 __fastcall sub_140059080(PEPROCESS a1)
{
  unsigned int v1; // er8
  int v3; // eax
  __int64 result; // rax

  v1 = dword_1400D8068;
  if ( dword_1400D8068 == 0xFFFFFFFF )
  {
    v3 = sub_140059014();
    v1 = v3 != 0 ? v3 + 8 : 0;
    dword_1400D8068 = v1;
  }
  if ( !v1 )
    return 0i64;
  if ( !a1 )
    a1 = PsInitialSystemProcess;
  result = *(_QWORD *)((char *)a1 + v1) - v1;
  if ( (((unsigned __int64)a1 ^ result) & 0xFFFFFFFF00000000ui64) != 0 )
    return 0i64;
  return result;
}
// 1400D8068: using guessed type int dword_1400D8068;

//----- (00000001400590E8) ----------------------------------------------------
char __fastcall sub_1400590E8(__int64 a1)
{
  if ( a1
    && *(_QWORD *)(a1 + 8)
    && *(_WORD *)a1
    && *(_WORD *)(a1 + 2)
    && !KeGetCurrentIrql()
    && !(unsigned __int8)sub_14000ECDC() )
  {
    JUMPOUT(0x14005911Ei64);
  }
  return 0;
}
// 14005911C: control flows out of bounds to 14005911E

//----- (0000000140059160) ----------------------------------------------------
char __fastcall sub_140059160(__int64 a1)
{
  if ( a1
    && *(_QWORD *)(a1 + 8)
    && *(_WORD *)a1
    && *(_WORD *)(a1 + 2)
    && !KeGetCurrentIrql()
    && !(unsigned __int8)sub_14000ECDC() )
  {
    JUMPOUT(0x140059199i64);
  }
  return 0;
}
// 140059197: control flows out of bounds to 140059199

//----- (00000001400591E8) ----------------------------------------------------
char __fastcall sub_1400591E8(unsigned __int16 *a1, __int64 a2)
{
  __int16 *v4; // r9
  unsigned int v5; // ecx
  __int16 *v6; // rax
  unsigned int v7; // er11
  unsigned int v8; // edx
  __int16 v9; // cx
  __int16 v10; // cx
  int v11; // ecx
  char result; // al

  if ( !a1 )
    return 0;
  if ( !a2 )
    return 0;
  v4 = (__int16 *)*((_QWORD *)a1 + 1);
  if ( !v4 )
    return 0;
  v5 = *a1;
  if ( v5 < 2 )
    return 0;
  v6 = v4;
  v7 = v5 >> 1;
  v8 = 0;
  if ( v5 >> 1 )
  {
    do
    {
      v9 = v4[v8];
      if ( !v9 )
        break;
      if ( v9 != 0x5C )
        JUMPOUT(0x14005925Ei64);
      v6 = (__int16 *)((unsigned __int64)&v4[v8 + 1] & -(__int64)(v8 < v7 - 1));
      ++v8;
    }
    while ( v8 < v7 );
    if ( !v6 )
      return 0;
  }
  v10 = *v6;
  if ( !*v6 || v10 == 0x5C || v10 == 0x3A )
    return 0;
  *(_QWORD *)(a2 + 8) = v6;
  v11 = 2 * ((unsigned __int64)*a1 >> 1) - (_DWORD)v6;
  result = 1;
  LOWORD(v11) = 2 * ((__int64)(unsigned int)(*((_DWORD *)a1 + 2) + v11) >> 1);
  *(_WORD *)a2 = v11;
  *(_WORD *)(a2 + 2) = v11;
  return result;
}
// 14005925A: control flows out of bounds to 14005925E

//----- (00000001400592B8) ----------------------------------------------------
char __fastcall sub_1400592B8(HANDLE FileHandle, __int64 *a2, ULONG *a3)
{
  char v3; // bl
  ULONG Length; // esi
  void *Buffer; // rax
  __int64 v9; // rdi
  struct _IO_STATUS_BLOCK IoStatusBlock; // [rsp+50h] [rbp-48h] BYREF
  char FileInformation[8]; // [rsp+60h] [rbp-38h] BYREF
  ULONG v13; // [rsp+68h] [rbp-30h]

  v3 = 0;
  if ( !FileHandle )
    return 0;
  if ( !a2 )
    return 0;
  if ( !a3 )
    return 0;
  *a2 = 0i64;
  *a3 = 0;
  if ( KeGetCurrentIrql() || (unsigned __int8)sub_14000ECDC() )
    return 0;
  if ( ZwQueryInformationFile(FileHandle, &IoStatusBlock, FileInformation, 0x18u, FileStandardInformation) >= 0 )
  {
    Length = v13;
    if ( v13 )
    {
      Buffer = (void *)sub_140051084(v13);
      v9 = (__int64)Buffer;
      if ( Buffer )
      {
        if ( ZwReadFile(FileHandle, 0i64, 0i64, 0i64, &IoStatusBlock, Buffer, Length, 0i64, 0i64) < 0 )
        {
          sub_140051220(v9);
        }
        else
        {
          *a2 = v9;
          v3 = 1;
          *a3 = Length;
        }
      }
    }
  }
  return v3;
}

//----- (00000001400593BC) ----------------------------------------------------
char __fastcall sub_1400593BC(__int64 a1, _QWORD *a2, _DWORD *a3)
{
  if ( a1 )
  {
    if ( *(_QWORD *)(a1 + 8) )
    {
      if ( *(_WORD *)a1 )
      {
        if ( *(_WORD *)(a1 + 2) )
        {
          if ( a2 )
          {
            if ( a3 )
            {
              *a2 = 0i64;
              *a3 = 0;
              if ( !KeGetCurrentIrql() && !(unsigned __int8)sub_14000ECDC() )
                JUMPOUT(0x140059461i64);
            }
          }
        }
      }
    }
  }
  return 0;
}
// 140059459: control flows out of bounds to 140059461

//----- (00000001400594F4) ----------------------------------------------------
char __fastcall sub_1400594F4(__int64 a1, _QWORD *a2, _DWORD *a3, __int64 a4)
{
  char v4; // bl
  unsigned __int64 v7; // rax
  ULONG v9; // [rsp+20h] [rbp-28h] BYREF
  __int64 v10; // [rsp+28h] [rbp-20h]
  unsigned __int16 v11[12]; // [rsp+30h] [rbp-18h] BYREF

  v4 = 0;
  v10 = a1;
  if ( a1 )
  {
    v7 = 0xFFFFFFFFFFFFFFFFui64;
    do
      ++v7;
    while ( *(_BYTE *)(a1 + v7) );
    LOWORD(v9) = v7;
    HIWORD(v9) = v7 + 1;
  }
  else
  {
    v9 = 0;
  }
  if ( (int)sub_140007274(v11, (unsigned __int16 *)&v9, (__int64)a3, a4, v9) >= 0 )
  {
    v4 = sub_1400593BC((__int64)v11, a2, a3);
    sub_14000724C((__int64)v11);
  }
  return v4;
}

//----- (0000000140059578) ----------------------------------------------------
char __fastcall sub_140059578(__int64 a1, __int64 a2, __int64 a3)
{
  if ( a1
    && *(_QWORD *)(a1 + 8)
    && *(_WORD *)a1
    && *(_WORD *)(a1 + 2)
    && a3
    && !KeGetCurrentIrql()
    && !(unsigned __int8)sub_14000ECDC() )
  {
    JUMPOUT(0x140059605i64);
  }
  return 0;
}
// 1400595FD: control flows out of bounds to 140059605

//----- (00000001400596B8) ----------------------------------------------------
char __fastcall sub_1400596B8(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned int a7, __int64 a8)
{
  __int64 v8; // rax
  int v10[6]; // [rsp+20h] [rbp-29h] BYREF
  char v11[72]; // [rsp+38h] [rbp-11h] BYREF
  int v12; // [rsp+80h] [rbp+37h]

  if ( sub_1400593BC(a1, &a8, &a7) )
  {
    if ( !a8 )
      JUMPOUT(0x1400596F1i64);
    v10[0] = 0x67452301;
    v10[1] = 0xEFCDAB89;
    v10[2] = 0x98BADCFE;
    v10[3] = 0x10325476;
    v10[4] = 0xC3D2E1F0;
    ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v11, 0i64, 0x48i64);
    v12 = 0;
    v8 = sub_140003C4C((__int64)v10, a8, a7);
    sub_140003B10(v8);
    JUMPOUT(0x14005974Bi64);
  }
  return 0;
}
// 1400596EF: control flows out of bounds to 1400596F1
// 140059746: control flows out of bounds to 14005974B

//----- (00000001400599C8) ----------------------------------------------------
LONG_PTR sub_1400599C8()
{
  LONG_PTR result; // rax

  qword_1400D82F8 = 0i64;
  qword_1400D8308 = 0i64;
  qword_1400D8310 = 0i64;
  qword_1400D8318 = 0i64;
  if ( qword_1400D8300 )
  {
    result = ObfDereferenceObject(qword_1400D8300);
    qword_1400D8300 = 0i64;
  }
  _InterlockedExchange(&dword_1400D82F0, 0);
  return result;
}
// 1400D82F0: using guessed type int dword_1400D82F0;
// 1400D82F8: using guessed type __int64 qword_1400D82F8;
// 1400D8308: using guessed type __int64 qword_1400D8308;
// 1400D8310: using guessed type __int64 qword_1400D8310;
// 1400D8318: using guessed type __int64 qword_1400D8318;

//----- (000000014005BC14) ----------------------------------------------------
void sub_14005BC14()
{
  JUMPOUT(0x14005BC28i64);
}
// 14005BC26: control flows out of bounds to 14005BC28

//----- (000000014005BDBC) ----------------------------------------------------
__int64 sub_14005BDBC()
{
  if ( Filter )
  {
    FltUnregisterFilter(Filter);
    Filter = 0i64;
  }
  return 0i64;
}

//----- (000000014005BDE4) ----------------------------------------------------
__int64 sub_14005BDE4()
{
  if ( !Filter )
    JUMPOUT(0x14005BE28i64);
  return 0xC0000718i64;
}
// 14005BE22: control flows out of bounds to 14005BE28

//----- (000000014005CF68) ----------------------------------------------------
void __fastcall sub_14005CF68(__int64 a1)
{
  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a1, 0i64, 0x48i64);
  *(_QWORD *)(a1 + 0x18) = 0i64;
  *(_DWORD *)(a1 + 0x20) = 0;
  *(_DWORD *)(a1 + 0x10) = 1;
  *(_DWORD *)(a1 + 0xC) = 0x8044DC0E;
  KeInitializeEvent((PRKEVENT)(a1 + 0x28), SynchronizationEvent, 0);
}

//----- (000000014005D1A0) ----------------------------------------------------
bool __fastcall sub_14005D1A0(__int64 a1, __int64 a2, unsigned int *a3)
{
  int v3; // er15
  unsigned int *v4; // rbx
  unsigned __int64 v7; // rbp
  unsigned int v8; // edx
  unsigned __int64 v9; // r8
  char *v10; // rcx
  char *v11; // rax
  int v12; // er8
  char *v13; // r10
  unsigned int v14; // er11
  __int64 v15; // r8
  unsigned __int64 v16; // rax
  _BYTE *v17; // r10
  unsigned int v18; // er11
  unsigned int v19; // eax
  __int64 v21; // [rsp+20h] [rbp-28h] BYREF
  __int16 v22; // [rsp+28h] [rbp-20h]

  v3 = *(_DWORD *)(a1 + 8);
  v4 = (unsigned int *)&unk_1400BD4A8;
  v21 = 0i64;
  v22 = 0;
  v7 = 0i64;
  while ( 1 )
  {
    v8 = v4[5];
    if ( v8 != v3 )
      goto LABEL_13;
    v9 = *(unsigned int *)(a1 + 0xC);
    if ( ((v3 != 0) + 1i64) * v9 < 8 )
      goto LABEL_13;
    v10 = *(char **)a1;
    v21 = *((_QWORD *)v4 + 1);
    if ( v8 )
    {
      v13 = sub_140007598(v10, (char *)&v21, v9);
      if ( !v13 )
        goto LABEL_13;
      v16 = *v4;
      if ( v15 - ((unsigned __int64)(unsigned int)((_DWORD)v13 - *(_DWORD *)a1) >> 1) < v16 )
        goto LABEL_13;
      v14 = 2 * v16;
    }
    else
    {
      v11 = sub_14000761C(v10, (unsigned __int8 *)&v21, v9);
      v13 = v11;
      if ( !v11 )
        goto LABEL_13;
      v14 = *v4;
      if ( *(_DWORD *)a1 + v12 - (int)v11 < *v4 )
        goto LABEL_13;
    }
    if ( (unsigned int)sub_14000512C(v13, v14, 0) == v4[0xFFFFFFFE]
      && (unsigned int)sub_140025404(v17, v18) == v4[0xFFFFFFFF] )
    {
      break;
    }
LABEL_13:
    v7 += 0x20i64;
    v4 += 8;
    if ( v7 >= 0x440 )
    {
      v19 = *a3;
      return v19 != 0;
    }
  }
  v19 = v4[4];
  *a3 = v19;
  return v19 != 0;
}
// 14005D226: variable 'v12' is possibly undefined
// 14005D24B: variable 'v15' is possibly undefined
// 14005D270: variable 'v17' is possibly undefined
// 14005D270: variable 'v18' is possibly undefined

//----- (000000014005D2B8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_14005D2B8()
{
  JUMPOUT(0x14005D2CFi64);
}
// 14005D4CD: positive sp value 28 has been found
// 14005D2C8: control flows out of bounds to 14005D2CF

//----- (000000014005D5B8) ----------------------------------------------------
__int64 __fastcall sub_14005D5B8(unsigned __int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  unsigned __int64 v7; // rsi
  void *v8; // rdi
  unsigned __int64 v9; // rsi
  unsigned __int64 v10; // rbp
  bool i; // cf
  int v12; // ecx
  unsigned int v14; // [rsp+50h] [rbp+8h]

  v14 = 0;
  v7 = a2 & 0xFFFFFFFFFFFFF000ui64;
  if ( a1 < (unsigned __int64)MmSystemRangeStart
    || (a1 & 0xFFFFFFFFFFFFF000ui64) != a1
    || !v7
    || ((qword_1400D82B8 ^ a1) & 0xFFFFFFFF00000000ui64) != 0 )
  {
    return 0i64;
  }
  v8 = (void *)sub_140051084(0x1000ui64);
  if ( v8 )
  {
    v9 = a1 + v7;
    v10 = a1;
    for ( i = a1 < v9; i && !v14; i = v10 < v9 )
    {
      if ( sub_14003019C(v10, 0x1000ui64, v8) == 0x1000 )
      {
        sub_1400306D0();
        if ( v10 == a1 )
        {
          if ( sub_14005240C((__int64)v8, 0x1000ui64, 0i64, &a6) )
          {
            if ( *(_WORD *)(a6 + 6) == 7 && *(_DWORD *)(a6 + 0x28) == 0x9064 && *(_DWORD *)(a6 + 0x50) == 0xB000 )
            {
              v12 = *(_DWORD *)(a6 + 8);
              if ( v12 == 0x56F975FA || v12 == 0x57089DA8 )
              {
                v14 = 0;
                break;
              }
            }
          }
          v14 = ((__int64 (__fastcall *)(void *))loc_14005D4D0)(v8);
        }
      }
      v10 += 0x1000i64;
    }
    sub_140051220((__int64)v8);
  }
  return v14;
}
// 14005D6DC: conditional instruction was optimized away because of '%arg_0.4==0'
// 1400D82B8: using guessed type __int64 qword_1400D82B8;

//----- (000000014005D720) ----------------------------------------------------
__int64 __fastcall sub_14005D720(__int64 a1)
{
  __int64 v2; // rax
  int v4[6]; // [rsp+38h] [rbp-31h] BYREF
  char v5[72]; // [rsp+50h] [rbp-19h] BYREF
  int v6; // [rsp+98h] [rbp+2Fh]

  if ( a1 )
  {
    v4[0] = 0x67452301;
    v4[1] = 0xEFCDAB89;
    v4[2] = 0x98BADCFE;
    v4[3] = 0x10325476;
    v4[4] = 0xC3D2E1F0;
    ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v5, 0i64, 0x48i64);
    v6 = 0;
    v2 = sub_14005DD60((__int64)v4, a1, 0x14ui64);
    sub_14005DC24(v2);
    JUMPOUT(0x14005D7A0i64);
  }
  return 0i64;
}
// 14005D79D: control flows out of bounds to 14005D7A0

//----- (000000014005D804) ----------------------------------------------------
__int64 __fastcall sub_14005D804(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, __int64 a5)
{
  unsigned int v5; // ebx
  __int64 v8; // rdi
  bool v9; // bl
  __int64 v10; // rcx
  _DWORD *v12; // [rsp+20h] [rbp-8h]

  v5 = 0;
  a5 = 0i64;
  if ( !a1 || !a2 )
    return 0i64;
  if ( sub_140025A00(a1, a2, &a5, a4, v12) )
  {
    v8 = a5;
    v5 = sub_14005D720(a5 + 0x34);
    if ( v5 == 0x17 )
    {
      v9 = 0;
      if ( sub_14005240C(a1, a2, 0i64, &a5) )
        v9 = *(_DWORD *)(a5 + 8) >= 0x5F3DE56Cu;
      v5 = !v9 ? 0x17 : 0;
    }
    if ( v8 )
    {
      v10 = *(_QWORD *)(v8 + 8);
      if ( v10 )
      {
        sub_140051220(v10);
        JUMPOUT(0x14005D89Ci64);
      }
      sub_14000724C(v8 + 0x10);
      sub_140051220(v8);
    }
  }
  return v5;
}
// 14005D897: control flows out of bounds to 14005D89C
// 14005D83A: variable 'v12' is possibly undefined

//----- (000000014005D8D0) ----------------------------------------------------
__int64 __fastcall sub_14005D8D0(__int64 a1)
{
  __int64 result; // rax

  result = 0i64;
  if ( a1 )
    JUMPOUT(0x14005D8F4i64);
  return result;
}
// 14005D8EE: control flows out of bounds to 14005D8F4

//----- (000000014005D9E8) ----------------------------------------------------
__int64 __fastcall sub_14005D9E8(__int64 a1)
{
  unsigned int v2; // ebx
  __int64 v3; // rdx
  __int64 v4; // rcx
  __int64 v5; // r8
  __int64 v6; // r9
  unsigned int *v7; // rax
  __int64 v8; // r8
  __int64 v9; // r9
  unsigned int *v10; // rsi
  unsigned int v11; // ebp
  __int64 v12; // rdi
  unsigned __int64 v13; // r8
  __int64 v14; // rdx
  unsigned __int64 v15; // rcx
  char v16; // dl
  _BYTE *v17; // rax
  __int64 v18; // rcx
  char v19; // al
  unsigned int v21; // [rsp+20h] [rbp-18h]
  __int64 v22; // [rsp+20h] [rbp-18h]
  __int64 v23; // [rsp+28h] [rbp-10h]

  v2 = 0;
  KeQueryTimeIncrement();
  v7 = (unsigned int *)sub_14002D72C(v4, v3, v5, v6, v21);
  v10 = v7;
  if ( !v7 )
    goto LABEL_23;
  v11 = 0;
  if ( *v7 )
  {
    do
    {
      if ( v2 )
        break;
      v12 = (__int64)&v10[0x4A * v11 + 2];
      v2 = sub_14005D5B8(*(_QWORD *)(v12 + 0x10), *(unsigned int *)(v12 + 0x18), v8, v9, v22, v23);
      if ( v2 || (v2 = sub_14005D8D0(v12), v2 != 0x16) )
      {
        if ( v2 == 5 )
        {
          v15 = 0i64;
          v8 = v12 + *(unsigned __int16 *)(v12 + 0x26);
          v16 = *(_BYTE *)(v8 + 0x28);
          v17 = (_BYTE *)(v8 + 0x28);
          if ( v16 )
          {
            do
            {
              ++v17;
              ++v15;
            }
            while ( *v17 );
            if ( v15 >= 0x10 && v16 == 0x70 )
            {
              v18 = 1i64;
              while ( (unsigned __int8)(*(_BYTE *)(v18 + v8 + 0x28) - 0x30) <= 9u )
              {
                if ( (unsigned __int64)++v18 >= 0xC )
                {
                  v2 = 0;
                  break;
                }
              }
            }
          }
        }
      }
      else if ( v12 != 0xFFFFFFFFFFFFFFD8ui64 && a1 )
      {
        v13 = 0i64;
        v14 = *(unsigned __int16 *)(v12 + 0x26) + v12 + 0x28;
        if ( v14 )
        {
          do
          {
            if ( !*(_BYTE *)(v14 + v13) )
              break;
            ++v13;
          }
          while ( v13 < 0x100 );
        }
        JUMPOUT(0x14005DAAEi64);
      }
      ++v11;
    }
    while ( v11 < *v10 );
  }
  sub_140051220((__int64)v10);
  if ( !v2 )
  {
LABEL_23:
    sub_14005D2B8();
    if ( !v19 )
    {
      sub_140045DCC();
      JUMPOUT(0x14005DB37i64);
    }
    v2 = 0x12;
  }
  return v2;
}
// 14005DAAB: control flows out of bounds to 14005DAAE
// 14005DB32: control flows out of bounds to 14005DB37
// 14005DA15: variable 'v4' is possibly undefined
// 14005DA15: variable 'v3' is possibly undefined
// 14005DA15: variable 'v5' is possibly undefined
// 14005DA15: variable 'v6' is possibly undefined
// 14005DA15: variable 'v21' is possibly undefined
// 14005DA55: variable 'v8' is possibly undefined
// 14005DA55: variable 'v9' is possibly undefined
// 14005DA55: variable 'v22' is possibly undefined
// 14005DA55: variable 'v23' is possibly undefined
// 14005DB22: variable 'v19' is possibly undefined

//----- (000000014005DB58) ----------------------------------------------------
__int64 __fastcall sub_14005DB58(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 a4, unsigned int a5, __int64 a6, __int64 a7)
{
  __int64 v9; // rcx
  __int64 v10; // r9
  __int64 result; // rax
  __int64 v12; // r8
  __int64 v13; // r9
  int v14; // ecx
  __int64 v15; // [rsp+20h] [rbp-18h]

  a5 = 0;
  if ( !a1 || !a2 )
    return 0i64;
  sub_1400306D0();
  result = a5;
  if ( !a5 )
  {
    result = sub_140054C98(v9, a1, a2, v10, (__int64)&a5);
    a5 = result;
    if ( !(_DWORD)result )
    {
      result = sub_14005D804(a1, a2, v12, v13, v15);
      a5 = result;
    }
  }
  if ( (_DWORD)result == 9 )
  {
    if ( !sub_14005240C(a1, 0x1000ui64, 0i64, &a7) )
      return a5;
    if ( *(_WORD *)(a7 + 6) != 7 )
      return a5;
    if ( *(_DWORD *)(a7 + 0x28) != 0x9064 )
      return a5;
    if ( *(_DWORD *)(a7 + 0x50) != 0xB000 )
      return a5;
    v14 = *(_DWORD *)(a7 + 8);
    if ( v14 != 0x56F975FA && v14 != 0x57089DA8 )
      return a5;
    return 0i64;
  }
  return result;
}
// 14005DBA6: variable 'v9' is possibly undefined
// 14005DBA6: variable 'v10' is possibly undefined
// 14005DBB9: variable 'v12' is possibly undefined
// 14005DBB9: variable 'v13' is possibly undefined
// 14005DBB9: variable 'v15' is possibly undefined

//----- (000000014005DC24) ----------------------------------------------------
void __fastcall sub_14005DC24(__int64 a1)
{
  __int64 v2; // rax
  unsigned __int64 v3; // r8
  unsigned __int64 i; // r9
  char v5; // cl
  char v6; // [rsp+20h] [rbp-19h] BYREF
  char v7[111]; // [rsp+21h] [rbp-18h] BYREF

  v6 = 0x80;
  ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v7, 0i64, 0x47i64);
  v2 = *(_QWORD *)(a1 + 0x18);
  v3 = (-((_DWORD)v2 + 9) & 0x3F) + 1i64;
  for ( i = 0i64; i < 0x40; i += 8i64 )
  {
    v5 = 0x38 - i;
    *(&v6 + v3++) = (unsigned __int64)(8 * v2) >> v5;
  }
  sub_14005DD60(a1, (__int64)&v6, v3);
  JUMPOUT(0x14005DC9Fi64);
}
// 14005DC9D: control flows out of bounds to 14005DC9F

//----- (000000014005DD60) ----------------------------------------------------
__int64 __fastcall sub_14005DD60(__int64 a1, __int64 a2, unsigned __int64 a3)
{
  unsigned __int64 v3; // rbx
  __int64 v4; // rdi
  _BYTE *v7; // rdx
  __int64 v8; // rcx
  char v9; // al
  _BYTE *v10; // rcx
  char v11; // al
  char v13[64]; // [rsp+20h] [rbp-58h] BYREF

  v3 = 0i64;
  v4 = *(_QWORD *)(a1 + 0x18) & 0x3Fi64;
  *(_QWORD *)(a1 + 0x18) += a3;
  if ( v4 + a3 >= 0x40 )
  {
    if ( v4 )
    {
      v7 = (_BYTE *)(v4 + a1 + 0x20);
      v8 = 0x40 - v4;
      do
      {
        v9 = *(_BYTE *)(v3 + a2);
        ++v3;
        *v7++ = v9;
        --v8;
      }
      while ( v8 );
    }
    ((void (__fastcall *)(char *, _QWORD, __int64))loc_14006F2C0)(v13, 0i64, 0x40i64);
    JUMPOUT(0x14005DE32i64);
  }
  if ( a3 )
  {
    v10 = (_BYTE *)(v4 + a1 + 0x20);
    do
    {
      v11 = *(_BYTE *)(v3 + a2);
      ++v3;
      *v10++ = v11;
    }
    while ( v3 < a3 );
  }
  return a1;
}
// 14005DE2F: control flows out of bounds to 14005DE32
// 14005DDAB: conditional instruction was optimized away because of 'rdi.8 in (1..3F)'

//----- (000000014005E728) ----------------------------------------------------
char __fastcall sub_14005E728(__int64 a1, __int64 a2, _DWORD *a3, _DWORD *a4)
{
  char v4; // bp
  unsigned __int64 v7; // rsi
  _DWORD *v8; // rax
  unsigned int v10; // ecx
  __int64 v11; // r14
  unsigned __int64 v12; // rdx
  unsigned __int64 v13; // rsi
  _DWORD *v14; // rdx
  unsigned int v15; // [rsp+20h] [rbp-18h]

  v4 = 0;
  if ( !a1 )
  {
    if ( a4 )
      *a4 = 2;
    return 0;
  }
  v7 = *(_QWORD *)(a1 + 0xE0);
  if ( !v7 )
  {
    if ( a4 )
      *a4 = 4;
    return 0;
  }
  v8 = (_DWORD *)sub_14002D72C(a1, a2, (__int64)a3, (__int64)a4, v15);
  if ( !v8 )
  {
    if ( a4 )
      *a4 = 5;
    return 0;
  }
  v10 = 0;
  if ( *v8 )
  {
    while ( 1 )
    {
      v11 = 0x4Ai64 * v10;
      v12 = *(_QWORD *)&v8[v11 + 6];
      if ( v12 >= (unsigned __int64)MmSystemRangeStart && v7 >= v12 && v7 <= v12 + (unsigned int)v8[v11 + 8] )
        break;
      if ( ++v10 >= *v8 )
        goto LABEL_24;
    }
    v4 = 1;
    if ( a3 )
    {
      *a3 = v7 - v12;
      v13 = 0i64;
      v14 = &v8[v11 + 0xC];
      if ( v14 )
      {
        do
        {
          if ( !*((_BYTE *)v14 + v13) )
            break;
          ++v13;
        }
        while ( v13 < 0x100 );
      }
      JUMPOUT(0x14005E811i64);
    }
    if ( a4 )
      *a4 = 7;
  }
LABEL_24:
  sub_140051220((__int64)v8);
  if ( !v4 && a4 )
    *a4 = 6;
  return v4;
}
// 14005E80E: control flows out of bounds to 14005E811
// 14005E776: variable 'v15' is possibly undefined

//----- (000000014005E86C) ----------------------------------------------------
#error "14005E8BA: call analysis failed (funcsize=58)"

//----- (000000014005EF44) ----------------------------------------------------
char __fastcall sub_14005EF44(__int64 a1, _QWORD *a2)
{
  char v3; // si
  unsigned __int64 v4; // rdi
  unsigned int v5; // edx
  unsigned __int64 v6; // r8
  char v7; // cl
  int v8; // eax
  char v9; // dl
  int v11; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v12; // [rsp+68h] [rbp-98h]
  int v13[3]; // [rsp+70h] [rbp-90h]
  __int16 v14; // [rsp+7Ch] [rbp-84h]
  __int64 v15[2]; // [rsp+7Eh] [rbp-82h] BYREF
  int v16; // [rsp+90h] [rbp-70h]
  int v17; // [rsp+C0h] [rbp-40h]
  int *v18; // [rsp+100h] [rbp+0h]

  v3 = 0;
  if ( !a1 || !*(_QWORD *)(a1 + 8) || !*(_WORD *)a1 || !*(_WORD *)(a1 + 2) || !a2 )
    return 0;
  *a2 = 0i64;
  if ( !KeGetCurrentIrql() && !(unsigned __int8)sub_14000ECDC() )
  {
    v12 = sub_140051084(0x200ui64);
    if ( v12 )
    {
      v11 = 0x2000000;
      if ( (int)sub_1400073D4((unsigned __int16 *)&v11, (unsigned __int16 *)a1) < 0 )
        goto LABEL_14;
      v13[0] = 0x51632776;
      v14 = 0xA501;
      v4 = 0xCi64;
      v13[1] = 0x414E7972;
      v15[0] = 0i64;
      v5 = 0x510F2758;
      LODWORD(v15[1]) = 0;
      v6 = 0i64;
      WORD2(v15[1]) = 0;
      v13[2] = 0x45976DCA;
      do
      {
        *(_DWORD *)((char *)v15 + v6 * 4) = v13[v6] ^ v5;
        ++v6;
        v5 = __ROR4__(
               ((v5 ^ (v5 << 0xD)) >> 0x11) ^ v5 ^ (v5 << 0xD) ^ (0x20
                                                                * (((v5 ^ (v5 << 0xD)) >> 0x11) ^ v5 ^ (v5 << 0xD))),
               3);
      }
      while ( v6 < 3 );
      do
      {
        v7 = v5;
        v5 >>= 8;
        *((_BYTE *)v15 + v4) = *((_BYTE *)v13 + v4) ^ v7;
        ++v4;
      }
      while ( v4 < 0xE );
      v3 = 1;
      v8 = sub_140007338((unsigned __int16 *)&v11, (__int64)v15);
      v9 = 1;
      if ( v8 < 0 )
LABEL_14:
        v9 = 0;
      if ( (v3 & 1) != 0 )
        memset(v15, 0, 0xEui64);
      if ( v9 )
      {
        if ( v12 )
        {
          if ( (_WORD)v11 && HIWORD(v11) && !KeGetCurrentIrql() && !(unsigned __int8)sub_14000ECDC() )
          {
            v16 = 0x30;
            JUMPOUT(0x14005F132i64);
          }
          if ( v12 && (_WORD)v11 && HIWORD(v11) && !KeGetCurrentIrql() && !(unsigned __int8)sub_14000ECDC() )
          {
            v17 = 0x30;
            JUMPOUT(0x14005F17Fi64);
          }
        }
        v18 = &v11;
        JUMPOUT(0x14005F1CCi64);
      }
      sub_140051220(v12);
    }
  }
  return 1;
}
// 14005F12F: control flows out of bounds to 14005F132
// 14005F17C: control flows out of bounds to 14005F17F
// 14005F1C8: control flows out of bounds to 14005F1CC

//----- (000000014005F240) ----------------------------------------------------
char __fastcall sub_14005F240(__int64 a1)
{
  char v1; // si
  __int64 v2; // rdi
  UNICODE_STRING String2; // [rsp+20h] [rbp-28h] BYREF

  v1 = 0;
  if ( !dword_1400DB244
    || !a1
    || !*(_QWORD *)(a1 + 8)
    || !*(_WORD *)a1
    || !*(_WORD *)(a1 + 2)
    || KeGetCurrentIrql()
    || !sub_140007178((__int64)&String2, (unsigned __int16 *)a1, *(_WORD *)a1) )
  {
    return 0;
  }
  KeEnterCriticalRegion();
  ExAcquireFastMutexUnsafe(&stru_1400DB290);
  if ( qword_1400DB288 )
  {
    v2 = qword_1400DB288;
    if ( !*(_DWORD *)(qword_1400DB288 + 0x18)
      || !RtlEqualUnicodeString((PCUNICODE_STRING)(qword_1400DB288 + 8), &String2, 1u) )
    {
      JUMPOUT(0x14005F318i64);
    }
    ++*(_DWORD *)(v2 + 0x18);
    v1 = 1;
  }
  ExReleaseFastMutexUnsafe(&stru_1400DB290);
  KeLeaveCriticalRegion();
  sub_14000724C((__int64)&String2);
  return v1;
}
// 14005F314: control flows out of bounds to 14005F318
// 14005F340: control flows out of bounds to 14005F343
// 14005F312: conditional instruction was optimized away because of 'er12.4==0'
// 14005F366: conditional instruction was optimized away because of 'r12.1==0'
// 1400DB244: using guessed type int dword_1400DB244;
// 1400DB288: using guessed type __int64 qword_1400DB288;

//----- (000000014005F3A0) ----------------------------------------------------
void __fastcall sub_14005F3A0(PCUNICODE_STRING String2)
{
  __int64 v2; // rbx
  unsigned int v3; // ebp
  __int64 v4; // rdi
  unsigned __int64 v6; // rcx

  if ( !dword_1400DB244
    || !String2
    || !String2->Buffer
    || !String2->Length
    || !String2->MaximumLength
    || KeGetCurrentIrql() )
  {
    return;
  }
  KeEnterCriticalRegion();
  ExAcquireFastMutexUnsafe(&stru_1400DB290);
  v2 = qword_1400DB288;
  if ( !qword_1400DB288 )
    goto LABEL_17;
  v3 = 0;
  v4 = 0i64;
  while ( !*(_DWORD *)(v4 + v2 + 0x18) )
  {
LABEL_12:
    ++v3;
    v4 += 0x20i64;
    if ( v3 >= 0x20 )
      goto LABEL_17;
  }
  if ( !RtlEqualUnicodeString((PCUNICODE_STRING)(v4 + v2 + 8), String2, 1u) )
  {
    v2 = qword_1400DB288;
    goto LABEL_12;
  }
  if ( (*(_DWORD *)(v4 + v2 + 0x18))-- == 1 )
  {
    sub_14000724C(v4 + v2 + 8);
    v6 = *(_QWORD *)(v4 + v2);
    if ( v6 )
    {
      sub_1400612D4(v6);
      *(_QWORD *)(v4 + v2) = 0i64;
    }
  }
LABEL_17:
  ExReleaseFastMutexUnsafe(&stru_1400DB290);
  KeLeaveCriticalRegion();
}
// 1400DB244: using guessed type int dword_1400DB244;
// 1400DB288: using guessed type __int64 qword_1400DB288;

//----- (000000014005F4A8) ----------------------------------------------------
void sub_14005F4A8()
{
  __int64 v0; // rcx
  unsigned int v1; // edi
  __int64 v2; // rbx

  KeGetCurrentIrql();
  if ( dword_1400DB244 )
  {
    KeEnterCriticalRegion();
    ExAcquireFastMutexUnsafe(&stru_1400DB290);
    v0 = qword_1400DB288;
    if ( qword_1400DB288 )
    {
      v1 = 0;
      v2 = 0i64;
      do
      {
        if ( *(_DWORD *)(v2 + v0 + 0x18) )
        {
          sub_14000724C(0x20i64 * v1 + 8 + v0);
          v0 = qword_1400DB288;
          if ( *(_QWORD *)(v2 + qword_1400DB288) )
          {
            sub_1400612D4(*(_QWORD *)(v2 + qword_1400DB288));
            v0 = qword_1400DB288;
          }
        }
        ++v1;
        v2 += 0x20i64;
      }
      while ( v1 < 0x20 );
      sub_140051220(v0);
      qword_1400DB288 = 0i64;
    }
    ExReleaseFastMutexUnsafe(&stru_1400DB290);
    KeLeaveCriticalRegion();
  }
}
// 1400DB244: using guessed type int dword_1400DB244;
// 1400DB288: using guessed type __int64 qword_1400DB288;

//----- (000000014005F9CC) ----------------------------------------------------
char __fastcall sub_14005F9CC(unsigned __int64 a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned int v3; // edx
  int v4; // er10
  int v6; // er11
  int v7; // eax
  __int64 v8; // r9
  _BYTE *i; // rcx
  int v11; // eax
  bool v12; // zf

  v3 = 0;
  v4 = 0;
  if ( !a1 )
    return 0;
  if ( !a3 )
    return 0;
  v6 = *a3;
  if ( !(_BYTE)v6 )
    return 0;
  v7 = *((_DWORD *)a3 + 5);
  if ( _bittest(&v7, 9u) )
  {
    if ( (v7 & 4) != 0 )
    {
      v3 = 1;
    }
    else if ( (v7 & 8) != 0 )
    {
      v3 = 2;
    }
    else if ( (v7 & 0x10) != 0 )
    {
      v3 = 4;
    }
    else
    {
      v8 = 0i64;
      if ( (v7 & 0x20) == 0 )
      {
LABEL_14:
        if ( !v3 || !v4 )
          return 0;
        goto LABEL_24;
      }
      v3 = 8;
    }
    v8 = 2i64;
    v4 = 2;
    goto LABEL_14;
  }
  if ( (v7 & 0x40) != 0 )
  {
    v3 = 1;
    v8 = 1i64;
LABEL_24:
    for ( i = (_BYTE *)(a1 + v6 - v3); ; --i )
    {
      if ( (unsigned __int64)i <= a1 )
        return 0;
      if ( v8 != 1 )
        break;
      if ( v3 == 1 && *i == a3[0x10] || v3 == 2 && *(_WORD *)i == *((_WORD *)a3 + 8) )
      {
LABEL_41:
        ((void (__fastcall *)(_BYTE *, __int64, _QWORD))loc_14006F2C0)(i, 0xAAi64, v3);
        return 1;
      }
      if ( v3 == 4 )
      {
        v11 = *((_DWORD *)a3 + 4);
        goto LABEL_33;
      }
LABEL_45:
      ;
    }
    if ( v8 != 2 )
      goto LABEL_45;
    switch ( v3 )
    {
      case 1u:
        if ( *i == a3[8] )
          goto LABEL_41;
        break;
      case 2u:
        if ( *(_WORD *)i == *((_WORD *)a3 + 4) )
          goto LABEL_41;
        break;
      case 4u:
        v11 = *((_DWORD *)a3 + 2);
LABEL_33:
        v12 = *(_DWORD *)i == v11;
LABEL_44:
        if ( v12 )
          goto LABEL_41;
        goto LABEL_45;
    }
    if ( v3 != 8 )
      goto LABEL_45;
    v12 = *(_QWORD *)i == *((_QWORD *)a3 + 1);
    goto LABEL_44;
  }
  if ( (char)v7 < 0 )
  {
    v3 = 2;
LABEL_23:
    v8 = 1i64;
    goto LABEL_24;
  }
  if ( _bittest(&v7, 8u) )
  {
    v3 = 4;
    goto LABEL_23;
  }
  return 0;
}

//----- (000000014005FAF8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_14005FAF8()
{
  JUMPOUT(0x14005FB15i64);
}
// 14005FF53: positive sp value 18 has been found
// 14005FB10: control flows out of bounds to 14005FB15

//----- (0000000140061030) ----------------------------------------------------
__int64 __fastcall sub_140061030(__int64 a1)
{
  struct _KTHREAD *v1; // rbx
  unsigned int v3; // eax
  char v4; // di
  __int64 (__fastcall *v5)(__int64, _QWORD, _QWORD, _QWORD); // rsi
  unsigned int v6; // esi

  v1 = KeGetCurrentThread();
  v3 = sub_140065008();
  if ( v1 && v3 )
    v4 = *((_BYTE *)v1 + v3);
  else
    v4 = 0;
  v5 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                  qword_1400DB308,
                                                                  &qword_1400DB308,
                                                                  0i64);
  sub_140065AB8((__int64)v1, 0);
  if ( v5 )
    v6 = v5(a1, 0i64, 0i64, 0i64);
  else
    v6 = 0xC0000002;
  sub_140065AB8((__int64)v1, v4);
  return v6;
}
// 1400DB308: using guessed type __int64 qword_1400DB308;

//----- (0000000140061108) ----------------------------------------------------
__int64 __fastcall sub_140061108(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, _QWORD, __int64, __int64); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DB310,
                                                                     &qword_1400DB310,
                                                                     0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB310: using guessed type __int64 qword_1400DB310;

//----- (00000001400611F8) ----------------------------------------------------
__int64 __fastcall sub_1400611F8(__int64 a1)
{
  struct _KTHREAD *v1; // rbx
  unsigned int v3; // eax
  char v4; // di
  __int64 (__fastcall *v5)(__int64, _QWORD, _QWORD, _QWORD); // rsi
  unsigned int v6; // esi

  v1 = KeGetCurrentThread();
  v3 = sub_140065008();
  if ( v1 && v3 )
    v4 = *((_BYTE *)v1 + v3);
  else
    v4 = 0;
  v5 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                  qword_1400DB318,
                                                                  &qword_1400DB318,
                                                                  0i64);
  sub_140065AB8((__int64)v1, 0);
  if ( v5 )
    v6 = v5(a1, 0i64, 0i64, 0i64);
  else
    v6 = 0xC0000002;
  sub_140065AB8((__int64)v1, v4);
  return v6;
}
// 1400DB318: using guessed type __int64 qword_1400DB318;

//----- (00000001400612D4) ----------------------------------------------------
__int64 __fastcall sub_1400612D4(unsigned __int64 a1)
{
  struct _KTHREAD *v2; // rbx
  unsigned int v3; // eax
  char v4; // si
  __int64 (__fastcall *v5)(unsigned __int64); // rbp
  unsigned int v6; // edi

  if ( a1 > 0xFFFFFFFFFFFFFFFDui64 )
    return 0i64;
  v2 = KeGetCurrentThread();
  v3 = sub_140065008();
  if ( v2 && v3 )
    v4 = *((_BYTE *)v2 + v3);
  else
    v4 = 0;
  v5 = (__int64 (__fastcall *)(unsigned __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                   qword_1400DB320,
                                                   &qword_1400DB320,
                                                   0i64);
  sub_140065AB8((__int64)v2, 0);
  if ( v5 )
    v6 = v5(a1);
  else
    v6 = 0xC0000002;
  sub_140065AB8((__int64)v2, v4);
  return v6;
}
// 1400DB320: using guessed type __int64 qword_1400DB320;

//----- (0000000140061370) ----------------------------------------------------
__int64 __fastcall sub_140061370(__int64 a1, __int64 a2)
{
  struct _KTHREAD *v2; // rbx
  unsigned int v5; // eax
  char v6; // di
  __int64 (__fastcall *v7)(__int64, __int64, __int64, __int64); // rsi
  __int64 v8; // r9
  unsigned int v9; // esi

  v2 = KeGetCurrentThread();
  v5 = sub_140065008();
  if ( v2 && v5 )
    v6 = *((_BYTE *)v2 + v5);
  else
    v6 = 0;
  v7 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DB330,
                                                                     &qword_1400DB330,
                                                                     0i64);
  sub_140065AB8((__int64)v2, 0);
  if ( v7 )
  {
    LOBYTE(v8) = 1;
    v9 = v7(a1, a2, 0x400i64, v8);
  }
  else
  {
    v9 = 0xC0000002;
  }
  sub_140065AB8((__int64)v2, v6);
  return v9;
}
// 1400613FD: variable 'v8' is possibly undefined
// 1400DB330: using guessed type __int64 qword_1400DB330;

//----- (0000000140061430) ----------------------------------------------------
__int64 __fastcall sub_140061430(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v7; // eax
  char v8; // di
  __int64 (__fastcall *v9)(unsigned __int64, __int64, unsigned __int64, __int64); // rsi
  unsigned int v10; // esi

  v4 = KeGetCurrentThread();
  v7 = sub_140065008();
  if ( v4 && v7 )
    v8 = *((_BYTE *)v4 + v7);
  else
    v8 = 0;
  v9 = (__int64 (__fastcall *)(unsigned __int64, __int64, unsigned __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                                       qword_1400DB338,
                                                                                       &qword_1400DB338,
                                                                                       0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v9 )
    v10 = v9(0xFFFFFFFFFFFFFFFFui64, a2, 0xFFFFFFFFFFFFFFFFui64, a4);
  else
    v10 = 0xC0000002;
  sub_140065AB8((__int64)v4, v8);
  return v10;
}
// 1400DB338: using guessed type __int64 qword_1400DB338;

//----- (00000001400614EC) ----------------------------------------------------
__int64 __fastcall sub_1400614EC(__int64 a1, __int64 a2, __int64 a3)
{
  struct _KTHREAD *v3; // rbx
  unsigned int v6; // eax
  char v7; // si
  __int64 (__fastcall *v8)(__int64, __int64, __int64, __int64); // rdi
  unsigned int v9; // edi

  v3 = KeGetCurrentThread();
  v6 = sub_140065008();
  if ( v3 && v6 )
    v7 = *((_BYTE *)v3 + v6);
  else
    v7 = 0;
  v8 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DB398,
                                                                     &qword_1400DB398,
                                                                     0i64);
  sub_140065AB8((__int64)v3, 0);
  if ( v8 )
    v9 = v8(a1, 1i64, a3, 0x100i64);
  else
    v9 = 0xC0000002;
  sub_140065AB8((__int64)v3, v7);
  return v9;
}
// 1400DB398: using guessed type __int64 qword_1400DB398;

//----- (00000001400615A4) ----------------------------------------------------
__int64 __fastcall sub_1400615A4(__int64 a1, __int64 a2, __int64 a3)
{
  struct _KTHREAD *v3; // rbx
  unsigned int v6; // eax
  char v7; // si
  __int64 (__fastcall *v8)(__int64, __int64, __int64); // rdi
  unsigned int v9; // edi

  v3 = KeGetCurrentThread();
  v6 = sub_140065008();
  if ( v3 && v6 )
    v7 = *((_BYTE *)v3 + v6);
  else
    v7 = 0;
  v8 = (__int64 (__fastcall *)(__int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                            qword_1400DB348,
                                                            &qword_1400DB348,
                                                            0i64);
  sub_140065AB8((__int64)v3, 0);
  if ( v8 )
    v9 = v8(a1, 4i64, a3);
  else
    v9 = 0xC0000002;
  sub_140065AB8((__int64)v3, v7);
  return v9;
}
// 1400DB348: using guessed type __int64 qword_1400DB348;

//----- (0000000140061650) ----------------------------------------------------
__int64 __fastcall sub_140061650(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v8; // eax
  char v9; // si
  __int64 (__fastcall *v10)(unsigned __int64, _QWORD, __int64, _QWORD); // rdi
  unsigned int v11; // edi

  v4 = KeGetCurrentThread();
  v8 = sub_140065008();
  if ( v4 && v8 )
    v9 = *((_BYTE *)v4 + v8);
  else
    v9 = 0;
  v10 = (__int64 (__fastcall *)(unsigned __int64, _QWORD, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                             qword_1400DB350,
                                                                             &qword_1400DB350,
                                                                             0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v10 )
    v11 = v10(0xFFFFFFFFFFFFFFFFui64, a2, a3, a4);
  else
    v11 = 0xC0000002;
  sub_140065AB8((__int64)v4, v9);
  return v11;
}
// 1400DB350: using guessed type __int64 qword_1400DB350;

//----- (00000001400616FC) ----------------------------------------------------
__int64 __fastcall sub_1400616FC(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, __int64, __int64, __int64); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                      qword_1400DB358,
                                                                      &qword_1400DB358,
                                                                      0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB358: using guessed type __int64 qword_1400DB358;

//----- (00000001400617C4) ----------------------------------------------------
__int64 __fastcall sub_1400617C4(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v8; // eax
  char v9; // si
  __int64 (__fastcall *v10)(unsigned __int64, __int64, __int64, __int64); // rdi
  unsigned int v11; // edi

  v4 = KeGetCurrentThread();
  v8 = sub_140065008();
  if ( v4 && v8 )
    v9 = *((_BYTE *)v4 + v8);
  else
    v9 = 0;
  v10 = (__int64 (__fastcall *)(unsigned __int64, __int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                               qword_1400DB378,
                                                                               &qword_1400DB378,
                                                                               0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v10 )
    v11 = v10(0xFFFFFFFFFFFFFFFFui64, a2, a3, a4);
  else
    v11 = 0xC0000002;
  sub_140065AB8((__int64)v4, v9);
  return v11;
}
// 1400DB378: using guessed type __int64 qword_1400DB378;

//----- (0000000140061870) ----------------------------------------------------
__int64 __fastcall sub_140061870(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, __int64, __int64, _QWORD); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DB370,
                                                                     &qword_1400DB370,
                                                                     0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB370: using guessed type __int64 qword_1400DB370;

//----- (0000000140061928) ----------------------------------------------------
__int64 __fastcall sub_140061928(__int64 a1, __int64 a2, __int64 a3, unsigned int a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, __int64, __int64, _QWORD); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(__int64, __int64, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DB388,
                                                                     &qword_1400DB388,
                                                                     0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB388: using guessed type __int64 qword_1400DB388;

//----- (00000001400619E8) ----------------------------------------------------
__int64 __fastcall sub_1400619E8(__int64 a1, unsigned int a2, __int64 a3, __int64 a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v8; // eax
  char v9; // si
  __int64 (__fastcall *v10)(unsigned __int64, _QWORD, __int64, __int64); // rdi
  unsigned int v11; // edi

  v4 = KeGetCurrentThread();
  v8 = sub_140065008();
  if ( v4 && v8 )
    v9 = *((_BYTE *)v4 + v8);
  else
    v9 = 0;
  v10 = (__int64 (__fastcall *)(unsigned __int64, _QWORD, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                              qword_1400DB380,
                                                                              &qword_1400DB380,
                                                                              0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v10 )
    v11 = v10(0xFFFFFFFFFFFFFFFFui64, a2, a3, a4);
  else
    v11 = 0xC0000002;
  sub_140065AB8((__int64)v4, v9);
  return v11;
}
// 1400DB380: using guessed type __int64 qword_1400DB380;

//----- (0000000140061AA4) ----------------------------------------------------
__int64 __fastcall sub_140061AA4(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, _QWORD, __int64, _QWORD); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                    qword_1400DB390,
                                                                    &qword_1400DB390,
                                                                    0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB390: using guessed type __int64 qword_1400DB390;

//----- (0000000140061B64) ----------------------------------------------------
__int64 __fastcall sub_140061B64(unsigned int a1, __int64 a2, unsigned int a3, __int64 a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(_QWORD, __int64, _QWORD, __int64); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(_QWORD, __int64, _QWORD, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                    qword_1400DB3B0,
                                                                    &qword_1400DB3B0,
                                                                    0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB3B0: using guessed type __int64 qword_1400DB3B0;

//----- (0000000140061C1C) ----------------------------------------------------
__int64 __fastcall sub_140061C1C(__int64 a1, __int64 a2, unsigned int a3, __int64 a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, __int64, _QWORD, __int64); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(__int64, __int64, _QWORD, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DB3C0,
                                                                     &qword_1400DB3C0,
                                                                     0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB3C0: using guessed type __int64 qword_1400DB3C0;

//----- (0000000140061CE8) ----------------------------------------------------
__int64 __fastcall sub_140061CE8(__int64 a1, unsigned int a2, __int64 a3, unsigned int a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, _QWORD, __int64, _QWORD); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                    qword_1400DB3C8,
                                                                    &qword_1400DB3C8,
                                                                    0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB3C8: using guessed type __int64 qword_1400DB3C8;

//----- (0000000140061DA4) ----------------------------------------------------
__int64 __fastcall sub_140061DA4(__int64 a1, unsigned int a2)
{
  __int64 v4; // rax
  struct _KTHREAD *v5; // rbx
  __int64 (__fastcall *v6)(__int64, _QWORD); // rdi
  unsigned int v7; // eax
  char v8; // si
  unsigned int v9; // edi
  int v11[8]; // [rsp+20h] [rbp-20h] BYREF

  v11[0] = 0xD462C506;
  v11[1] = 0x34D178B4;
  v11[2] = 0x140492E7;
  v11[3] = 0xABD28886;
  v11[4] = 0xCA70EA8E;
  v4 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v11);
  v5 = KeGetCurrentThread();
  v6 = (__int64 (__fastcall *)(__int64, _QWORD))v4;
  v7 = sub_140065008();
  if ( v5 && v7 )
    v8 = *((_BYTE *)v5 + v7);
  else
    v8 = 0;
  sub_140065AB8((__int64)v5, 0);
  if ( v6 )
    v9 = v6(a1, a2);
  else
    v9 = 0xC0000002;
  sub_140065AB8((__int64)v5, v8);
  return v9;
}

//----- (0000000140061E5C) ----------------------------------------------------
__int64 __fastcall sub_140061E5C(__int64 a1, __int64 a2, __int64 a3)
{
  struct _KTHREAD *v3; // rbx
  unsigned int v7; // eax
  char v8; // si
  __int64 (__fastcall *v9)(__int64, __int64, __int64, __int64); // rdi
  unsigned int v10; // edi

  v3 = KeGetCurrentThread();
  v7 = sub_140065008();
  if ( v3 && v7 )
    v8 = *((_BYTE *)v3 + v7);
  else
    v8 = 0;
  v9 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                     qword_1400DB3A0,
                                                                     &qword_1400DB3A0,
                                                                     0i64);
  sub_140065AB8((__int64)v3, 0);
  if ( v9 )
    v10 = v9(a1, a2, a3, 4i64);
  else
    v10 = 0xC0000002;
  sub_140065AB8((__int64)v3, v8);
  return v10;
}
// 1400DB3A0: using guessed type __int64 qword_1400DB3A0;

//----- (0000000140061F14) ----------------------------------------------------
__int64 __fastcall sub_140061F14(__int64 a1, __int64 a2, __int64 a3, __int64 a4)
{
  struct _KTHREAD *v4; // rbx
  unsigned int v9; // eax
  char v10; // si
  __int64 (__fastcall *v11)(__int64, __int64, __int64, __int64); // rdi
  unsigned int v12; // edi

  v4 = KeGetCurrentThread();
  v9 = sub_140065008();
  if ( v4 && v9 )
    v10 = *((_BYTE *)v4 + v9);
  else
    v10 = 0;
  v11 = (__int64 (__fastcall *)(__int64, __int64, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                      qword_1400DB3A8,
                                                                      &qword_1400DB3A8,
                                                                      0i64);
  sub_140065AB8((__int64)v4, 0);
  if ( v11 )
    v12 = v11(a1, a2, a3, a4);
  else
    v12 = 0xC0000002;
  sub_140065AB8((__int64)v4, v10);
  return v12;
}
// 1400DB3A8: using guessed type __int64 qword_1400DB3A8;

//----- (0000000140061FD4) ----------------------------------------------------
__int64 __fastcall sub_140061FD4(__int64 a1, __int64 a2, __int64 a3)
{
  struct _KTHREAD *v3; // rbx
  unsigned int v6; // eax
  char v7; // si
  __int64 (__fastcall *v8)(__int64, _QWORD, __int64, __int64); // rdi
  unsigned int v9; // edi

  v3 = KeGetCurrentThread();
  v6 = sub_140065008();
  if ( v3 && v6 )
    v7 = *((_BYTE *)v3 + v6);
  else
    v7 = 0;
  v8 = (__int64 (__fastcall *)(__int64, _QWORD, __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                    qword_1400DB3B8,
                                                                    &qword_1400DB3B8,
                                                                    0i64);
  sub_140065AB8((__int64)v3, 0);
  if ( v8 )
    v9 = v8(a1, 0i64, a3, 0x18i64);
  else
    v9 = 0xC0000002;
  sub_140065AB8((__int64)v3, v7);
  return v9;
}
// 1400DB3B8: using guessed type __int64 qword_1400DB3B8;

//----- (0000000140062084) ----------------------------------------------------
__int64 __fastcall sub_140062084(__int64 a1, __int64 a2, __int64 a3)
{
  struct _KTHREAD *v3; // rbx
  unsigned int v6; // eax
  char v7; // di
  __int64 (__fastcall *v8)(__int64, unsigned __int64, __int64, _QWORD); // rsi
  unsigned int v9; // esi

  v3 = KeGetCurrentThread();
  v6 = sub_140065008();
  if ( v3 && v6 )
    v7 = *((_BYTE *)v3 + v6);
  else
    v7 = 0;
  v8 = (__int64 (__fastcall *)(__int64, unsigned __int64, __int64, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                             qword_1400DB3E8,
                                                                             &qword_1400DB3E8,
                                                                             0i64);
  sub_140065AB8((__int64)v3, 0);
  if ( v8 )
    v9 = v8(a1, 0xFFFFFFFFFFFFFFFFui64, a3, 0i64);
  else
    v9 = 0xC0000002;
  sub_140065AB8((__int64)v3, v7);
  return v9;
}
// 1400DB3E8: using guessed type __int64 qword_1400DB3E8;

//----- (000000014006215C) ----------------------------------------------------
__int64 __fastcall sub_14006215C(__int64 a1, __int64 a2)
{
  struct _KTHREAD *v2; // rbx
  unsigned int v4; // eax
  char v5; // si
  __int64 (__fastcall *v6)(unsigned __int64, __int64); // rdi
  unsigned int v7; // edi

  v2 = KeGetCurrentThread();
  v4 = sub_140065008();
  if ( v2 && v4 )
    v5 = *((_BYTE *)v2 + v4);
  else
    v5 = 0;
  v6 = (__int64 (__fastcall *)(unsigned __int64, __int64))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                            qword_1400DB3F0,
                                                            &qword_1400DB3F0,
                                                            0i64);
  sub_140065AB8((__int64)v2, 0);
  if ( v6 )
    v7 = v6(0xFFFFFFFFFFFFFFFFui64, a2);
  else
    v7 = 0xC0000002;
  sub_140065AB8((__int64)v2, v5);
  return v7;
}
// 1400DB3F0: using guessed type __int64 qword_1400DB3F0;

//----- (00000001400621F4) ----------------------------------------------------
__int64 __fastcall sub_1400621F4(__int64 a1)
{
  struct _KTHREAD *v1; // rbx
  unsigned int v3; // eax
  char v4; // di
  __int64 (__fastcall *v5)(__int64, _QWORD, _QWORD, _QWORD); // rsi
  unsigned int v6; // esi

  v1 = KeGetCurrentThread();
  v3 = sub_140065008();
  if ( v1 && v3 )
    v4 = *((_BYTE *)v1 + v3);
  else
    v4 = 0;
  v5 = (__int64 (__fastcall *)(__int64, _QWORD, _QWORD, _QWORD))((__int64 (__fastcall *)(__int64, __int64 *, _QWORD))loc_1400404E8)(
                                                                  qword_1400DB400,
                                                                  &qword_1400DB400,
                                                                  0i64);
  sub_140065AB8((__int64)v1, 0);
  if ( v5 )
    v6 = v5(a1, 0i64, 0i64, 0i64);
  else
    v6 = 0xC0000002;
  sub_140065AB8((__int64)v1, v4);
  return v6;
}
// 1400DB400: using guessed type __int64 qword_1400DB400;

//----- (00000001400624B4) ----------------------------------------------------
char __fastcall sub_1400624B4(__int64 a1, _DWORD *a2)
{
  char v3; // si
  unsigned __int64 v4; // rdi
  unsigned int v5; // edx
  unsigned __int64 v6; // r8
  char v7; // cl
  int v8; // eax
  char v9; // dl
  int v11; // [rsp+60h] [rbp-A0h] BYREF
  __int64 v12; // [rsp+68h] [rbp-98h]
  int v13[2]; // [rsp+70h] [rbp-90h] BYREF
  __int16 v14; // [rsp+78h] [rbp-88h]
  _BYTE v15[10]; // [rsp+7Ah] [rbp-86h] BYREF
  _BYTE *v16; // [rsp+88h] [rbp-78h]
  int *v17; // [rsp+98h] [rbp-68h]
  __int64 v18; // [rsp+A8h] [rbp-58h]

  v3 = 0;
  if ( !a1 || !*(_QWORD *)(a1 + 8) || !*(_WORD *)a1 || !*(_WORD *)(a1 + 2) || !a2 )
    return 0;
  *a2 = 0;
  v12 = sub_140051084(0x200ui64);
  if ( v12 )
  {
    v11 = 0x2000000;
    if ( (int)sub_1400073D4((unsigned __int16 *)&v11, (unsigned __int16 *)a1) < 0 )
      goto LABEL_13;
    v13[0] = 0x790BFED2;
    v14 = 0xB80E;
    v4 = 8i64;
    v13[1] = 0xCF9C0E61;
    *(_QWORD *)v15 = 0i64;
    v5 = 0x796EFEFC;
    *(_WORD *)&v15[8] = 0;
    v6 = 0i64;
    v17 = v13;
    v16 = v15;
    do
    {
      *(_DWORD *)&v16[v6 * 4] = v17[v6] ^ v5;
      ++v6;
      v5 = __ROR4__(
             ((v5 ^ (v5 << 0xD)) >> 7) ^ v5 ^ (v5 << 0xD) ^ ((((v5 ^ (v5 << 0xD)) >> 7) ^ v5 ^ (v5 << 0xD)) << 0x11),
             1);
    }
    while ( v6 < 2 );
    v16 = v15;
    do
    {
      v7 = v5;
      v5 >>= 8;
      v16[v4] = *((_BYTE *)v13 + v4) ^ v7;
      ++v4;
    }
    while ( v4 < 0xA );
    v3 = 1;
    v8 = sub_140007338((unsigned __int16 *)&v11, (__int64)v15);
    v9 = 1;
    if ( v8 < 0 )
LABEL_13:
      v9 = 0;
    if ( (v3 & 1) != 0 )
      memset(v15, 0, sizeof(v15));
    if ( v9 && v12 && (_WORD)v11 && HIWORD(v11) && !KeGetCurrentIrql() && !(unsigned __int8)sub_14000ECDC() )
    {
      v18 = 0i64;
      JUMPOUT(0x140062663i64);
    }
    sub_140051220(v12);
  }
  return 0;
}
// 14006265F: control flows out of bounds to 140062663

//----- (000000014006281C) ----------------------------------------------------
void __fastcall sub_14006281C(__int64 a1)
{
  __int64 v2; // r8
  _QWORD *v3; // rdx
  void *v4; // rcx
  __int64 v5; // rcx
  void *v6; // rcx
  void *v7; // rcx
  __int64 *v8; // rbx
  __int64 v9; // rcx

  v2 = *(_QWORD *)(a1 + 0x260);
  v3 = *(_QWORD **)(a1 + 0x268);
  if ( *(_QWORD *)(v2 + 8) != a1 + 0x260 || *v3 != a1 + 0x260 )
    __fastfail(3u);
  *v3 = v2;
  *(_QWORD *)(v2 + 8) = v3;
  if ( a1 )
  {
    v4 = *(void **)(a1 + 8);
    if ( v4 )
      ObfDereferenceObject(v4);
    if ( *(_QWORD *)(a1 + 0x48) )
    {
      sub_14000724C(a1 + 0x40);
      JUMPOUT(0x140062878i64);
    }
    v5 = _InterlockedExchange64((volatile __int64 *)(a1 + 0xE8), 0i64);
    if ( v5 )
      sub_140051220(v5);
    v6 = (void *)_InterlockedExchange64((volatile __int64 *)(a1 + 0x200), 0i64);
    if ( v6 )
      sub_14001FBDC(v6);
    v7 = (void *)_InterlockedExchange64((volatile __int64 *)(a1 + 0x208), 0i64);
    if ( v7 )
      sub_14001FBDC(v7);
    v8 = (__int64 *)_InterlockedExchange64((volatile __int64 *)(a1 + 0x210), 0i64);
    if ( v8 )
    {
      if ( *v8 )
        sub_140051220(*v8);
      sub_140051220((__int64)v8);
    }
    v9 = _InterlockedExchange64((volatile __int64 *)(a1 + 0xB0), 0i64);
    if ( v9 )
      sub_140051220(v9);
    if ( *(_QWORD *)(a1 + 0x228) )
    {
      sub_14000724C(a1 + 0x220);
      JUMPOUT(0x140062907i64);
    }
  }
  sub_140051220(a1);
}
// 140062873: control flows out of bounds to 140062878
// 140062902: control flows out of bounds to 140062907

//----- (0000000140062920) ----------------------------------------------------
__int64 *sub_140062920()
{
  __int64 *result; // rax

  result = (__int64 *)(unsigned int)_InterlockedCompareExchange(&dword_1400DB428, 1, 0);
  if ( !(_DWORD)result )
  {
    stru_1400DB2C8.Owner = 0i64;
    stru_1400DB2C8.Contention = 0;
    stru_1400DB2C8.Count = 1;
    KeInitializeEvent(&stru_1400DB2C8.Event, SynchronizationEvent, 0);
    result = &qword_1400DB418;
    qword_1400DB420 = (__int64)&qword_1400DB418;
    qword_1400DB418 = (__int64)&qword_1400DB418;
  }
  return result;
}
// 1400DB418: using guessed type __int64 qword_1400DB418;
// 1400DB420: using guessed type __int64 qword_1400DB420;
// 1400DB428: using guessed type int dword_1400DB428;

//----- (0000000140062BF4) ----------------------------------------------------
__int64 *__fastcall sub_140062BF4(__int64 a1)
{
  __int64 *i; // rax
  __int64 *v3; // rbx

  if ( !dword_1400DB428 || !a1 || KeGetCurrentIrql() > 1u )
    return 0i64;
  ExAcquireFastMutex(&stru_1400DB2C8);
  for ( i = (__int64 *)qword_1400DB418; ; i = (__int64 *)*i )
  {
    if ( i == &qword_1400DB418 )
      goto LABEL_8;
    v3 = i + 0xFFFFFFB4;
    if ( i[0xFFFFFFB6i64] == a1 )
      break;
  }
  if ( i == (__int64 *)0x260 || *((_BYTE *)v3 + 0x25C) )
  {
LABEL_8:
    v3 = 0i64;
    goto LABEL_9;
  }
  ++*((_DWORD *)v3 + 0x96);
LABEL_9:
  ExReleaseFastMutex(&stru_1400DB2C8);
  return v3;
}
// 1400DB418: using guessed type __int64 qword_1400DB418;
// 1400DB428: using guessed type int dword_1400DB428;

//----- (0000000140062C84) ----------------------------------------------------
__int64 *__fastcall sub_140062C84(__int64 a1)
{
  __int64 v1; // rax

  v1 = sub_14004888C(a1);
  return sub_140062BF4(v1);
}

//----- (0000000140062C9C) ----------------------------------------------------
__int64 *__fastcall sub_140062C9C(__int64 a1)
{
  __int64 *v1; // rdi
  __int64 *v3; // rax

  v1 = 0i64;
  if ( !dword_1400DB428 || KeGetCurrentIrql() > 1u )
    return 0i64;
  ExAcquireFastMutex(&stru_1400DB2C8);
  if ( a1 )
    v3 = *(__int64 **)(a1 + 0x260);
  else
    v3 = (__int64 *)qword_1400DB418;
  while ( v3 != &qword_1400DB418 )
  {
    if ( !*((_BYTE *)v3 + 0xFFFFFFFC) )
    {
      ++*((_DWORD *)v3 + 0xFFFFFFFE);
      v1 = v3 + 0xFFFFFFB4;
      break;
    }
    v3 = (__int64 *)*v3;
  }
  ExReleaseFastMutex(&stru_1400DB2C8);
  if ( a1 )
    sub_140062D30(a1);
  return v1;
}
// 1400DB418: using guessed type __int64 qword_1400DB418;
// 1400DB428: using guessed type int dword_1400DB428;

//----- (0000000140062D30) ----------------------------------------------------
void __fastcall sub_140062D30(__int64 a1)
{
  __int64 v2; // rdx
  __int64 *i; // rax
  __int64 v4; // rcx
  int v5; // eax
  bool v6; // zf

  if ( dword_1400DB428 && a1 && KeGetCurrentIrql() <= 1u )
  {
    ExAcquireFastMutex(&stru_1400DB2C8);
    v2 = *(_QWORD *)(a1 + 0x10);
    if ( v2 )
    {
      for ( i = (__int64 *)qword_1400DB418; i != &qword_1400DB418; i = (__int64 *)*i )
      {
        v4 = (__int64)(i + 0xFFFFFFB4);
        if ( i[0xFFFFFFB6i64] == v2 )
        {
          if ( i != (__int64 *)0x260 )
          {
            v5 = *(_DWORD *)(v4 + 0x258) - 1;
            v6 = *(_BYTE *)(v4 + 0x25C) == 0;
            *(_DWORD *)(v4 + 0x258) = v5;
            if ( !v6 && !v5 )
              sub_14006281C(v4);
          }
          break;
        }
      }
    }
    ExReleaseFastMutex(&stru_1400DB2C8);
  }
}
// 1400DB418: using guessed type __int64 qword_1400DB418;
// 1400DB428: using guessed type int dword_1400DB428;

//----- (0000000140062DC8) ----------------------------------------------------
void sub_140062DC8()
{
  unsigned int v0; // edx
  __int64 i; // rbx
  __int64 v2; // rcx

  if ( KeGetCurrentIrql() <= 1u )
  {
    ExAcquireFastMutex(&stru_1400D8270);
    if ( byte_1400DB438 )
    {
      v0 = dword_1400DB42C;
      for ( i = 0i64; (unsigned int)i < v0; i = (unsigned int)(i + 1) )
      {
        v2 = *(_QWORD *)(qword_1400DB430 + 0x18 * i + 0x10);
        if ( v2 )
        {
          sub_140051220(v2);
          v0 = dword_1400DB42C;
        }
      }
      sub_140051220(qword_1400DB430);
      qword_1400DB430 = 0i64;
      byte_1400DB438 = 0;
    }
    byte_1400DB439 = 1;
    ExReleaseFastMutex(&stru_1400D8270);
  }
}
// 1400DB42C: using guessed type int dword_1400DB42C;
// 1400DB430: using guessed type __int64 qword_1400DB430;
// 1400DB438: using guessed type char byte_1400DB438;
// 1400DB439: using guessed type char byte_1400DB439;

//----- (0000000140062E54) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void __fastcall sub_140062E54(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, int a9, int a10, __int64 a11)
{
  __int64 v11[4]; // [rsp+8h] [rbp-20h] BYREF

  if ( a1 )
  {
    if ( sub_14005240C(a1, 0x1000ui64, 0i64, v11) )
      JUMPOUT(0x140062E87i64);
  }
  JUMPOUT(0x140062E8Ci64);
}
// 140062E9B: positive sp value 28 has been found
// 140062E85: control flows out of bounds to 140062E87
// 140062E8A: control flows out of bounds to 140062E8C

//----- (0000000140062E9C) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_140062E9C()
{
  JUMPOUT(0x140062EC5i64);
}
// 1400630C6: positive sp value 20 has been found
// 140062EC3: control flows out of bounds to 140062EC5

//----- (00000001400630C8) ----------------------------------------------------
// positive sp value has been detected, the output may be wrong!
void sub_1400630C8()
{
  JUMPOUT(0x14006310Fi64);
}
// 14006320A: positive sp value 10 has been found
// 14006310B: control flows out of bounds to 14006310F

//----- (000000014006320C) ----------------------------------------------------
__int64 __fastcall sub_14006320C(unsigned __int64 a1, unsigned __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, _DWORD *a9)
{
  unsigned int v13; // esi
  unsigned __int64 v14; // rcx
  __int64 v15; // rcx
  __int64 v16; // rax
  void *v17; // rax
  int v18; // esi
  unsigned __int64 v19; // rdi
  _DWORD *v20; // rcx
  __int64 v21; // rax
  __int64 v22; // rbx
  __int64 v23; // rcx
  char v24; // al

  v13 = 0xC0000229;
  if ( !KeGetCurrentIrql() )
  {
    if ( a1 )
    {
      if ( a2 )
      {
        if ( a3 )
        {
          v14 = *(_QWORD *)(a3 + 0x10);
          if ( v14 )
          {
            if ( *(_DWORD *)(a3 + 0x18)
              && v14 >= (unsigned __int64)MmSystemRangeStart
              && a4
              && a9
              && sub_14000D7DC(a3, a1)
              && sub_14000D7DC(v15, a1 + a2) )
            {
              *a4 = 0i64;
              *a9 = 0;
              v16 = sub_140051084(8 * (a2 >> 0xC) + 8);
              *a4 = v16;
              if ( v16 )
              {
                if ( KeGetCurrentIrql() <= 1u )
                {
                  ExAcquireFastMutex(&stru_1400D8270);
                  if ( !byte_1400DB438 && !byte_1400DB439 )
                  {
                    v17 = (void *)sub_140051084(0x6000ui64);
                    qword_1400DB430 = (__int64)v17;
                    if ( v17 )
                    {
                      byte_1400DB438 = 1;
                      memset(v17, 0, 0x6000ui64);
                    }
                  }
                  ExReleaseFastMutex(&stru_1400D8270);
                  if ( byte_1400DB438 )
                  {
                    v18 = sub_14000512C((_BYTE *)(a3 + 0x28), 0x100u, 0);
                    ExAcquireFastMutex(&stru_1400D8270);
                    if ( byte_1400DB438 )
                    {
                      v19 = 0i64;
                      if ( dword_1400DB42C )
                      {
                        v20 = (_DWORD *)(qword_1400DB430 + 4);
                        while ( *v20 != v18 )
                        {
                          ++v19;
                          v20 += 6;
                          if ( v19 >= (unsigned int)dword_1400DB42C )
                            goto LABEL_27;
                        }
                        if ( sub_140051084(0x18ui64) )
                          JUMPOUT(0x1400633DCi64);
                      }
                    }
LABEL_27:
                    ExReleaseFastMutex(&stru_1400D8270);
                    sub_140062E9C();
                    v22 = v21;
                    if ( v21 )
                    {
                      ExAcquireFastMutex(&stru_1400D8270);
                      if ( byte_1400DB438 && (unsigned int)dword_1400DB42C < 0x400 )
                        JUMPOUT(0x1400634ACi64);
                      ExReleaseFastMutex(&stru_1400D8270);
                      sub_1400630C8();
                      v23 = *(_QWORD *)(v22 + 0x10);
                      v13 = v24 == 0 ? 0xC0000005 : 0;
                      if ( v23 )
                        sub_140051220(v23);
                      sub_140051220(v22);
                      if ( (int)v13 >= 0 && *a9 )
                        return v13;
                    }
                    else
                    {
                      v13 = 0xC0000123;
                    }
                  }
                }
                sub_140051220(*a4);
              }
              return v13;
            }
          }
        }
      }
    }
  }
  return 0xC000000Di64;
}
// 1400633D8: control flows out of bounds to 1400633DC
// 1400634A8: control flows out of bounds to 1400634AC
// 14006345A: conditional instruction was optimized away because of 'rbx.8==0'
// 1400632BB: variable 'v15' is possibly undefined
// 14006346A: variable 'v21' is possibly undefined
// 140063561: variable 'v24' is possibly undefined
// 1400DB42C: using guessed type int dword_1400DB42C;
// 1400DB430: using guessed type __int64 qword_1400DB430;
// 1400DB438: using guessed type char byte_1400DB438;
// 1400DB439: using guessed type char byte_1400DB439;

//----- (0000000140064F8C) ----------------------------------------------------
char __fastcall sub_140064F8C(__int64 a1, __int64 a2, __int64 a3, __int64 a4, PVOID Object, __int64 a6)
{
  bool v6; // bl

  a6 = a2;
  if ( !a1 || !a2 || (int)sub_1400488FC(a1, (__int64)&Object) < 0 )
    return 1;
  if ( (unsigned int)sub_140013EF0((__int64)Object) == 0x40 && MEMORY[0xFFFFF7800000026C] >= 0xAu )
    v6 = ((__int64 (__fastcall *)(PVOID, __int64, __int64 *, __int64))loc_140015908)(Object, 0x340i64, &a6, 8i64) != 0;
  else
    v6 = 1;
  ObfDereferenceObject(Object);
  return v6;
}

//----- (0000000140065008) ----------------------------------------------------
__int64 sub_140065008()
{
  __int64 result; // rax
  unsigned __int64 v1; // rax
  _BYTE *v2; // rbx
  unsigned __int64 v3; // rdi
  int v4[6]; // [rsp+20h] [rbp-40h] BYREF
  unsigned __int8 v5; // [rsp+38h] [rbp-28h]
  int v6; // [rsp+59h] [rbp-7h]

  result = (unsigned int)dword_1400D8078;
  if ( dword_1400D8078 == 0xFFFFFFFF )
  {
    v4[0] = 0x520B6747;
    v4[1] = 0x1D1A19B5;
    v4[2] = 0x46DD7368;
    v4[3] = 0xF441935F;
    v4[4] = 0x4FDA464C;
    v1 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v4);
    v2 = (_BYTE *)v1;
    if ( v1 )
    {
      v3 = v1 + 0x18;
      if ( v1 < v1 + 0x18 )
      {
        do
        {
          sub_14001B640();
          if ( (v6 & 0x1000) != 0 )
            break;
          if ( *v2 == 0xC3 )
            break;
          v2 += v5;
        }
        while ( (unsigned __int64)v2 < v3 );
      }
    }
    JUMPOUT(0x140065099i64);
  }
  return result;
}
// 140065096: control flows out of bounds to 140065099
// 1400D8078: using guessed type int dword_1400D8078;

//----- (00000001400650C0) ----------------------------------------------------
__int64 sub_1400650C0()
{
  __int64 result; // rax
  __int64 v1; // rcx
  int v2[8]; // [rsp+20h] [rbp-20h] BYREF

  result = (unsigned int)dword_1400D8070;
  if ( dword_1400D8070 == 0xFFFFFFFF )
  {
    v2[0] = 0xD44FE712;
    v2[1] = 0x2A9A21AE;
    v2[2] = 0x116F34C2;
    v2[3] = 0xE520CDA;
    v2[4] = 0xBE64AD2D;
    v1 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v2);
    result = 0i64;
    if ( v1 && *(_BYTE *)v1 == 0x48 && *(_WORD *)(v1 + 1) == 0x818B )
      result = *(unsigned int *)(v1 + 3);
    dword_1400D8070 = result;
  }
  return result;
}
// 1400D8070: using guessed type int dword_1400D8070;

//----- (000000014006512C) ----------------------------------------------------
__int64 sub_14006512C()
{
  __int64 result; // rax
  __int64 v1; // rcx
  int v2[8]; // [rsp+20h] [rbp-20h] BYREF

  result = (unsigned int)dword_1400D8074;
  if ( dword_1400D8074 == 0xFFFFFFFF )
  {
    v2[0] = 0xF7CD4C3;
    v2[1] = 0x6FCB157E;
    v2[2] = 0x34BD22EF;
    v2[3] = 0xD076D76B;
    v2[4] = 0x41E55CBA;
    v1 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v2);
    result = 0i64;
    if ( v1 && *(_BYTE *)v1 == 0x48 && *(_WORD *)(v1 + 1) == 0x818B )
      result = *(unsigned int *)(v1 + 3);
    dword_1400D8074 = result;
  }
  return result;
}
// 1400D8074: using guessed type int dword_1400D8074;

//----- (0000000140065198) ----------------------------------------------------
__int64 sub_140065198()
{
  int v0; // eax
  __int64 v1; // rax
  __int64 v2; // rbx
  unsigned __int64 v3; // rdi
  unsigned int v4; // eax
  unsigned __int64 i; // rbx
  int v6; // ecx
  unsigned int v7; // eax
  unsigned int v8; // eax
  int v10[6]; // [rsp+20h] [rbp-40h] BYREF
  char v11; // [rsp+43h] [rbp-1Dh]
  char v12; // [rsp+47h] [rbp-19h]
  char v13; // [rsp+4Dh] [rbp-13h]
  unsigned int v14; // [rsp+55h] [rbp-Bh]
  int v15; // [rsp+59h] [rbp-7h]

  if ( (unsigned int)sub_14002C3E0(&qword_1400DB5B0) == 0x103 )
  {
    if ( MEMORY[0xFFFFF7800000026C] == 6 && MEMORY[0xFFFFF78000000270] == 1 )
    {
      v0 = 0x164;
      dword_1400DB5A8 = 0x164;
    }
    else
    {
      v10[0] = 0x7000BEEF;
      v10[1] = 0x25123E7F;
      v10[2] = 0x22B429D5;
      v10[3] = 0xBF88B408;
      v10[4] = 0x2CE7F7DE;
      v1 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v10);
      v2 = v1;
      if ( v1 )
      {
        v3 = v1 + 0x132;
        sub_14001B640();
        for ( i = v4 + v2; i < v3; i += v8 )
        {
          v6 = v15;
          if ( _bittest(&v6, 0xCu) || ((v11 + 0x3E) & 0xF6) == 0 )
            break;
          if ( (v15 & 1) != 0 && _bittest(&v6, 8u) && v11 == (char)0x8A && !v12 && v14 < 0x300 )
          {
            dword_1400DB5A8 = v14;
            sub_14001B640();
            i += v7;
            if ( (v15 & 0x1000) == 0 && (v15 & 4) != 0 && v11 == 0x3C && v13 == 5 )
              break;
            dword_1400DB5A8 = 0;
          }
          sub_14001B640();
        }
      }
      v0 = dword_1400DB5A8;
    }
    if ( v0 )
      JUMPOUT(0x1400652F2i64);
    _InterlockedExchange64(&qword_1400DB5B0, 2i64);
  }
  return (unsigned int)dword_1400DB5A8;
}
// 1400652EE: control flows out of bounds to 1400652F2
// 140065241: variable 'v4' is possibly undefined
// 14006528D: variable 'v7' is possibly undefined
// 1400652BF: variable 'v8' is possibly undefined
// 1400DB5A8: using guessed type int dword_1400DB5A8;
// 1400DB5B0: using guessed type __int64 qword_1400DB5B0;

//----- (0000000140065320) ----------------------------------------------------
__int64 sub_140065320()
{
  struct _KTHREAD *v0; // rbx
  __int64 (*v1)(void); // rax
  __int64 v2; // rax
  struct _KTHREAD *v3; // rcx
  int v5[8]; // [rsp+20h] [rbp-20h] BYREF

  v0 = KeGetCurrentThread();
  if ( (unsigned int)sub_14002C3E0(&qword_1400DB5C0) == 0x103 )
  {
    v1 = (__int64 (*)(void))qword_1400DB5B8;
    if ( qword_1400DB5B8
      || (v5[0] = 0x22E9595B,
          v5[1] = 0x6F66127,
          v5[2] = 0x5FE4FF40,
          v5[3] = 0xC2ECB75C,
          v5[4] = 0x1A672C7F,
          v1 = (__int64 (*)(void))((__int64 (__fastcall *)(int *))loc_1400061CC)(v5),
          (qword_1400DB5B8 = (__int64)v1) != 0) )
    {
      v2 = v1();
      v3 = v0;
      if ( v0 < (struct _KTHREAD *)((char *)v0 + 0x2F8) )
      {
        while ( *(_QWORD *)v3 != v2 )
        {
          v3 = (struct _KTHREAD *)((char *)v3 + 8);
          if ( v3 >= (struct _KTHREAD *)((char *)v0 + 0x2F8) )
            goto LABEL_9;
        }
        dword_1400DB598 = (_DWORD)v3 - (_DWORD)v0;
      }
    }
LABEL_9:
    _InterlockedExchange64(&qword_1400DB5C0, 2i64);
  }
  return (unsigned int)dword_1400DB598;
}
// 1400DB598: using guessed type int dword_1400DB598;
// 1400DB5B8: using guessed type __int64 qword_1400DB5B8;
// 1400DB5C0: using guessed type __int64 qword_1400DB5C0;

//----- (00000001400653D4) ----------------------------------------------------
__int64 sub_1400653D4()
{
  struct _KTHREAD *v0; // rbx
  __int64 (*v1)(void); // rax
  __int64 v2; // rax
  struct _KTHREAD *v3; // rcx
  int v5[8]; // [rsp+20h] [rbp-20h] BYREF

  v0 = KeGetCurrentThread();
  if ( (unsigned int)sub_14002C3E0(&qword_1400DB590) == 0x103 )
  {
    v1 = (__int64 (*)(void))qword_1400DB5A0;
    if ( qword_1400DB5A0
      || (v5[0] = 0xCEA456B3,
          v5[1] = 0xE8B7B5AD,
          v5[2] = 0xD2981E65,
          v5[3] = 0x6CF036AD,
          v5[4] = 0xD2DF0EC7,
          v1 = (__int64 (*)(void))((__int64 (__fastcall *)(int *))loc_1400061CC)(v5),
          (qword_1400DB5A0 = (__int64)v1) != 0) )
    {
      v2 = v1();
      v3 = v0;
      if ( v0 < (struct _KTHREAD *)((char *)v0 + 0x2F8) )
      {
        while ( *(_QWORD *)v3 != v2 )
        {
          v3 = (struct _KTHREAD *)((char *)v3 + 8);
          if ( v3 >= (struct _KTHREAD *)((char *)v0 + 0x2F8) )
            goto LABEL_9;
        }
        dword_1400DB59C = (_DWORD)v3 - (_DWORD)v0;
      }
    }
LABEL_9:
    _InterlockedExchange64(&qword_1400DB590, 2i64);
  }
  return (unsigned int)dword_1400DB59C;
}
// 1400DB590: using guessed type __int64 qword_1400DB590;
// 1400DB59C: using guessed type int dword_1400DB59C;
// 1400DB5A0: using guessed type __int64 qword_1400DB5A0;

//----- (0000000140065488) ----------------------------------------------------
__int64 sub_140065488()
{
  struct _KTHREAD *v0; // rbx
  __int64 (*v1)(void); // rax
  __int64 v2; // rax
  struct _KTHREAD *v3; // rcx
  int v5[8]; // [rsp+20h] [rbp-20h] BYREF

  v0 = KeGetCurrentThread();
  if ( (unsigned int)sub_14002C3E0(&qword_1400DB578) == 0x103 )
  {
    v1 = (__int64 (*)(void))qword_1400DB570;
    if ( qword_1400DB570
      || (v5[0] = 0x11C8C59B,
          v5[1] = 0xE804E6D1,
          v5[2] = 0x8C573B7B,
          v5[3] = 0x452609E6,
          v5[4] = 0x7DA9C4A8,
          v1 = (__int64 (*)(void))((__int64 (__fastcall *)(int *))loc_1400061CC)(v5),
          (qword_1400DB570 = (__int64)v1) != 0) )
    {
      v2 = v1();
      v3 = v0;
      if ( v0 < (struct _KTHREAD *)((char *)v0 + 0x2F8) )
      {
        while ( *(_QWORD *)v3 != v2 )
        {
          v3 = (struct _KTHREAD *)((char *)v3 + 8);
          if ( v3 >= (struct _KTHREAD *)((char *)v0 + 0x2F8) )
            goto LABEL_9;
        }
        dword_1400DB588 = (_DWORD)v3 - (_DWORD)v0;
      }
    }
LABEL_9:
    _InterlockedExchange64(&qword_1400DB578, 2i64);
  }
  return (unsigned int)dword_1400DB588;
}
// 1400DB570: using guessed type __int64 qword_1400DB570;
// 1400DB578: using guessed type __int64 qword_1400DB578;
// 1400DB588: using guessed type int dword_1400DB588;

//----- (000000014006553C) ----------------------------------------------------
#error "1400655E4: call analysis failed (funcsize=80)"

//----- (0000000140065644) ----------------------------------------------------
__int64 sub_140065644()
{
  __int64 v0; // rax
  __int64 v1; // rbx
  unsigned __int64 v2; // rdi
  unsigned int v3; // eax
  unsigned __int64 i; // rbx
  int v5; // eax
  unsigned int v6; // eax
  int v8[6]; // [rsp+20h] [rbp-40h] BYREF
  char v9; // [rsp+3Fh] [rbp-21h]
  char v10; // [rsp+43h] [rbp-1Dh]
  char v11; // [rsp+44h] [rbp-1Ch]
  char v12; // [rsp+4Dh] [rbp-13h]
  unsigned __int8 v13; // [rsp+55h] [rbp-Bh]
  int v14; // [rsp+59h] [rbp-7h]

  if ( (unsigned int)sub_14002C3E0(&qword_1400DB560) == 0x103 )
  {
    v8[0] = 0x1BD40E4;
    v8[1] = 0x7A8B6387;
    v8[2] = 0xE594F314;
    v8[3] = 0x2F522583;
    v8[4] = 0x60B34D67;
    v0 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v8);
    v1 = v0;
    if ( v0 )
    {
      v2 = v0 + 0xF1;
      sub_14001B640();
      for ( i = v3 + v1; i < v2; i += v6 )
      {
        v5 = v14;
        if ( _bittest(&v5, 0xCu) )
          break;
        if ( _bittest(&v5, 0x1Eu)
          && _bittest(&v5, 0x1Cu)
          && (v14 & 1) != 0
          && (v14 & 0x40) != 0
          && (v14 & 4) != 0
          && !v12
          && v9
          && v10 == 0xF
          && v11 == (char)0xBA )
        {
          dword_1400DB56C = v13;
          break;
        }
        sub_14001B640();
      }
    }
    _InterlockedExchange64(&qword_1400DB560, 2i64);
  }
  return (unsigned int)dword_1400DB56C;
}
// 1400656B4: variable 'v3' is possibly undefined
// 140065703: variable 'v6' is possibly undefined
// 1400DB560: using guessed type __int64 qword_1400DB560;
// 1400DB56C: using guessed type int dword_1400DB56C;

//----- (0000000140065738) ----------------------------------------------------
__int64 sub_140065738()
{
  __int64 result; // rax
  __int64 v1; // rax
  __int64 v2; // rdi
  unsigned __int64 i; // rbx
  int v4[6]; // [rsp+28h] [rbp-50h] BYREF
  unsigned __int8 v5; // [rsp+40h] [rbp-38h]
  int v6; // [rsp+61h] [rbp-17h]

  result = (unsigned int)dword_1400D806C;
  if ( dword_1400D806C == 0xFFFFFFFF )
  {
    v4[0] = 0xC7B757C3;
    v4[1] = 0x88488AEC;
    v4[2] = 0x40168536;
    v4[3] = 0x76E29A79;
    v4[4] = 0xAA295B5C;
    v1 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(v4);
    v2 = v1;
    if ( v1 )
    {
      for ( i = v1; ; i += v5 )
      {
        if ( i >= v2 + 0x18 )
          goto LABEL_10;
        sub_14001B640();
        if ( (v6 & 0x1000) != 0 )
          goto LABEL_10;
        if ( ((*(_WORD *)i + 0x7F75) & 0xFEFF) == 0 )
          break;
        if ( *(_BYTE *)i == 0xC2 || *(_BYTE *)i == 0xC3 )
          goto LABEL_10;
      }
      dword_1400D806C = *(_DWORD *)(i + 2);
    }
LABEL_10:
    JUMPOUT(0x1400657F9i64);
  }
  return result;
}
// 1400657F6: control flows out of bounds to 1400657F9
// 1400D806C: using guessed type int dword_1400D806C;

//----- (0000000140065814) ----------------------------------------------------
char __fastcall sub_140065814(__int64 a1)
{
  char v1; // bl
  unsigned int v3; // eax

  v1 = 0;
  if ( a1 )
  {
    v3 = sub_140065738();
    if ( v3 )
    {
      v1 = 1;
      *(_DWORD *)(v3 + a1) |= 4u;
    }
  }
  return v1;
}

//----- (0000000140065848) ----------------------------------------------------
__int64 __fastcall sub_140065848(__int64 a1, _QWORD *a2)
{
  int v3; // ebx

  if ( a1 && a2 )
  {
    *a2 = 0i64;
    v3 = sub_1400384B8(a1, 0x200u, a1, 0x40u);
    if ( v3 >= 0 )
    {
      v3 = sub_140061CE8(0i64, 9u, (__int64)a2, 8u);
      sub_1400612D4(0i64);
    }
  }
  else
  {
    v3 = (a1 != 0) - 0x3FFFFF11;
  }
  return (unsigned int)v3;
}

//----- (00000001400658E0) ----------------------------------------------------
__int64 __fastcall sub_1400658E0(__int64 a1, _QWORD *a2, __int64 a3, __int64 a4, PVOID Object, __int64 a6, unsigned __int64 a7)
{
  int v8; // ebx
  __int64 v9; // r8
  PVOID v10; // rcx

  Object = 0i64;
  if ( a1 && a2 )
  {
    v8 = sub_1400489AC(a1, (__int64)&Object);
    if ( v8 >= 0 )
    {
      a7 = 0i64;
      v10 = Object;
      if ( Object && a2 )
      {
        *a2 = 0i64;
        v8 = sub_1400384B8((__int64)v10, 0x200u, v9, 0x40u);
        if ( v8 >= 0 )
        {
          v8 = sub_140061CE8(a7, 9u, (__int64)a2, 8u);
          sub_1400612D4(a7);
        }
        v10 = Object;
      }
      else
      {
        v8 = (Object != 0i64) - 0x3FFFFF11;
      }
      ObfDereferenceObject(v10);
    }
  }
  else
  {
    v8 = (a1 != 0) - 0x3FFFFF11;
  }
  return (unsigned int)v8;
}
// 14006595B: variable 'v9' is possibly undefined

//----- (0000000140065A68) ----------------------------------------------------
__int64 __fastcall sub_140065A68(__int64 a1)
{
  __int64 v2; // rdx
  __int64 result; // rax

  v2 = (unsigned int)sub_1400650C0();
  result = 0i64;
  if ( a1 )
  {
    if ( (_DWORD)v2 )
      result = *(_QWORD *)(v2 + a1);
  }
  return result;
}

//----- (0000000140065A90) ----------------------------------------------------
__int64 __fastcall sub_140065A90(__int64 a1)
{
  __int64 v2; // rdx
  __int64 result; // rax

  v2 = (unsigned int)sub_14006512C();
  result = 0i64;
  if ( a1 )
  {
    if ( (_DWORD)v2 )
      result = *(_QWORD *)(v2 + a1);
  }
  return result;
}

//----- (0000000140065AB8) ----------------------------------------------------
char __fastcall sub_140065AB8(__int64 a1, char a2)
{
  unsigned int v4; // eax

  v4 = sub_140065008();
  if ( !a1 || !v4 )
    return 0;
  *(_BYTE *)(v4 + a1) = a2;
  return 1;
}

//----- (0000000140065AF0) ----------------------------------------------------
void __fastcall sub_140065AF0(__int64 a1, __int64 a2)
{
  unsigned __int64 v3; // rbx
  unsigned int v4; // eax
  KSPIN_LOCK *v5; // rcx
  void (__fastcall *v6)(_QWORD, __int64); // rax
  int v7[8]; // [rsp+20h] [rbp-20h] BYREF

  v3 = (unsigned __int8)a2;
  if ( MEMORY[0xFFFFF7800000026C] < 6u || MEMORY[0xFFFFF7800000026C] == 6 && !MEMORY[0xFFFFF78000000270] )
  {
    v6 = (void (__fastcall *)(_QWORD, __int64))qword_1400DADF0;
    if ( qword_1400DADF0
      || (v7[0] = 0x130966FE,
          v7[1] = 0x31680111,
          v7[2] = 0x4AA754F,
          v7[3] = 0x8C34956F,
          v7[4] = 0x8EA948D,
          v6 = (void (__fastcall *)(_QWORD, __int64))((__int64 (__fastcall *)(int *))loc_1400061CC)(v7),
          (qword_1400DADF0 = (__int64)v6) != 0) )
    {
      LOBYTE(a2) = v3;
      v6(0i64, a2);
    }
  }
  else
  {
    v4 = sub_140065644();
    if ( a1 )
    {
      v5 = (KSPIN_LOCK *)((a1 + v4) & -(__int64)(v4 != 0));
      if ( v5 )
      {
        KeReleaseSpinLockFromDpcLevel(v5);
        __writecr8(v3);
      }
    }
  }
}
// 140065B94: variable 'a2' is possibly undefined
// 1400DADF0: using guessed type __int64 qword_1400DADF0;

//----- (0000000140065BA8) ----------------------------------------------------
__int64 __fastcall sub_140065BA8(PETHREAD Thread, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  __int64 v8; // r14
  __int64 v9; // r15
  unsigned int v10; // eax
  unsigned __int64 v12; // rsi
  unsigned int v13; // eax
  unsigned __int64 v14; // rbp
  __int64 v15; // r12
  unsigned int v16; // eax
  KSPIN_LOCK *v17; // rcx
  unsigned __int8 v18; // r14
  __int64 v19; // rdx
  void *v20; // rcx

  a6 = a2;
  v8 = (unsigned int)sub_140065198();
  v9 = (unsigned int)sub_14006553C();
  v10 = sub_140065488();
  if ( !Thread )
  {
    sub_1400653D4();
    return 0i64;
  }
  if ( v10 )
    v12 = *(_QWORD *)((char *)Thread + v10);
  else
    v12 = 0i64;
  v13 = sub_1400653D4();
  if ( v13 )
    v14 = *(_QWORD *)((char *)Thread + v13);
  else
    v14 = 0i64;
  if ( !(unsigned __int8)sub_140048A9C((__int64)Thread)
    || !a3
    || !(_DWORD)v8
    || !(_DWORD)v9
    || !v12
    || !v14
    || KeGetCurrentIrql() > 1u
    || Thread == KeGetCurrentThread() )
  {
    return 0i64;
  }
  v15 = v8;
  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a3, 0i64, 0x2000i64);
  if ( MEMORY[0xFFFFF7800000026C] < 6u || MEMORY[0xFFFFF7800000026C] == 6 && !MEMORY[0xFFFFF78000000270] )
  {
    if ( sub_140046390(&a6) )
    {
      v18 = a6;
LABEL_25:
      if ( !PsIsThreadTerminating(Thread) && *((_BYTE *)Thread + v15) == 5 )
      {
        v20 = *(void **)((char *)Thread + v9);
        if ( (unsigned __int64)v20 > v14 && (unsigned __int64)v20 < v12 )
        {
          if ( MmGetPhysicalAddress(v20) )
            JUMPOUT(0x140065D1Ei64);
        }
      }
      LOBYTE(v19) = v18;
      sub_140065AF0((__int64)Thread, v19);
      return 0i64;
    }
  }
  else
  {
    v16 = sub_140065644();
    v17 = (KSPIN_LOCK *)(((unsigned __int64)Thread + v16) & -(__int64)(v16 != 0));
    if ( v17 )
    {
      v18 = KeGetCurrentIrql();
      __writecr8(0xCui64);
      KeAcquireSpinLockAtDpcLevel(v17);
      goto LABEL_25;
    }
  }
  return 0i64;
}
// 140065D1B: control flows out of bounds to 140065D1E
// 140065D30: variable 'v19' is possibly undefined
// 14006553C: using guessed type __int64 sub_14006553C(void);

//----- (00000001400672C0) ----------------------------------------------------
void **__fastcall sub_1400672C0(ULONG64 a1)
{
  void **result; // rax
  int v3; // er14
  void *retaddr; // [rsp+78h] [rbp+0h] BYREF

  result = &retaddr;
  if ( a1 )
  {
    result = (void **)sub_140052894(a1);
    v3 = (int)result;
    if ( (_DWORD)result )
    {
      if ( sub_140052944(a1) )
      {
        if ( v3 == 0x40 )
          JUMPOUT(0x14006735Bi64);
        JUMPOUT(0x140067379i64);
      }
      JUMPOUT(0x1400673E6i64);
    }
  }
  return result;
}
// 140067359: control flows out of bounds to 14006735B
// 140067377: control flows out of bounds to 140067379
// 1400673E2: control flows out of bounds to 1400673E6

//----- (00000001400674E4) ----------------------------------------------------
void **__fastcall sub_1400674E4(ULONG64 a1)
{
  return sub_1400672C0(a1);
}

//----- (00000001400674EC) ----------------------------------------------------
#error "140067514: call analysis failed (funcsize=15)"

//----- (0000000140067520) ----------------------------------------------------
char __fastcall sub_140067520(__int64 a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, PVOID Object)
{
  char *v7; // rsi
  int v8; // eax
  __int64 v9; // rsi
  __int64 v10; // rax
  int v12[12]; // [rsp+38h] [rbp-C0h] BYREF
  char v13[22]; // [rsp+7Ah] [rbp-7Eh] BYREF
  char v14[104]; // [rsp+90h] [rbp-68h] BYREF

  if ( a1 && (int)sub_1400489AC(a1, (__int64)&Object) >= 0 )
  {
    v7 = (char *)Object;
    v8 = sub_1400650C0();
    if ( v7 && v8 )
      v9 = *(_QWORD *)&v7[v8];
    else
      v9 = 0i64;
    if ( v9 && (unsigned int)sub_140013EF0(v9) && sub_140015378(v9, (__int64)v14) )
    {
      v12[0] = 0xC39C992;
      v12[1] = 0xFE5A28EE;
      v12[2] = 0xAFF73E0;
      v12[3] = 0x87E2421E;
      v12[4] = 0xC786FA70;
      v10 = ((__int64 (__fastcall *)(int *, char *))loc_140067764)(v12, v13);
      if ( sub_140052728(v10) )
        JUMPOUT(0x14006763Di64);
      memset(v13, 0, 0x14ui64);
      ((void (__fastcall *)(__int64, char *))loc_140015528)(v9, v14);
    }
    ObfDereferenceObject(Object);
  }
  return 0;
}
// 14006763B: control flows out of bounds to 14006763D

//----- (00000001400685D4) ----------------------------------------------------
char __fastcall sub_1400685D4(PETHREAD Thread, __int64 a2, unsigned int *a3, __int64 a4, unsigned __int64 a5, __int64 a6, __int64 a7, __int64 a8)
{
  char v8; // si
  __int64 v12; // rax
  __int64 v13; // rdx
  __int64 v14; // r9
  __int64 v15; // rdi
  unsigned __int64 v16; // rax
  __int64 v17; // r9
  unsigned __int64 v18; // rdx
  unsigned int i; // er15
  unsigned __int64 v20; // rcx
  __int64 v21; // rax
  __int64 v23; // [rsp+20h] [rbp-50h]
  __int64 v24; // [rsp+28h] [rbp-48h]
  __int64 v25; // [rsp+40h] [rbp-30h] BYREF
  int v26; // [rsp+58h] [rbp-18h] BYREF
  int v27; // [rsp+5Ch] [rbp-14h]
  int v28; // [rsp+60h] [rbp-10h]
  int v29; // [rsp+64h] [rbp-Ch]
  int v30; // [rsp+68h] [rbp-8h]

  v8 = 0;
  if ( !Thread )
    return 0;
  if ( !a3 )
    return 0;
  ((void (__fastcall *)(__int64, _QWORD, __int64))loc_14006F2C0)(a2, 0i64, 0x4D0i64);
  ((void (__fastcall *)(unsigned int *, _QWORD, __int64))loc_14006F2C0)(a3, 0i64, 0x208i64);
  if ( !qword_1400DB448 )
  {
    v26 = 0xF35E042B;
    v27 = 0x9300E8D7;
    v28 = 0x91DA3EE5;
    v29 = 0x34E9AF5F;
    v30 = 0x31CF0D71;
    qword_1400DB448 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD, _QWORD))((__int64 (__fastcall *)(int *))loc_1400061CC)(&v26);
    if ( !qword_1400DB448 )
      return 0;
  }
  if ( !qword_1400DB440 )
  {
    v26 = 0x79ADFB62;
    v27 = 0xEE1D9CA3;
    v28 = 0x68520599;
    v29 = 0x96B26451;
    v30 = 0x8C0CFA2F;
    qword_1400DB440 = (__int64 (__fastcall *)(_QWORD, _QWORD, _QWORD))((__int64 (__fastcall *)(int *))loc_1400061CC)(&v26);
    if ( !qword_1400DB440 )
      return 0;
  }
  v12 = sub_140051084(0x2000ui64);
  v15 = v12;
  if ( v12 )
  {
    v16 = sub_140065BA8(Thread, v13, v12, v14, v23, v24);
    if ( v16 > 0x47 && v16 != 0x2000 )
    {
      if ( sub_14000A70C(0x747865742Ei64, &a5, &a8, v17) )
      {
        v18 = *(_QWORD *)(v15 + 0x38);
        if ( v18 >= a5 && v18 < a8 + a5 )
        {
          *(_QWORD *)(a2 + 0xF8) = v18;
          *(_QWORD *)(a2 + 0x98) = v15 + 0x40;
          v8 = 1;
          for ( i = 0; i < 0x20; ++i )
          {
            *(_QWORD *)&a3[4 * *a3 + 2] = v18;
            *(_QWORD *)&a3[4 * ++*a3] = *(_QWORD *)(a2 + 0x98);
            v20 = *(_QWORD *)(a2 + 0xF8);
            if ( v20 < (unsigned __int64)MmSystemRangeStart )
              break;
            if ( *(_QWORD *)(a2 + 0x98) < (unsigned __int64)MmSystemRangeStart )
              break;
            v21 = qword_1400DB440(v20, &v25, 0i64);
            if ( !v21 )
              break;
            qword_1400DB448(0i64, v25, *(_QWORD *)(a2 + 0xF8), v21);
            v18 = *(_QWORD *)(a2 + 0xF8);
            if ( !v18 )
            {
              *((_BYTE *)a3 + 4) = 1;
              break;
            }
          }
        }
      }
    }
    sub_140051220(v15);
  }
  return v8;
}
// 1400686CD: variable 'v13' is possibly undefined
// 1400686CD: variable 'v14' is possibly undefined
// 1400686CD: variable 'v23' is possibly undefined
// 1400686CD: variable 'v24' is possibly undefined
// 1400686FA: variable 'v17' is possibly undefined
// 1400DB440: using guessed type __int64 (__fastcall *qword_1400DB440)(_QWORD, _QWORD, _QWORD);
// 1400DB448: using guessed type __int64 (__fastcall *qword_1400DB448)(_QWORD, _QWORD, _QWORD, _QWORD);

//----- (0000000140069460) ----------------------------------------------------
__int64 sub_140069460()
{
  char v1[24]; // [rsp+30h] [rbp-40h] BYREF
  __int64 v2; // [rsp+48h] [rbp-28h]

  if ( !qword_1400DB5D0 )
  {
    ((void (__fastcall *)(char *, char *))loc_140007050)(v1, byte_14006F980);
    v2 = 0i64;
    JUMPOUT(0x140069496i64);
  }
  return qword_1400DB5D0;
}
// 140069492: control flows out of bounds to 140069496
// 1400DB5D0: using guessed type __int64 qword_1400DB5D0;

//----- (0000000140069584) ----------------------------------------------------
__int64 sub_140069584()
{
  __int64 *v0; // rax
  __int64 v1; // rbx
  int v3[8]; // [rsp+20h] [rbp-20h] BYREF

  v0 = (__int64 *)qword_1400DB5C8;
  v1 = 0i64;
  if ( qword_1400DB5C8
    || (v3[0] = 0xEB1B18F8,
        v3[1] = 0x99249837,
        v3[2] = 0x8E089F7,
        v3[3] = 0x441AE5ED,
        v3[4] = 0x8237C780,
        v0 = (__int64 *)((__int64 (__fastcall *)(int *))loc_1400061CC)(v3),
        (qword_1400DB5C8 = (__int64)v0) != 0) )
  {
    v1 = *v0;
  }
  return v1;
}
// 1400DB5C8: using guessed type __int64 qword_1400DB5C8;

//----- (0000000140069674) ----------------------------------------------------
char sub_140069674()
{
  __int64 v0; // rax
  char v1; // bl
  __int64 v2; // rcx
  int v4; // [rsp+20h] [rbp-20h] BYREF
  int v5; // [rsp+24h] [rbp-1Ch]
  int v6; // [rsp+28h] [rbp-18h]
  int v7; // [rsp+2Ch] [rbp-14h]
  int v8; // [rsp+30h] [rbp-10h]

  v0 = qword_1400DB4A0;
  v1 = 0;
  if ( !qword_1400DB4A0 )
  {
    v4 = 0xA1E8465B;
    v5 = 0xFE0B72E4;
    v6 = 0x7DA7594F;
    v7 = 0xCB27EDEB;
    v8 = 0x328CC076;
    v0 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(&v4);
    qword_1400DB4A0 = v0;
  }
  v2 = qword_1400DB4A8;
  if ( !qword_1400DB4A8 )
  {
    v4 = 0x85FCF6A4;
    v5 = 0x2FC40427;
    v6 = 0x577EFB59;
    v7 = 0x8A095855;
    v8 = 0xA5A76FB0;
    v2 = ((__int64 (__fastcall *)(int *))loc_1400061CC)(&v4);
    qword_1400DB4A8 = v2;
    v0 = qword_1400DB4A0;
  }
  if ( v0 && v2 )
    v1 = 1;
  return v1;
}
// 1400DB4A0: using guessed type __int64 qword_1400DB4A0;
// 1400DB4A8: using guessed type __int64 qword_1400DB4A8;

//----- (0000000140069C08) ----------------------------------------------------
char __fastcall sub_140069C08(__int64 a1)
{
  char v1; // bl
  __int64 *i; // rax

  v1 = 0;
  if ( !byte_1400DB43A || KeGetCurrentIrql() > 1u )
    return 0;
  ExAcquireFastMutex(&stru_1400DB468);
  for ( i = (__int64 *)qword_1400DB458; i != &qword_1400DB458; i = (__int64 *)*i )
  {
    if ( i[5] == a1 )
    {
      v1 = 1;
      break;
    }
  }
  ExReleaseFastMutex(&stru_1400DB468);
  return v1;
}
// 1400DB43A: using guessed type char byte_1400DB43A;
// 1400DB458: using guessed type __int64 qword_1400DB458;

//----- (0000000140069C74) ----------------------------------------------------
unsigned __int64 __fastcall sub_140069C74(unsigned __int64 a1, __int64 a2, unsigned int a3)
{
  unsigned __int64 v4; // rbx
  unsigned __int64 v7; // rsi
  __int64 v8; // rdx
  __int64 v9; // rdx
  unsigned __int64 v10; // rbx
  unsigned __int64 v11; // rsi
  __int64 v12; // rdx
  unsigned __int64 v13; // rsi
  unsigned __int64 v14; // rbx
  unsigned __int64 v15; // rbx

  v4 = a1;
  if ( a3 < 8 )
    return 0i64;
  if ( a1 && a2 )
  {
    v7 = 0i64;
    v8 = a2 + 8;
    if ( v8 )
    {
      do
      {
        if ( !*(_BYTE *)(v7 + v8) )
          break;
        ++v7;
      }
      while ( v7 < 0xFF );
    }
    ((void (__fastcall *)(unsigned __int64, __int64, unsigned __int64))loc_14006F000)(a1, v8, v7);
    v9 = a2 + 0x140;
    v10 = v7 + v4;
    v11 = 0i64;
    *(_BYTE *)(v10 + 1) = *(_BYTE *)(a2 + 0x108);
    *(_DWORD *)(v10 + 2) = *(_DWORD *)(a2 + 0x10C);
    *(_DWORD *)(v10 + 6) = *(_DWORD *)(a2 + 0x110);
    *(_DWORD *)(v10 + 0xA) = *(_DWORD *)(a2 + 0x114);
    *(_BYTE *)(v10 + 0xE) = *(_BYTE *)a2;
    *(_BYTE *)(v10 + 0xF) = *(_BYTE *)(a2 + 1);
    if ( a2 != 0xFFFFFFFFFFFFFEC0ui64 )
    {
      do
      {
        if ( !*(_BYTE *)(v9 + v11) )
          break;
        ++v11;
      }
      while ( v11 < 0xFF );
    }
    ((void (__fastcall *)(unsigned __int64, __int64, unsigned __int64))loc_14006F000)(v10 + 0x10, v9, v11);
    v12 = a2 + 0x240;
    v13 = v10 + 0x11 + v11;
    v14 = 0i64;
    if ( a2 != 0xFFFFFFFFFFFFFDC0ui64 )
    {
      do
      {
        if ( !*(_BYTE *)(v12 + v14) )
          break;
        ++v14;
      }
      while ( v14 < 0xFF );
    }
    ((void (__fastcall *)(unsigned __int64, __int64, unsigned __int64))loc_14006F000)(v13, v12, v14);
    v15 = v13 + v14;
    *(_BYTE *)(v15 + 1) = *(_BYTE *)(a2 + 0x109);
    *(_QWORD *)(v15 + 2) = *(_QWORD *)(a2 + 0x120);
    *(_QWORD *)(v15 + 0xA) = *(_QWORD *)(a2 + 0x128);
    *(_QWORD *)(v15 + 0x12) = *(_QWORD *)(a2 + 0x130);
    *(_DWORD *)(v15 + 0x1A) = *(_DWORD *)(a2 + 0x138);
    *(_DWORD *)(v15 + 0x1E) = *(_DWORD *)(a2 + 0x13C);
    v4 = v15 + 0x22;
  }
  return v4 - a1;
}

//----- (0000000140069DC8) ----------------------------------------------------
__int64 __fastcall sub_140069DC8(__int64 a1, char a2)
{
  __int64 result; // rax
  unsigned int *v3; // r11
  unsigned int v4; // ecx
  unsigned int v5; // ecx
  unsigned int v6; // eax
  __int64 v7; // rcx
  unsigned int v8; // er10
  unsigned int v9; // er9
  __int64 v10; // r15
  unsigned int v11; // ebx
  __int64 v12; // r12
  unsigned int *v13; // r13
  unsigned int *v14; // r14
  __int64 v15; // rbp
  __int64 v16; // r15
  unsigned int v17; // edx
  __int64 v18; // rax
  unsigned int v19; // ebx
  unsigned int *v20; // r14
  unsigned int v21; // edi
  int v22; // ebp
  int v23; // ecx
  unsigned int *v24; // r15
  __int64 v25; // r12
  __int64 v26; // rdx

  result = (unsigned __int16)word_1400D82CC;
  if ( word_1400D82CC )
  {
    v3 = (unsigned int *)qword_1400D82D0;
    v4 = 0x340 * (unsigned __int16)word_1400D82CC;
    if ( qword_1400D82D0 )
    {
      if ( v4 >= 8 )
      {
        v5 = v4 >> 2;
        v6 = 0x34 / v5;
        v7 = v5 - 1;
        v8 = v6 + 6;
        if ( a2 )
        {
          v9 = *(_DWORD *)(qword_1400D82D0 + 4 * v7);
          v10 = qword_1400D82D0 + 4;
          v11 = 0;
          do
          {
            v11 -= 0x61C88647;
            v12 = 0i64;
            v13 = (unsigned int *)v10;
            v14 = v3;
            v15 = (v11 >> 2) & 3;
            v16 = (unsigned int)v7;
            do
            {
              v17 = *v13++;
              v18 = v15 ^ v12++ & 3;
              *v14 += ((v11 ^ v17) + (*((_DWORD *)&unk_1400D82C8 + v18 + 4) ^ v9)) ^ (((0x10 * v9) ^ (v17 >> 3))
                                                                                    + ((v9 >> 5) ^ (4 * v17)));
              v9 = *v14++;
              --v16;
            }
            while ( v16 );
            v10 = (__int64)(v3 + 1);
            result = 0x10 * v9;
            v3[(unsigned int)v7] += ((v11 ^ *v3) + (*((_DWORD *)&unk_1400D82C8 + (v15 ^ 3) + 4) ^ v9)) ^ ((result ^ (*v3 >> 3)) + ((v9 >> 5) ^ (4 * *v3)));
            v9 = v3[(unsigned int)v7];
            --v8;
          }
          while ( v8 );
        }
        else
        {
          v19 = *(_DWORD *)qword_1400D82D0;
          v20 = (unsigned int *)(qword_1400D82D0 + 4 * v7);
          v21 = 0x9E3779B9 * v8;
          v22 = v7;
          do
          {
            v23 = v22;
            v24 = v20;
            v25 = (v21 >> 2) & 3;
            do
            {
              v26 = v25 ^ v23-- & 3;
              *v24 -= ((v21 ^ v19) + (*((_DWORD *)&unk_1400D82C8 + v26 + 4) ^ v3[v23])) ^ (((0x10 * v3[v23]) ^ (v19 >> 3))
                                                                                         + ((v3[v23] >> 5) ^ (4 * v19)));
              v19 = *v24;
              v24 += 0xFFFFFFFF;
            }
            while ( v23 );
            result = 0x10 * *v20;
            *v3 -= ((v21 ^ v19) + (*((_DWORD *)&unk_1400D82C8 + v25 + 4) ^ *v20)) ^ ((result ^ (v19 >> 3))
                                                                                   + ((*v20 >> 5) ^ (4 * v19)));
            v19 = *v3;
            v21 += 0x61C88647;
          }
          while ( v21 );
        }
      }
    }
  }
  return result;
}
// 1400D82CC: using guessed type __int16 word_1400D82CC;
// 1400D82D0: using guessed type __int64 qword_1400D82D0;

//----- (000000014006A7E4) ----------------------------------------------------
__int64 __fastcall sub_14006A7E4(__int64 *a1, __int64 *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6)
{
  char v6; // bl
  signed __int64 v7; // rax
  __int64 *v9; // rsi
  __int64 *i; // rdi
  __int64 *v11; // r12
  __int64 v12; // r15
  __int64 v13; // r9
  __int64 result; // rax
  __int64 *j; // rbx
  __int64 l; // r15
  __int64 *v17; // rsi
  __int64 v18; // r14
  __int64 v19; // rcx
  __int64 *v20; // r12
  __int64 *k; // r15
  __int64 v22; // [rsp+20h] [rbp-20h]
  __int64 v23; // [rsp+28h] [rbp-18h]
  __int64 *v24; // [rsp+30h] [rbp-10h] BYREF
  __int64 v25; // [rsp+38h] [rbp-8h]

  v6 = a4;
  v7 = (char *)a2 - (char *)a1;
  v9 = a2;
  for ( i = a1; ; v7 = (char *)v9 - (char *)i )
  {
    result = v7 & 0xFFFFFFFFFFFFFFF8ui64;
    if ( result <= 0x100 )
    {
      if ( i != v9 )
      {
        for ( j = i + 1; j != v9; ++j )
        {
          v18 = *j;
          v19 = *j;
          v20 = j;
          a6 = 0i64;
          a5 = 0i64;
          sub_140013E74(v19, &a6);
          sub_140013E74(*i, &a5);
          if ( a6 <= a5 )
          {
            for ( k = j + 0xFFFFFFFF; ; k += 0xFFFFFFFF )
            {
              a5 = 0i64;
              a6 = 0i64;
              sub_140013E74(v18, &a6);
              sub_140013E74(*k, &a5);
              result = a5;
              if ( a6 <= a5 )
                break;
              *v20 = *k;
              v20 = k;
            }
            *v20 = v18;
          }
          else
          {
            result = ((__int64 (__fastcall *)(__int64 *, __int64 *))loc_14006F000)(i + 1, i);
            *i = v18;
          }
        }
      }
      return result;
    }
    if ( a3 <= 0 )
      break;
    LOBYTE(a4) = v6;
    sub_14006A9EC(&v24, i, v9, a4, v22, v23, (__int64)v24);
    v11 = v24;
    v12 = v25;
    a3 = (a3 >> 2) + (a3 >> 1);
    LOBYTE(v13) = v6;
    if ( (__int64)(((char *)v24 - (char *)i) & 0xFFFFFFFFFFFFFFF8ui64) >= (__int64)(((unsigned __int64)v9 - v25) & 0xFFFFFFFFFFFFFFF8ui64) )
    {
      sub_14006A7E4(v25, v9, a3, v13);
      v9 = v11;
    }
    else
    {
      sub_14006A7E4(i, v24, a3, v13);
      i = (__int64 *)v12;
    }
  }
  for ( l = ((char *)v9 - (char *)i) >> 4; l > 0; result = sub_14006AD08((__int64)i, l, v9 - i, &a5, v22, v23) )
  {
    --l;
    LOBYTE(v22) = v6;
    a5 = i[l];
  }
  if ( v9 - i >= 2 )
  {
    v17 = v9 + 0xFFFFFFFF;
    do
    {
      a5 = *v17;
      *v17 = *i;
      LOBYTE(v22) = v6;
      sub_14006AD08((__int64)i, 0i64, v17 - i, &a5, v22, v23);
      v17 += 0xFFFFFFFF;
      result = ((unsigned __int64)v17 + 8i64 - (_QWORD)i) & 0xFFFFFFFFFFFFFFF8ui64;
    }
    while ( result >= 0x10 );
  }
  return result;
}
// 14006A827: variable 'a4' is possibly undefined
// 14006A827: variable 'v22' is possibly undefined
// 14006A827: variable 'v23' is possibly undefined
// 14006A866: variable 'v13' is possibly undefined

//----- (000000014006A9EC) ----------------------------------------------------
__int64 **__fastcall sub_14006A9EC(__int64 **a1, __int64 *a2, __int64 *a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7)
{
  __int64 *v7; // rbx
  __int64 *v9; // r12
  __int64 *v10; // rcx
  __int64 *v11; // r15
  __int64 v12; // rax
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rdi
  __int64 *v16; // r14
  __int64 *v17; // rbx
  __int64 *v18; // rdi
  __int64 v19; // rcx
  __int64 v20; // rcx
  __int64 v21; // rcx
  __int64 v22; // rcx
  __int64 *v23; // rdi
  __int64 *v24; // rsi
  __int64 v25; // rcx
  __int64 v26; // rcx
  __int64 v27; // rcx
  bool v28; // zf
  __int64 *v29; // r14
  __int64 v30; // rcx
  __int64 v31; // rcx
  __int64 v32; // rcx
  __int64 v33; // rcx
  __int64 v34; // rcx
  __int64 v35; // rcx
  __int64 v36; // rcx
  __int64 **result; // rax

  v7 = a3 + 0xFFFFFFFF;
  v9 = a2;
  v10 = a2;
  v11 = &a2[((char *)a3 - (char *)a2) >> 4];
  v12 = a3 + 0xFFFFFFFF - a2;
  if ( v12 > 0x28 )
  {
    v13 = (v12 + 1) >> 3;
    v14 = 0x10 * v13;
    v15 = 8 * v13;
    v16 = &a2[v13];
    sub_14006AE0C(a2, v16, &a2[2 * v13]);
    sub_14006AE0C(&v11[v15 / 0xFFFFFFFFFFFFFFF8ui64], v11, &v11[(unsigned __int64)v15 / 8]);
    v7 = (__int64 *)((char *)v7 - v15);
    sub_14006AE0C(&a3[v14 / 0xFFFFFFFFFFFFFFF8ui64 + 0xFFFFFFFF], v7, a3 + 0xFFFFFFFF);
    v10 = v16;
  }
  sub_14006AE0C(v10, v11, v7);
  v17 = v11 + 1;
  if ( v9 < v11 )
  {
    do
    {
      v18 = v11 + 0xFFFFFFFF;
      v19 = v11[0xFFFFFFFF];
      a7 = 0i64;
      a6 = 0i64;
      sub_140013E74(v19, &a7);
      sub_140013E74(*v11, &a6);
      if ( a7 > a6 )
        break;
      v20 = *v11;
      a7 = 0i64;
      a6 = 0i64;
      sub_140013E74(v20, &a7);
      sub_140013E74(*v18, &a6);
      if ( a7 > a6 )
        break;
      v11 += 0xFFFFFFFF;
    }
    while ( v9 < v18 );
  }
  while ( v17 < a3 )
  {
    v21 = *v17;
    a7 = 0i64;
    a6 = 0i64;
    sub_140013E74(v21, &a7);
    sub_140013E74(*v11, &a6);
    if ( a7 > a6 )
      break;
    v22 = *v11;
    a7 = 0i64;
    a6 = 0i64;
    sub_140013E74(v22, &a7);
    sub_140013E74(*v17, &a6);
    if ( a7 > a6 )
      break;
    ++v17;
  }
  v23 = v17;
  v24 = v11;
  while ( 1 )
  {
    while ( v23 < a3 )
    {
      v25 = *v11;
      a7 = 0i64;
      a6 = 0i64;
      sub_140013E74(v25, &a7);
      sub_140013E74(*v23, &a6);
      if ( a7 > a6 )
        goto LABEL_18;
      v26 = *v23;
      a7 = 0i64;
      a6 = 0i64;
      sub_140013E74(v26, &a7);
      sub_140013E74(*v11, &a6);
      if ( a7 > a6 )
        break;
      if ( v17 != v23 )
      {
        v27 = *v17;
        *v17 = *v23;
        *v23 = v27;
      }
      ++v17;
LABEL_18:
      ++v23;
    }
    v28 = v24 == v9;
    if ( v24 > v9 )
    {
      v29 = v24 + 0xFFFFFFFF;
      do
      {
        v30 = *v29;
        a7 = 0i64;
        a6 = 0i64;
        sub_140013E74(v30, &a7);
        sub_140013E74(*v11, &a6);
        if ( a7 <= a6 )
        {
          v31 = *v11;
          a7 = 0i64;
          a6 = 0i64;
          sub_140013E74(v31, &a7);
          sub_140013E74(*v29, &a6);
          if ( a7 > a6 )
            break;
          v11 += 0xFFFFFFFF;
          if ( v11 != v29 )
          {
            v32 = *v11;
            *v11 = *v29;
            *v29 = v32;
          }
        }
        v24 += 0xFFFFFFFF;
        v29 += 0xFFFFFFFF;
      }
      while ( v9 < v24 );
      v28 = v24 == v9;
    }
    if ( v28 )
      break;
    v24 += 0xFFFFFFFF;
    if ( v23 != a3 )
    {
      v36 = *v23;
      *v23 = *v24;
      *v24 = v36;
      goto LABEL_18;
    }
    v11 += 0xFFFFFFFF;
    if ( v24 == v11 )
    {
      v35 = *v11;
    }
    else
    {
      v35 = *v24;
      *v24 = *v11;
      *v11 = v35;
    }
    v17 += 0xFFFFFFFF;
    *v11 = *v17;
    *v17 = v35;
  }
  if ( v23 != a3 )
  {
    if ( v17 != v23 )
    {
      v33 = *v11;
      *v11 = *v17;
      *v17 = v33;
    }
    v34 = *v11;
    ++v17;
    *v11++ = *v23;
    *v23 = v34;
    goto LABEL_18;
  }
  result = a1;
  a1[1] = v17;
  *a1 = v11;
  return result;
}

//----- (000000014006AD08) ----------------------------------------------------
__int64 __fastcall sub_14006AD08(__int64 a1, __int64 a2, __int64 a3, __int64 *a4, __int64 a5, __int64 a6)
{
  __int64 v8; // rcx
  __int64 v10; // rbx
  __int64 v11; // r14
  __int64 v12; // r12
  __int64 v13; // rsi
  __int64 v14; // rcx
  __int64 v15; // rsi
  __int64 result; // rax

  v8 = a3 - 1;
  v10 = a2;
  v11 = (a3 - 1) >> 1;
  v12 = a2;
  v13 = a2;
  if ( a2 < v11 )
  {
    do
    {
      v13 = 2 * v13 + 2;
      v14 = *(_QWORD *)(a1 + 8 * v13);
      a6 = 0i64;
      a5 = 0i64;
      sub_140013E74(v14, &a6);
      sub_140013E74(*(_QWORD *)(a1 + 8 * v13 - 8), &a5);
      if ( a6 > a5 )
        --v13;
      *(_QWORD *)(a1 + 8 * v10) = *(_QWORD *)(a1 + 8 * v13);
      v10 = v13;
    }
    while ( v13 < v11 );
    v8 = a3 - 1;
  }
  if ( v13 == v11 && (a3 & 1) == 0 )
  {
    *(_QWORD *)(a1 + 8 * v10) = *(_QWORD *)(a1 + 8 * a3 - 8);
    v10 = v8;
  }
  if ( v12 < v10 )
  {
    do
    {
      v15 = (v10 - 1) >> 1;
      a6 = 0i64;
      a5 = 0i64;
      sub_140013E74(*(_QWORD *)(a1 + 8 * v15), &a6);
      sub_140013E74(*a4, &a5);
      if ( a6 <= a5 )
        break;
      *(_QWORD *)(a1 + 8 * v10) = *(_QWORD *)(a1 + 8 * v15);
      v10 = (v10 - 1) >> 1;
    }
    while ( v12 < v15 );
  }
  result = *a4;
  *(_QWORD *)(a1 + 8 * v10) = *a4;
  return result;
}

//----- (000000014006AE0C) ----------------------------------------------------
__int64 __fastcall sub_14006AE0C(__int64 *a1, __int64 *a2, __int64 *a3)
{
  __int64 v6; // rcx
  __int64 v7; // rcx
  __int64 result; // rax
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // [rsp+20h] [rbp-10h] BYREF
  __int64 v12; // [rsp+28h] [rbp-8h] BYREF

  v12 = 0i64;
  v11 = 0i64;
  sub_140013E74(*a2, &v12);
  sub_140013E74(*a1, &v11);
  if ( v12 > v11 )
  {
    v6 = *a2;
    *a2 = *a1;
    *a1 = v6;
  }
  v7 = *a3;
  v11 = 0i64;
  v12 = 0i64;
  sub_140013E74(v7, &v11);
  sub_140013E74(*a2, &v12);
  result = v12;
  if ( v11 > v12 )
  {
    v9 = *a3;
    *a3 = *a2;
    v11 = 0i64;
    v12 = 0i64;
    *a2 = v9;
    sub_140013E74(v9, &v11);
    sub_140013E74(*a1, &v12);
    result = v12;
    if ( v11 > v12 )
    {
      result = *a1;
      v10 = *a2;
      *a2 = *a1;
      *a1 = v10;
    }
  }
  return result;
}

//----- (000000014006B2D8) ----------------------------------------------------
__int64 __fastcall sub_14006B2D8(__int64 a1, __int64 a2, __int64 a3, _QWORD *a4)
{
  int v4; // eax
  __int64 v5; // r8
  __int64 v6; // rax
  int v7; // eax
  char v9; // al

  if ( a1 && a2 && a4 )
  {
    v4 = *(_DWORD *)(a2 + 4);
    if ( v4 == 2 )
    {
      if ( *(_BYTE *)(a2 + 0x40) )
      {
        v7 = *(_DWORD *)(a2 + 0x30);
        if ( v7 == 0xC4 )
        {
          v6 = (unsigned int)a3 + *(_DWORD *)(a2 + 0x48) + *(unsigned __int8 *)(a1 + 8);
          goto LABEL_15;
        }
        if ( v7 == 0xC5 )
        {
          v6 = a3 + *(_QWORD *)(a2 + 0x48) + *(unsigned __int8 *)(a1 + 8);
          goto LABEL_15;
        }
        if ( !v7 && !*(_DWORD *)(a2 + 0x34) )
        {
          v9 = *(_BYTE *)(a1 + 0x17);
          switch ( v9 )
          {
            case 0x10:
              *a4 = (unsigned __int16)*(_DWORD *)(a2 + 0x48);
              return 0x100000i64;
            case 0x20:
              v6 = *(unsigned int *)(a2 + 0x48);
              goto LABEL_15;
            case 0x40:
              v6 = *(_QWORD *)(a2 + 0x48);
              goto LABEL_15;
          }
        }
      }
    }
    else if ( v4 == 4 && *(_BYTE *)(a2 + 0x58) && *(_BYTE *)(a2 + 0x59) )
    {
      v5 = *(_QWORD *)(a2 + 0x60) + *(unsigned __int8 *)(a1 + 8) + a3;
      *a4 = v5;
      if ( !*(_DWORD *)a1 )
        return 0x100000i64;
      if ( (unsigned int)(*(_DWORD *)a1 - 1) <= 4 )
      {
        if ( *(_WORD *)(a2 + 0x14) == 0x10 )
        {
          v6 = (unsigned __int16)v5;
LABEL_15:
          *a4 = v6;
        }
        return 0x100000i64;
      }
    }
  }
  return 0x80100004i64;
}

//----- (000000014006B3B0) ----------------------------------------------------
__int64 __fastcall sub_14006B3B0(__int64 a1, int a2, _DWORD *a3)
{
  unsigned __int64 v4; // rcx
  _DWORD *v5; // r9

  v4 = 0i64;
  if ( !a1 || !a3 )
    return 0x80100004i64;
  *a3 = 0;
  v5 = (_DWORD *)(a1 + 0x438);
  do
  {
    if ( *v5 == a2 )
      *a3 |= 1 << v4;
    ++v4;
    ++v5;
  }
  while ( v4 < 0x15 );
  return 0x100000i64;
}

//----- (000000014006B3F4) ----------------------------------------------------
__int64 __fastcall sub_14006B3F4(__int64 a1, int *a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, int a7)
{
  __int64 result; // rax
  int v10; // ebx
  int v11; // ebx
  int v12; // ebx

  result = sub_14006B3B0(a1, 2, a2);
  if ( (int)result >= 0 )
  {
    result = sub_14006B3B0(a1, 3, &a7);
    if ( (int)result >= 0 )
    {
      v10 = a7 | *a2;
      *a2 = v10;
      result = sub_14006B3B0(a1, 4, &a7);
      if ( (int)result >= 0 )
      {
        v11 = a7 | v10;
        *a2 = v11;
        result = sub_14006B3B0(a1, 5, &a7);
        if ( (int)result >= 0 )
        {
          v12 = a7 | v11;
          *a2 = v12;
          result = sub_14006B3B0(a1, 6, &a7);
          if ( (int)result >= 0 )
          {
            result = 0x100000i64;
            *a2 = a7 | v12;
          }
        }
      }
    }
  }
  return result;
}

//----- (000000014006B4A4) ----------------------------------------------------
__int64 __fastcall sub_14006B4A4(unsigned int a1, unsigned __int8 a2)
{
  __int64 v2; // rax
  int v3; // ecx
  __int64 result; // rax

  if ( a1
    && a1 - 0xB > 1
    && a1 < 0x13
    && (v2 = 2i64 * (int)a1, v3 = dword_1400703B0[4 * a1 + 1], a2 <= dword_1400703B0[2 * v2 + 2] - v3) )
  {
    result = v3 + (unsigned int)a2;
  }
  else
  {
    result = 0i64;
  }
  return result;
}
// 1400703B0: using guessed type int dword_1400703B0[];

//----- (000000014006B4DC) ----------------------------------------------------
__int64 __fastcall sub_14006B4DC(int a1, int a2)
{
  __int64 v2; // rax
  _DWORD *i; // r8
  __int64 v5; // r8
  unsigned __int8 v6; // dl

  v2 = 0i64;
  for ( i = &unk_1400703B8; a2 < i[0xFFFFFFFF] || a2 > *i; i += 4 )
  {
    if ( (unsigned __int64)++v2 >= 0x13 )
      return 0i64;
  }
  v5 = dword_1400703B0[4 * v2];
  if ( (_DWORD)v5 == 4 && a1 )
    return 0i64;
  v6 = a2 - byte_1400703B4[0x10 * v5];
  if ( (_DWORD)v5 == 1 )
  {
    v6 = byte_1400704E0[v6];
  }
  else
  {
    if ( (int)v5 <= 1 )
      return 0i64;
    if ( (int)v5 > 4 )
    {
      if ( (unsigned int)(v5 - 7) <= 2 )
        return (unsigned int)v6 + 0x98;
      return 0i64;
    }
  }
  if ( !a1 )
    return (unsigned int)v6 + 0x35;
  if ( a1 != 1 )
  {
    if ( a1 == 2 )
      return (unsigned int)v6 + 0x15;
    if ( a1 != 3 )
    {
      if ( (unsigned int)(a1 - 4) > 1 )
        return 0i64;
      return (unsigned int)v6 + 0x15;
    }
  }
  return (unsigned int)v6 + 0x25;
}
// 1400703B0: using guessed type int dword_1400703B0[];

//----- (000000014006B588) ----------------------------------------------------
__int16 __fastcall sub_14006B588(int a1, int a2)
{
  __int16 result; // ax
  int *v3; // r8
  unsigned __int64 v4; // rax
  __int64 v5; // rax

  if ( a2 > 0xC4 )
  {
    if ( a2 == 0xC5 )
      return a1 == 0 ? 0x40 : 0;
    if ( a2 > 0x103 )
    {
      if ( a2 <= 0x105 )
        return 0x40;
      if ( a2 <= 0x107 )
        return 0x20;
      if ( a2 == 0x108 )
        return 0x40;
    }
  }
  else
  {
    if ( a2 == 0xC4 )
      return 0x20;
    if ( a2 >= 0x4D )
    {
      if ( a2 <= 0x4F || a2 == 0xC0 )
        return 0x10;
      if ( a2 != 0xC1 )
      {
        if ( a2 != 0xC2 )
        {
          if ( a2 == 0xC3 )
            return 0x10;
          goto LABEL_17;
        }
        return a1 == 0 ? 0x40 : 0;
      }
      return 0x20;
    }
  }
LABEL_17:
  v3 = (int *)&unk_1400703B8;
  v4 = 0i64;
  while ( a2 < v3[0xFFFFFFFF] || a2 > *v3 )
  {
    ++v4;
    v3 += 4;
    if ( v4 >= 0x13 )
      return 0;
  }
  v5 = 2 * v4;
  if ( a1 )
    result = dword_1400703B0[2 * v5 + 3];
  else
    result = HIWORD(dword_1400703B0[2 * v5 + 3]);
  return result;
}
// 1400703B0: using guessed type int dword_1400703B0[];

//----- (000000014006B864) ----------------------------------------------------
__int64 __fastcall sub_14006B864(int **a1, __int64 a2, _BYTE *a3)
{
  int v4; // esi
  int v5; // er10
  int v8; // edx
  char v9; // bp
  int v10; // er14
  bool v11; // di
  int v12; // er8
  char v13; // di
  bool v14; // cc
  bool v16; // zf
  int v17; // er10
  int v18; // er10
  int v19; // er10
  int v20; // er10
  int v21; // edx
  char v22; // cl
  char v23; // dl
  int v24; // er10
  char v25; // al
  int v26; // er8

  v4 = a3[0xB] & 0xF;
  v5 = (unsigned __int8)a3[0xB] >> 4;
  v8 = 1;
  v9 = 0;
  v10 = *(_DWORD *)(a2 + 0xC);
  v11 = 0;
  v12 = 0;
  if ( v10 )
  {
    switch ( v10 )
    {
      case 2:
        v8 = a3[0xD] & 0xF;
        break;
      case 3:
        v8 = a3[0xD] & 0xF;
        v11 = (a3[0xD] & 0x10) != 0;
        break;
      case 4:
        v8 = a3[0xD] & 0xF;
        v11 = (a3[0xD] & 0x10) != 0;
        v12 = ((unsigned __int8)a3[0xF] >> 2) & 3;
        if ( *(_BYTE *)(a2 + 0x564) && (a3[0xF] & 0x10) == 0 )
          return 0x8020000Ai64;
        break;
      case 5:
        v13 = a3[0xD];
        v8 = v13 & 0xF;
        v11 = (v13 & 0x10) != 0;
        v12 = ((unsigned __int8)a3[0xE] >> 5) & 3;
        if ( !byte_140070698[8 * (a3[0xE] & 0x1F) + 0xB8 + *(unsigned __int8 *)(a2 + 0x574)] )
          return 0x80200001i64;
        break;
    }
  }
  else
  {
    if ( (char)a3[6] < 0 && **a1 == 5 )
      return 0x80200001i64;
    if ( *((_BYTE *)a1 + 0x18) && (char)a3[0xC] >= 0 )
      return 0x80200004i64;
  }
  switch ( v4 )
  {
    case 2:
      if ( !**a1 && *((_BYTE *)a1 + 0x2C) )
        return 0x80200003i64;
      break;
    case 3:
      if ( *(_BYTE *)(a2 + 0x579) == 1 )
        return 0x80200003i64;
      goto LABEL_35;
    case 4:
LABEL_35:
      v14 = *(_BYTE *)(a2 + 0x579) <= 5u;
LABEL_36:
      if ( !v14 )
        return 0x80200003i64;
      break;
    case 5:
      if ( !byte_140070698[(unsigned __int8)(*(_BYTE *)(a2 + 0x579) | (8 * *((_BYTE *)a1 + 0x27))) + 0x188] )
        return 0x80200003i64;
      break;
    default:
      switch ( v4 )
      {
        case 6:
          v16 = *((_BYTE *)a1 + 0x27) == 0;
          break;
        case 7:
          if ( **a1 )
            goto LABEL_40;
          if ( *((_BYTE *)a1 + 0x27) )
            return 0x80200003i64;
          v16 = *((_BYTE *)a1 + 0x2C) == 0;
          break;
        case 8:
          if ( *((_BYTE *)a1 + 0x27) )
            return 0x80200003i64;
          v14 = *(_BYTE *)(a2 + 0x579) <= 3u;
          goto LABEL_36;
        default:
          goto LABEL_40;
      }
      if ( !v16 )
        return 0x80200003i64;
      break;
  }
LABEL_40:
  v17 = v5 - 3;
  if ( v17 )
  {
    v18 = v17 - 1;
    if ( v18 )
    {
      v19 = v18 - 4;
      if ( v19 )
      {
        v20 = v19 - 1;
        if ( v20 )
        {
          if ( v20 == 1 && !**a1 && !*(_BYTE *)(a2 + 0x578) && *(_BYTE *)(a2 + 0x57A) == 5 )
            return 0x80200001i64;
        }
        else
        {
          v9 = 1;
        }
      }
      else if ( *((_BYTE *)a1 + 0x29) || *(_BYTE *)(a2 + 0x57A) > 3u )
      {
        return 0x80200003i64;
      }
      goto LABEL_55;
    }
  }
  else if ( *(_BYTE *)(a2 + 0x57A) == 1 )
  {
    return 0x80200003i64;
  }
  if ( *(_BYTE *)(a2 + 0x57A) > 6u )
    return 0x80200003i64;
LABEL_55:
  if ( !v8 )
  {
    if ( (*((_BYTE *)a1 + 0x2E) & 0xF) == 0 )
    {
      if ( v9 )
        goto LABEL_65;
      goto LABEL_61;
    }
    return 0x80200003i64;
  }
  v21 = v8 - 1;
  if ( !v21 )
    goto LABEL_65;
  if ( v21 != 1 )
  {
    if ( !**a1 && *((_BYTE *)a1 + 0x2E) > 7u )
      return 0x80200003i64;
    goto LABEL_65;
  }
LABEL_61:
  if ( *((_BYTE *)a1 + 0x2D) )
    return 0x80200003i64;
LABEL_65:
  if ( v11 )
  {
    v22 = *(_BYTE *)(a2 + 0x579);
    v23 = *(_BYTE *)(a2 + 0x57D);
    v24 = **a1;
    if ( !v24 )
    {
      v22 |= 8 * (*((_BYTE *)a1 + 0x27) | (2 * *((_BYTE *)a1 + 0x2C)));
      v23 |= 8 * (*((_BYTE *)a1 + 0x28) | (2 * *((_BYTE *)a1 + 0x2D)));
    }
    v25 = 0xF0;
    if ( v10 == 3 )
    {
      v25 = *((_BYTE *)a1 + 0x2E);
      if ( v24 )
        v25 &= 7u;
    }
    else if ( !v4 )
    {
      v22 = 0xF1;
    }
    if ( v22 == v23 || v22 == v25 || v23 == v25 )
      return 0x80200003i64;
  }
  v26 = v12 - 2;
  if ( v26 )
  {
    if ( v26 != 1 || !*((_BYTE *)a1 + 0x2F) )
      return 0x100000i64;
  }
  else if ( *((_BYTE *)a1 + 0x2F) )
  {
    return 0x100000i64;
  }
  return 0x8020000Ai64;
}

//----- (000000014006BBB0) ----------------------------------------------------
__int64 __fastcall sub_14006BBB0(__int64 a1, __int64 a2)
{
  char v2; // r11
  char i; // r9
  unsigned int v5; // er10
  _DWORD *v6; // rax
  bool v7; // zf
  __int64 v8; // rax
  bool v9; // cl

  v2 = 0;
  for ( i = 0; ; ++i )
  {
    if ( *(_BYTE *)(a2 + 8) >= 0xFu )
      return 0x80200002i64;
    if ( !*(_QWORD *)(a1 + 0x10) )
      return 0x80200000i64;
    v5 = **(unsigned __int8 **)(a1 + 8);
    if ( v5 <= 0x65 )
      break;
    switch ( v5 )
    {
      case 0x66u:
        v7 = *(_BYTE *)(a1 + 0x1C) == 0;
        *(_BYTE *)(a1 + 0x20) = i;
        if ( v7 )
        {
          *(_BYTE *)(a1 + 0x1C) = 0x66;
          *(_BYTE *)(a1 + 0x23) = i;
        }
        *(_QWORD *)(a2 + 0x430) |= 0x400000000ui64;
        break;
      case 0x67u:
        *(_BYTE *)(a1 + 0x21) = i;
        *(_QWORD *)(a2 + 0x430) |= 0x800000000ui64;
        break;
      case 0xF0u:
        *(_BYTE *)(a1 + 0x18) = 1;
        *(_BYTE *)(a1 + 0x1D) = i;
        break;
      case 0xF2u:
      case 0xF3u:
        *(_BYTE *)(a1 + 0x19) = v5;
        *(_BYTE *)(a1 + 0x1C) = v5;
        *(_BYTE *)(a1 + 0x1E) = i;
        *(_BYTE *)(a1 + 0x23) = i;
        break;
      default:
        goto LABEL_17;
    }
LABEL_26:
    if ( v2 )
    {
      if ( v2 != (_BYTE)v5 )
      {
        v2 = 0;
        *(_BYTE *)(a2 + 0x548) = 0;
      }
    }
    *(_BYTE *)(a2 + 8i64 * (unsigned __int8)(*(_BYTE *)(a2 + 0x4C8))++ + 0x4D0) = v5;
    ++*(_BYTE *)(a2 + 8);
    ++*(_QWORD *)(a1 + 8);
    --*(_QWORD *)(a1 + 0x10);
  }
  if ( v5 == 0x65 )
    goto LABEL_8;
  if ( ((v5 - 0x26) & 0xFFFFFFE7) == 0 )
  {
    v6 = *(_DWORD **)a1;
    *(_BYTE *)(a1 + 0x1A) = v5;
    *(_BYTE *)(a1 + 0x1F) = i;
    if ( *v6 || (unsigned __int8)(*(_BYTE *)(a1 + 0x1B) - 0x64) > 1u )
      goto LABEL_11;
    goto LABEL_26;
  }
  if ( v5 == 0x64 )
  {
LABEL_8:
    *(_BYTE *)(a1 + 0x1A) = v5;
    *(_BYTE *)(a1 + 0x1F) = i;
LABEL_11:
    *(_BYTE *)(a1 + 0x1B) = v5;
    *(_BYTE *)(a1 + 0x22) = i;
    goto LABEL_26;
  }
LABEL_17:
  if ( !**(_DWORD **)a1 && (v5 & 0xF0) == 0x40 )
  {
    v2 = **(_BYTE **)(a1 + 8);
    *(_BYTE *)(a2 + 0x548) = i;
    goto LABEL_26;
  }
  v8 = *(_QWORD *)(a2 + 0x430);
  if ( (v8 & 0x400000000i64) != 0 )
  {
    *(_DWORD *)(a2 + 8i64 * *(unsigned __int8 *)(a1 + 0x20) + 0x4CC) = 1;
    v8 = *(_QWORD *)(a2 + 0x430);
  }
  if ( (v8 & 0x800000000i64) != 0 )
    *(_DWORD *)(a2 + 8i64 * *(unsigned __int8 *)(a1 + 0x21) + 0x4CC) = 1;
  if ( v2 )
  {
    v9 = (v2 & 8) != 0;
    *(_DWORD *)(a2 + 8i64 * *(unsigned __int8 *)(a2 + 0x548) + 0x4CC) = 1;
    *(_QWORD *)(a2 + 0x430) |= 4ui64;
    *(_BYTE *)(a2 + 0x544) = v9;
    *(_BYTE *)(a2 + 0x545) = (v2 & 4) != 0;
    *(_BYTE *)(a2 + 0x546) = (v2 & 2) != 0;
    *(_BYTE *)(a2 + 0x547) = v2 & 1;
    *(_BYTE *)(a1 + 0x26) = v9;
    *(_BYTE *)(a1 + 0x27) = *(_BYTE *)(a2 + 0x545);
    *(_BYTE *)(a1 + 0x28) = *(_BYTE *)(a2 + 0x546);
    *(_BYTE *)(a1 + 0x29) = *(_BYTE *)(a2 + 0x547);
  }
  return 0x100000i64;
}

//----- (000000014006BDD4) ----------------------------------------------------
__int64 __fastcall sub_14006BDD4(__int64 a1, __int64 a2, _BYTE *a3)
{
  char v4; // al
  char v5; // al
  __int64 result; // rax
  char v7; // r10
  char v8; // cl
  bool v9; // zf
  char v10; // al
  char v11; // r10

  *(_QWORD *)(a2 + 0x430) |= 0x20ui64;
  *(_BYTE *)(a2 + 0x55C) = a3[1] >> 7;
  *(_BYTE *)(a2 + 0x55D) = (a3[1] & 0x40) != 0;
  *(_BYTE *)(a2 + 0x55E) = (a3[1] & 0x20) != 0;
  *(_BYTE *)(a2 + 0x55F) = (a3[1] & 0x10) != 0;
  v4 = a3[1];
  if ( (v4 & 0xC) != 0 )
    goto LABEL_14;
  v5 = v4 & 3;
  *(_BYTE *)(a2 + 0x560) = v5;
  if ( !v5 )
    return 0x80200007i64;
  v7 = a3[2] >> 7;
  *(_BYTE *)(a2 + 0x561) = v7;
  *(_BYTE *)(a2 + 0x562) = (a3[2] >> 3) & 0xF;
  *(_BYTE *)(a2 + 0x563) = a3[2] & 3;
  v8 = a3[3] >> 7;
  *(_BYTE *)(a2 + 0x564) = v8;
  *(_BYTE *)(a2 + 0x565) = (a3[3] & 0x40) != 0;
  *(_BYTE *)(a2 + 0x566) = (a3[3] & 0x20) != 0;
  *(_BYTE *)(a2 + 0x567) = (a3[3] & 0x10) != 0;
  v9 = (a3[3] & 8) == 0;
  *(_BYTE *)(a2 + 0x568) = (a3[3] & 8) != 0;
  if ( v9 )
  {
    if ( **(_DWORD **)a1 )
      goto LABEL_14;
  }
  v10 = a3[3] & 7;
  *(_BYTE *)(a2 + 0x569) = v10;
  if ( v8 && !v10 )
    return 0x8020000Ai64;
  *(_BYTE *)(a1 + 0x26) = v7;
  *(_BYTE *)(a1 + 0x27) = (*(_BYTE *)(a2 + 0x55C) & 1) == 0;
  *(_BYTE *)(a1 + 0x28) = (*(_BYTE *)(a2 + 0x55D) & 1) == 0;
  *(_BYTE *)(a1 + 0x29) = (*(_BYTE *)(a2 + 0x55E) & 1) == 0;
  v11 = (a3[3] >> 5) & 3;
  *(_BYTE *)(a1 + 0x2B) = v11;
  *(_BYTE *)(a1 + 0x2C) = (*(_BYTE *)(a2 + 0x55F) & 1) == 0;
  *(_BYTE *)(a1 + 0x2D) = (*(_BYTE *)(a2 + 0x568) & 1) == 0;
  *(_BYTE *)(a1 + 0x2E) = ~*(_BYTE *)(a2 + 0x562) & 0xF | (0x10 * ((*(_BYTE *)(a2 + 0x568) & 1) == 0));
  *(_BYTE *)(a1 + 0x2F) = *(_BYTE *)(a2 + 0x569);
  if ( !*(_BYTE *)(a2 + 0x568) )
  {
    if ( **(_DWORD **)a1 )
      goto LABEL_14;
  }
  if ( !*(_BYTE *)(a2 + 0x567) && v11 == 3 )
LABEL_14:
    result = 0x80200008i64;
  else
    result = 0x100000i64;
  return result;
}

//----- (000000014006BF98) ----------------------------------------------------
__int64 __fastcall sub_14006BF98(int **a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, __int64 a6, unsigned __int8 a7, unsigned __int8 a8)
{
  char *v8; // r12
  char *i; // r14
  unsigned int v12; // er15
  unsigned __int16 v13; // di
  int v14; // eax
  int v15; // eax
  int v16; // ecx
  int v17; // ecx
  __int16 v18; // di
  __int16 v19; // ax
  char v20; // al
  __int64 v21; // rax
  int *v22; // rcx
  __int16 v23; // ax
  unsigned __int64 v24; // rax
  __int64 v25; // r10
  char v26; // r11
  unsigned __int8 v27; // cl
  __int64 v28; // r10
  char v29; // r11
  unsigned __int8 v30; // cl
  unsigned __int64 v31; // rax
  int v32; // edx
  bool v33; // zf
  unsigned __int8 v35; // dl
  int v36; // eax
  char v37; // al
  __int64 v38; // [rsp+20h] [rbp-20h] BYREF
  __int64 v39; // [rsp+28h] [rbp-18h] BYREF

  v8 = (char *)&unk_140070834;
  for ( i = 0i64; ; i = 0i64 )
  {
    while ( 1 )
    {
      v12 = (unsigned __int8)*v8;
      v13 = 0;
      LOWORD(v38) = 0;
      if ( v12 > 0xE )
      {
        if ( v12 > 0x15 )
        {
          if ( v12 != 0x16 )
          {
            switch ( v12 )
            {
              case 0x17u:
                v33 = *((_BYTE *)*a1 + 0xC) == 0;
                break;
              case 0x18u:
                v33 = *((_BYTE *)*a1 + 0xD) == 0;
                break;
              case 0x19u:
                v33 = *((_BYTE *)*a1 + 0xE) == 0;
                break;
              case 0x1Au:
                v33 = *((_BYTE *)*a1 + 0xF) == 0;
                break;
              case 0x1Bu:
                v33 = *((_BYTE *)*a1 + 0x10) == 0;
                break;
              default:
                sub_14006EE20(*(_DWORD *)(a2 + 0xC), *(_WORD *)(v8 + 1), &v39);
                v35 = (*(_QWORD *)(a2 + 0x430) & 0x400000000i64) != 0;
                v36 = **a1;
                if ( v36 )
                {
                  if ( ((v36 - 1) & 0xFFFFFFFD) == 0 )
                    v35 += 2;
                }
                else
                {
                  v35 += 2 * ((*((_BYTE *)a1 + 0x26) & 1) + 2);
                }
                v37 = byte_140070698[8 * (*(_BYTE *)(v39 + 5) & 7) + 0x58 + v35];
                *(_BYTE *)(a2 + 0x16) = v37;
                if ( v37 == 0x10 )
                  *((_BYTE *)a1 + 0x24) = 0;
                else
                  *((_BYTE *)a1 + 0x24) = (v37 != 0x20) + 1;
                JUMPOUT(0x14006C598i64);
            }
            goto LABEL_87;
          }
          v13 = *((_BYTE *)*a1 + 0xB) != 0;
        }
        else
        {
          switch ( v12 )
          {
            case 0x15u:
              v33 = *((_BYTE *)*a1 + 0xA) == 0;
              goto LABEL_87;
            case 0xFu:
              JUMPOUT(0x14006C462i64);
            case 0x10u:
              v13 = *((unsigned __int8 *)a1 + 0x26);
              break;
            case 0x11u:
              v13 = *((unsigned __int8 *)a1 + 0x29);
              break;
            case 0x12u:
              v13 = *(unsigned __int8 *)(a2 + 0x567);
              break;
            case 0x13u:
              v13 = *(unsigned __int8 *)(a2 + 0x573);
              break;
            default:
              v33 = *((_BYTE *)*a1 + 9) == 0;
LABEL_87:
              v13 = !v33;
              goto LABEL_108;
          }
        }
        goto LABEL_108;
      }
      if ( v12 == 0xE )
      {
        v31 = *(_QWORD *)(a2 + 0x430);
        v32 = (*a1)[1];
        if ( v32 )
        {
          if ( v32 != 1 )
          {
            v23 = 2 - ((v31 & 0x800000000i64) != 0);
            goto LABEL_62;
          }
          v24 = v31 >> 0x23;
LABEL_50:
          LOBYTE(v24) = ~(_BYTE)v24;
        }
        else
        {
          v24 = v31 >> 0x23;
        }
        goto LABEL_52;
      }
      if ( v12 <= 7 )
        break;
      switch ( v12 )
      {
        case 8u:
          v16 = sub_14006D8EC((__int64)a1, a2, &v38, 4i64, v38, v39);
          if ( v16 < 0 )
            return (unsigned int)v16;
          v13 = (_WORD)v38 != 3;
LABEL_73:
          v16 = 0x100000;
LABEL_93:
          if ( v16 < 0 )
            return (unsigned int)v16;
          goto LABEL_108;
        case 9u:
          if ( !*(_BYTE *)(a2 + 0x57B) )
          {
            *(_BYTE *)(a2 + 0x57B) = *(_BYTE *)(a2 + 8);
            v16 = sub_14006D844((__int64)a1, a2, &a8);
            if ( v16 < 0 )
              return (unsigned int)v16;
            v30 = a8;
            *(_QWORD *)(a2 + 0x430) |= v28;
            *(_BYTE *)(a2 + 0x578) = v30 >> 6;
            *(_BYTE *)(a2 + 0x579) = v29 & (v30 >> 3);
            *(_BYTE *)(a2 + 0x57A) = v29 & v30;
          }
          v13 = *(unsigned __int8 *)(a2 + 0x579);
          goto LABEL_73;
        case 0xAu:
          if ( !*(_BYTE *)(a2 + 0x57B) )
          {
            *(_BYTE *)(a2 + 0x57B) = *(_BYTE *)(a2 + 8);
            v16 = sub_14006D844((__int64)a1, a2, &a7);
            if ( v16 < 0 )
              return (unsigned int)v16;
            v27 = a7;
            *(_QWORD *)(a2 + 0x430) |= v25;
            *(_BYTE *)(a2 + 0x578) = v27 >> 6;
            *(_BYTE *)(a2 + 0x579) = v26 & (v27 >> 3);
            *(_BYTE *)(a2 + 0x57A) = v26 & v27;
          }
          v13 = *(unsigned __int8 *)(a2 + 0x57A);
          goto LABEL_73;
        case 0xBu:
          v23 = *((_BYTE *)a1 + 0x19) != 0;
          goto LABEL_62;
      }
      if ( v12 != 0xC )
      {
        v22 = *a1;
        if ( !**a1 && *((_BYTE *)a1 + 0x26) )
        {
          v23 = 2;
LABEL_62:
          v13 = v23;
          goto LABEL_108;
        }
        if ( _bittest64((const signed __int64 *)(a2 + 0x430), 0x22u) )
        {
          *(_DWORD *)(a2 + 8i64 * *((unsigned __int8 *)a1 + 0x20) + 0x4CC) = 1;
          v22 = *a1;
        }
        if ( *v22 != 2 && *v22 < 4 )
        {
          v24 = *(_QWORD *)(a2 + 0x430) >> 0x22;
          goto LABEL_50;
        }
        v24 = *(_QWORD *)(a2 + 0x430) >> 0x22;
LABEL_52:
        v23 = v24 & 1;
        goto LABEL_62;
      }
      if ( *((_BYTE *)a1 + 0x1C) == 0x66 )
      {
        v13 = 2;
        *(_DWORD *)(a2 + 8i64 * *((unsigned __int8 *)a1 + 0x23) + 0x4CC) = 2;
        *(_QWORD *)(a2 + 0x430) &= 0xFFFFFFFBFFFFFFFFui64;
      }
      else if ( *((unsigned __int8 *)a1 + 0x1C) == 0xF2 )
      {
        v13 = 4;
        *(_DWORD *)(a2 + 8i64 * *((unsigned __int8 *)a1 + 0x23) + 0x4CC) = 2;
      }
      else if ( *((unsigned __int8 *)a1 + 0x1C) == 0xF3 )
      {
        v13 = 3;
        *(_DWORD *)(a2 + 8i64 * *((unsigned __int8 *)a1 + 0x23) + 0x4CC) = 2;
      }
      else
      {
        v13 = 1;
      }
      i = sub_14006EABC((unsigned __int8 *)v8, 0);
LABEL_108:
      v8 = sub_14006EABC((unsigned __int8 *)v8, v13);
    }
    if ( v12 == 7 )
    {
      v15 = sub_14006D8EC((__int64)a1, a2, &v38, 4i64, v38, v39);
LABEL_18:
      v13 = v38;
      v16 = v15;
      goto LABEL_93;
    }
    if ( (_BYTE)v12 )
    {
      if ( v12 == 1 )
      {
        if ( *(_DWORD *)(a2 + 0xC) )
        {
          v13 = *(unsigned __int8 *)(a2 + 0x54C) + 3 * *(unsigned __int8 *)(a2 + 0x550) - 7;
          goto LABEL_108;
        }
      }
      else if ( v12 == 2 )
      {
        if ( *(_DWORD *)(a2 + 0xC) )
        {
          v18 = *(unsigned __int8 *)(a2 + 0x559);
          v19 = *(unsigned __int8 *)(a2 + 0x555);
LABEL_23:
          v13 = v19 + 4 * v18 + 1;
          goto LABEL_108;
        }
      }
      else
      {
        if ( v12 != 3 )
        {
          if ( v12 != 4 )
          {
            if ( v12 == 5 )
            {
              v14 = **a1;
              if ( v14 )
              {
                if ( ((v14 - 1) & 0xFFFFFFFD) == 0 )
                  v13 = 1;
              }
              else
              {
                v13 = 2;
              }
            }
            else
            {
              v13 = **a1 != 0;
            }
            goto LABEL_108;
          }
          v15 = sub_14006D958((__int64)a1, a2, &v38, 4i64, v38, v39);
          goto LABEL_18;
        }
        v17 = *(_DWORD *)(a2 + 0xC);
        if ( v17 )
        {
          if ( v17 != 4 )
          {
            v13 = *(unsigned __int8 *)(a2 + 0x56F) + 0x11 + 4 * *(unsigned __int8 *)(a2 + 0x572);
            goto LABEL_108;
          }
          v18 = *(unsigned __int8 *)(a2 + 0x563);
          v19 = *(unsigned __int8 *)(a2 + 0x560);
          goto LABEL_23;
        }
      }
      v13 = 0;
      goto LABEL_108;
    }
    if ( !i )
      break;
    v20 = *((_BYTE *)a1 + 0x1C);
    v8 = i;
    if ( v20 )
    {
      *(_DWORD *)(a2 + 8i64 * *((unsigned __int8 *)a1 + 0x23) + 0x4CC) = 0;
      v20 = *((_BYTE *)a1 + 0x1C);
    }
    if ( v20 == 0x66 )
    {
      v21 = *((unsigned __int8 *)a1 + 0x23);
      if ( *((_BYTE *)a1 + 0x20) == (_BYTE)v21 )
        *(_DWORD *)(a2 + 8 * v21 + 0x4CC) = 1;
      *(_QWORD *)(a2 + 0x430) |= 0x400000000ui64;
    }
  }
  return 0x80200001i64;
}
// 14006C45D: control flows out of bounds to 14006C462
// 14006C596: control flows out of bounds to 14006C598
// 14006C035: conditional instruction was optimized away because of 'er15.4==6'
// 14006C1BA: conditional instruction was optimized away because of 'er15.4==D'
// 14006C409: conditional instruction was optimized away because of 'er15.4==14'
// 14006C4F4: conditional instruction was optimized away because of 'r15.1 in (1..E|10..1B)'
// 14006C4FA: conditional instruction was optimized away because of 'r15.1 in (1..E|10..1B)'
// 14006C2D0: variable 'v25' is possibly undefined
// 14006C2E7: variable 'v26' is possibly undefined
// 14006C333: variable 'v28' is possibly undefined
// 14006C34A: variable 'v29' is possibly undefined

//----- (000000014006C7A8) ----------------------------------------------------
__int64 __fastcall sub_14006C7A8(_BYTE *a1, __int64 a2, _BYTE *a3)
{
  unsigned __int8 v4; // al
  char v6; // cl
  char v7; // al

  *(_QWORD *)(a2 + 0x430) |= 0x40ui64;
  *(_BYTE *)(a2 + 0x56B) = a3[1] >> 7;
  *(_BYTE *)(a2 + 0x56C) = (a3[1] & 0x40) != 0;
  *(_BYTE *)(a2 + 0x56D) = (a3[1] & 0x20) != 0;
  *(_BYTE *)(a2 + 0x56E) = (a3[1] & 0x10) != 0;
  v4 = a3[1] & 0xF;
  *(_BYTE *)(a2 + 0x56F) = v4;
  if ( v4 > 3u )
    return 0x80200007i64;
  v6 = a3[2] >> 7;
  *(_BYTE *)(a2 + 0x570) = v6;
  *(_BYTE *)(a2 + 0x571) = (a3[2] >> 3) & 0xF;
  *(_BYTE *)(a2 + 0x572) = a3[2] & 3;
  *(_BYTE *)(a2 + 0x573) = a3[3] >> 7;
  *(_BYTE *)(a2 + 0x574) = (a3[3] >> 4) & 7;
  *(_BYTE *)(a2 + 0x575) = (a3[3] & 8) != 0;
  *(_BYTE *)(a2 + 0x576) = a3[3] & 7;
  a1[0x26] = v6;
  a1[0x27] = (*(_BYTE *)(a2 + 0x56B) & 1) == 0;
  a1[0x28] = (*(_BYTE *)(a2 + 0x56C) & 1) == 0;
  a1[0x29] = (*(_BYTE *)(a2 + 0x56D) & 1) == 0;
  a1[0x2C] = (*(_BYTE *)(a2 + 0x56E) & 1) == 0;
  v7 = ~*(_BYTE *)(a2 + 0x575);
  a1[0x2B] = 2;
  a1[0x2D] = v7 & 1;
  a1[0x2E] = ~*(_BYTE *)(a2 + 0x571) & 0xF | (0x10 * ((*(_BYTE *)(a2 + 0x575) & 1) == 0));
  a1[0x2F] = *(_BYTE *)(a2 + 0x576);
  return 0x100000i64;
}

//----- (000000014006C8F4) ----------------------------------------------------
__int64 __fastcall sub_14006C8F4(_DWORD **a1, __int64 a2, __int64 a3)
{
  char v3; // di
  char v4; // al
  __int64 v6; // r11
  char v9; // r11
  char v10; // r11
  int v11; // eax

  *(_DWORD *)(a3 + 4) = 2;
  v3 = 0;
  *(_DWORD *)(a3 + 0x28) = 1;
  v4 = *(_BYTE *)(a2 + 0x17);
  v6 = *(unsigned __int8 *)(a2 + 0x57A);
  if ( v4 == 0x10 )
  {
    *(_DWORD *)(a3 + 0x30) = dword_140070508[v6];
    v11 = dword_140070528[v6];
    *(_DWORD *)(a3 + 0x34) = v11;
    *(_BYTE *)(a3 + 0x38) = v11 != 0;
    if ( !*(_BYTE *)(a2 + 0x578) )
    {
      if ( (_BYTE)v6 != 6 )
        return 0x100000i64;
      *(_DWORD *)(a3 + 0x30) &= *(unsigned __int8 *)(a2 + 0x578);
    }
LABEL_24:
    *(_BYTE *)(a3 + 0x40) = 1;
    *(_QWORD *)(a3 + 0x48) = *(_QWORD *)(a2 + 0x580);
    return 0x100000i64;
  }
  if ( v4 != 0x20 )
  {
    *(_DWORD *)(a3 + 0x30) = (unsigned __int8)((__int64 (__fastcall *)(_DWORD **, __int64, __int64, __int64))loc_14006B654)(
                                                a1,
                                                a2,
                                                5i64,
                                                4i64)
                           + 0x35;
    if ( *(_BYTE *)(a2 + 0x578) )
    {
      if ( *(_BYTE *)(a2 + 0x578) == 1 )
      {
        v3 = 8;
        goto LABEL_9;
      }
    }
    else
    {
      if ( v9 != 5 )
        goto LABEL_9;
      *(_DWORD *)(a3 + 0x30) = **a1 == 0 ? 0xC5 : 0;
    }
    v3 = 0x20;
LABEL_9:
    if ( (v9 & 7) == 4 )
      JUMPOUT(0x14006C9BCi64);
    goto LABEL_19;
  }
  *(_DWORD *)(a3 + 0x30) = (unsigned __int8)((__int64 (__fastcall *)(_DWORD **, __int64, __int64, __int64))loc_14006B654)(
                                              a1,
                                              a2,
                                              5i64,
                                              3i64)
                         + 0x25;
  if ( *(_BYTE *)(a2 + 0x578) )
  {
    if ( *(_BYTE *)(a2 + 0x578) == 1 )
    {
      v3 = 8;
      goto LABEL_17;
    }
  }
  else
  {
    if ( v10 != 5 )
      goto LABEL_17;
    *(_DWORD *)(a3 + 0x30) = **a1 == 0 ? 0xC4 : 0;
  }
  v3 = 0x20;
LABEL_17:
  if ( v10 == 4 )
    JUMPOUT(0x14006CA98i64);
LABEL_19:
  *(_DWORD *)(a3 + 0x34) = 0;
  *(_BYTE *)(a3 + 0x38) = 0;
  if ( v3 )
    goto LABEL_24;
  return 0x100000i64;
}
// 14006C9B9: control flows out of bounds to 14006C9BC
// 14006CA95: control flows out of bounds to 14006CA98
// 14006C98D: variable 'v9' is possibly undefined
// 14006CA68: variable 'v10' is possibly undefined

//----- (000000014006CB7C) ----------------------------------------------------
__int64 __fastcall sub_14006CB7C(__int64 a1, __int64 a2, unsigned int a3, unsigned __int8 a4)
{
  int v5; // eax

  *(_DWORD *)(a2 + 4) = 1;
  if ( a3 == 1 )
  {
    if ( (*(_BYTE *)(a1 + 0x430) & 4) != 0 && a4 >= 4u )
      v5 = a4 + 5;
    else
      v5 = a4 + 1;
  }
  else
  {
    v5 = sub_14006B4A4(a3, a4);
  }
  *(_DWORD *)(a2 + 0x20) = v5;
  return 0x100000i64;
}

//----- (000000014006CBCC) ----------------------------------------------------
__int64 __fastcall sub_14006CBCC(unsigned __int8 *a1, __int64 a2, __int64 a3, __int64 a4, __int64 a5, unsigned __int8 *a6)
{
  unsigned __int8 v8; // r13
  char v9; // al
  unsigned __int8 v10; // r12
  unsigned __int8 *v11; // rsi
  __int64 v12; // rdi
  __int64 v13; // r9
  unsigned __int8 v14; // al
  __int64 v15; // r8
  int v16; // ecx
  int v17; // eax
  int v18; // eax
  bool v19; // zf
  char v20; // cl
  int v21; // edx
  unsigned int v22; // ecx
  int v23; // ecx
  bool v24; // zf
  char v25; // al
  int v26; // edx
  unsigned int v27; // ecx
  unsigned int v28; // er11
  char v29; // al
  unsigned int v30; // ecx
  unsigned int v31; // ecx
  unsigned int v32; // ecx
  unsigned int v33; // ecx
  unsigned int v34; // ecx
  unsigned int v35; // ecx
  unsigned int v36; // ecx
  __int64 result; // rax
  __int64 v38; // rcx
  __int64 v39; // rax
  unsigned __int8 v40; // r9
  __int64 v41; // r8
  __int64 v42; // rax
  unsigned __int64 v43; // rax
  __int64 v44; // rcx

  v8 = 0;
  v9 = sub_14006EE94(a3, &a6);
  v10 = 0;
  *(_BYTE *)(a2 + 0x18) = v9;
  if ( v9 )
  {
    v11 = a6;
    do
    {
      v12 = 0x68i64 * v10;
      *(_BYTE *)(v12 + a2 + 0x20) = v10;
      *(_DWORD *)(v12 + a2 + 0x28) = *v11 >> 6;
      *(_BYTE *)(v12 + a2 + 0x2C) = v11[1] & 0xF;
      if ( (*v11 & 0x3F) == 1 )
      {
        *(_DWORD *)(v12 + a2 + 0x24) = 1;
        if ( (v11[9] & 7) == 0 )
        {
          v17 = *((_WORD *)v11 + 5) & 0x1FF;
          goto LABEL_53;
        }
        if ( (v11[9] & 7) == 1 )
        {
          v22 = dword_140070548[a1[0x24]];
          goto LABEL_48;
        }
        if ( (v11[9] & 7) == 2 )
        {
          v25 = *(_BYTE *)(a2 + 0x17);
          if ( v25 == 0x10 )
            goto LABEL_45;
          v23 = 0;
          v24 = v25 == 0x20;
        }
        else
        {
          if ( (v11[9] & 7) != 3 )
          {
            if ( (v11[9] & 7) == 4 )
            {
              v20 = *(_BYTE *)(a2 + 0x17);
              if ( v20 == 0x10 )
              {
                v17 = 0xC3;
                goto LABEL_53;
              }
              v18 = 0;
              v19 = v20 == 0x20;
            }
            else
            {
              v16 = *(_DWORD *)(*(_QWORD *)a1 + 4i64);
              if ( (v11[9] & 7) != 5 )
              {
                if ( v16 )
                  v17 = (v16 != 1) + 0xC1;
                else
                  v17 = 0xC0;
                goto LABEL_53;
              }
              if ( !v16 )
              {
                v17 = 0xC4;
LABEL_53:
                *(_DWORD *)(v12 + a2 + 0x40) = v17;
                goto LABEL_54;
              }
              v18 = 0;
              v19 = v16 == 1;
            }
            LOBYTE(v18) = !v19;
            v17 = v18 + 0xC4;
            goto LABEL_53;
          }
          v21 = *(_DWORD *)(*(_QWORD *)a1 + 4i64);
          if ( !v21 )
          {
LABEL_45:
            v22 = 2;
LABEL_48:
            v17 = sub_14006B4A4(v22, v11[0xA] & 0x3F);
            v11 = a6;
            goto LABEL_53;
          }
          v23 = 0;
          v24 = v21 == 1;
        }
        LOBYTE(v23) = !v24;
        v22 = v23 + 3;
        goto LABEL_48;
      }
      if ( (*v11 & 0x3F) != 2 )
      {
        if ( (*v11 & 0x3F) == 3 )
        {
          *(_WORD *)(v12 + a2 + 0x78) = 0;
          *(_DWORD *)(v12 + a2 + 0x24) = 4;
          *(_WORD *)(v12 + a2 + 0x34) = 8;
          *(_QWORD *)(v12 + a2 + 0x80) = 1i64;
        }
        goto LABEL_54;
      }
      *(_DWORD *)(v12 + a2 + 0x24) = 2;
      *(_DWORD *)(v12 + a2 + 0x48) = 1;
      v13 = (unsigned int)dword_140070558[a1[0x25]];
      if ( ((v11[9] >> 3) & 0xF) != 0 )
      {
        if ( ((v11[9] >> 3) & 0xF) != 1 )
        {
          switch ( (v11[9] >> 3) & 0xF )
          {
            case 2:
              v14 = 0;
              break;
            case 3:
              v14 = 2;
              break;
            case 4:
              v14 = 3;
              break;
            case 5:
              v14 = 4;
              break;
            case 6:
              v14 = 5;
              break;
            case 7:
              v14 = 6;
              break;
            default:
              v14 = 7;
              break;
          }
          goto LABEL_25;
        }
        v15 = 4i64;
      }
      else
      {
        v15 = 2i64;
      }
      v14 = ((__int64 (__fastcall *)(unsigned __int8 *, __int64, __int64, __int64))loc_14006B654)(a1, a2, v15, v13);
LABEL_25:
      *(_DWORD *)(v12 + a2 + 0x50) = sub_14006B4A4(v13, v14);
      if ( (v11[9] & 7) != 0 )
        *(_DWORD *)(v12 + a2 + 0x4C) = sub_14006B4A4(0xDu, (v11[9] & 7u) - 1);
      v11 = a6;
LABEL_54:
      v26 = *(_DWORD *)(v12 + a2 + 0x24);
      if ( v26 )
        goto LABEL_136;
      *(_DWORD *)(v12 + a2 + 0x30) = v11[9] & 0x3F;
      v27 = *v11 & 0x3F;
      if ( v27 > 0xD )
      {
        switch ( v27 )
        {
          case 0xEu:
            v28 = 7;
            goto LABEL_122;
          case 0xFu:
            v28 = 8;
            goto LABEL_122;
          case 0x10u:
            v28 = 9;
            goto LABEL_122;
          case 0x11u:
            v28 = 0xA;
            goto LABEL_122;
          case 0x12u:
            v28 = 0x12;
            goto LABEL_122;
          case 0x13u:
            v28 = 0xD;
            goto LABEL_122;
          case 0x14u:
            v28 = 0xF;
            goto LABEL_122;
          case 0x15u:
            v28 = 0x10;
            goto LABEL_122;
          case 0x16u:
            v28 = 0x11;
            goto LABEL_122;
        }
      }
      else
      {
        switch ( v27 )
        {
          case 0xDu:
            v28 = 6;
            goto LABEL_122;
          case 4u:
            v28 = 1;
            goto LABEL_122;
          case 5u:
            goto LABEL_69;
          case 6u:
            goto LABEL_72;
          case 7u:
            v28 = 4;
            goto LABEL_122;
          case 8u:
            v29 = *(_BYTE *)(a2 + 0x16);
            goto LABEL_68;
          case 9u:
            v29 = *(_BYTE *)(a2 + 0x16);
            if ( v29 == 0x10 )
            {
LABEL_72:
              v28 = 3;
              goto LABEL_122;
            }
LABEL_74:
            v28 = (v29 != 0x20) + 3;
LABEL_122:
            switch ( v11[9] & 0x3F )
            {
              case 1:
                v41 = 2i64;
                break;
              case 2:
                v41 = 4i64;
                break;
              case 3:
                v41 = 1i64;
                break;
              case 4:
                v41 = 3i64;
                break;
              case 5:
                v41 = 8i64;
                break;
              default:
                v40 = a1[0x2F];
LABEL_134:
                result = sub_14006CB7C(a2, v12 + a2 + 0x20, v28, v40);
                if ( (int)result < 0 )
                  return result;
                v26 = *(_DWORD *)(v12 + a2 + 0x24);
                v11 = a6;
                goto LABEL_136;
            }
            v40 = ((__int64 (__fastcall *)(unsigned __int8 *, __int64, __int64, _QWORD))loc_14006B654)(a1, a2, v41, v28);
            goto LABEL_134;
          case 0xAu:
            v28 = (*(_BYTE *)(a2 + 0x16) != 0x10) + 2;
            goto LABEL_122;
          case 0xBu:
            v29 = *(_BYTE *)(a2 + 0x17);
LABEL_68:
            if ( v29 == 0x10 )
            {
LABEL_69:
              v28 = 2;
              goto LABEL_122;
            }
            goto LABEL_74;
          case 0xCu:
            v28 = 5;
            goto LABEL_122;
        }
      }
      v30 = v27 - 0x17;
      if ( !v30 || (v31 = v30 - 1) == 0 || (v32 = v31 - 1) == 0 || (v33 = v32 - 1) == 0 )
      {
        result = sub_14006C8F4((_DWORD **)a1, a2, v12 + a2 + 0x20);
        if ( (int)result < 0 )
          return result;
        goto LABEL_102;
      }
      v34 = v33 - 3;
      if ( v34 )
      {
        v35 = v34 - 1;
        if ( !v35 )
        {
          *(_BYTE *)(v12 + a2 + 0x2C) = 0;
          result = sub_14006C8F4((_DWORD **)a1, a2, v12 + a2 + 0x20);
          if ( (int)result < 0 )
            return result;
          *(_DWORD *)(v12 + a2 + 0x48) = 2;
          goto LABEL_102;
        }
        v36 = v35 - 1;
        if ( v36 )
        {
          if ( v36 == 1 )
          {
            *(_BYTE *)(v12 + a2 + 0x2C) = 0;
            result = sub_14006C8F4((_DWORD **)a1, a2, v12 + a2 + 0x20);
            if ( (int)result < 0 )
              return result;
            *(_DWORD *)(v12 + a2 + 0x48) = 3;
LABEL_102:
            v11 = a6;
            goto LABEL_103;
          }
        }
        else
        {
          *(_DWORD *)(v12 + a2 + 0x24) = 2;
          *(_DWORD *)(v12 + a2 + 0x48) = 1;
          *(_BYTE *)(v12 + a2 + 0x60) = 1;
          *(_QWORD *)(v12 + a2 + 0x68) = *(_QWORD *)(a2 + 0x580);
        }
      }
      else
      {
        *(_DWORD *)(v12 + a2 + 0x24) = 3;
        *(_DWORD *)(v12 + a2 + 0x74) = *(_DWORD *)(a2 + 0x598);
        *(_WORD *)(v12 + a2 + 0x70) = *(_WORD *)(a2 + 0x5B0);
      }
LABEL_103:
      v26 = *(_DWORD *)(v12 + a2 + 0x24);
      if ( !v26 )
      {
        if ( (*v11 & 0x3F) == 0x1B || (*v11 & 0x3F) == 0x1C )
        {
          *(_DWORD *)(v12 + a2 + 0x24) = 4;
          *(_WORD *)(v12 + a2 + 0x34) = 8 * *(_WORD *)&v11[2 * a1[0x24] + 2];
          v38 = 3i64 * v8;
          if ( (v11[9] & 0x3F) == 5 )
            v39 = *(_BYTE *)(a2 + 0x18i64 * v8 + 0x598) & 0xF;
          else
            v39 = *(_QWORD *)(a2 + 0x18i64 * v8 + 0x598);
          *(_QWORD *)(v12 + a2 + 0x80) = v39;
          ++v8;
          *(_BYTE *)(v12 + a2 + 0x78) = *(_BYTE *)(a2 + 8 * v38 + 0x590);
          *(_BYTE *)(v12 + a2 + 0x79) = *(_BYTE *)(a2 + 8 * v38 + 0x591);
        }
        goto LABEL_152;
      }
      if ( (unsigned int)(*(_DWORD *)(a2 + 0xC) - 4) <= 1 && *(_BYTE *)(a2 + 0x588) == 8 )
        *(_QWORD *)(v12 + a2 + 0x68) *= a1[0x3C];
LABEL_136:
      if ( v26 == 2 )
      {
        v42 = *(_QWORD *)(a2 + 0x430);
        if ( _bittest64(&v42, 0x1Cu) )
        {
          *(_DWORD *)(v12 + a2 + 0x4C) = 0xC7;
        }
        else
        {
          if ( !_bittest64(&v42, 0x1Du) )
          {
            if ( _bittest64(&v42, 0x1Eu) )
              goto LABEL_151;
            if ( _bittest64(&v42, 0x1Fu) )
            {
              *(_DWORD *)(v12 + a2 + 0x4C) = 0xC6;
              goto LABEL_152;
            }
            if ( _bittest64(&v42, 0x20u) )
            {
              *(_DWORD *)(v12 + a2 + 0x4C) = 0xCA;
              goto LABEL_152;
            }
            if ( _bittest64(&v42, 0x21u) )
            {
              *(_DWORD *)(v12 + a2 + 0x4C) = 0xCB;
              goto LABEL_152;
            }
            if ( *(_DWORD *)(v12 + a2 + 0x4C) )
              goto LABEL_152;
            v43 = *(int *)(v12 + a2 + 0x50);
            if ( (unsigned int)v43 > 0x3A || (v44 = 0x600060006000000i64, !_bittest64(&v44, v43)) )
            {
LABEL_151:
              *(_DWORD *)(v12 + a2 + 0x4C) = 0xC9;
              goto LABEL_152;
            }
          }
          *(_DWORD *)(v12 + a2 + 0x4C) = 0xC8;
        }
      }
LABEL_152:
      sub_14006E81C((unsigned int **)a1, a2, v12 + a2 + 0x20, (__int64)v11);
      ++v10;
      v11 = a6 + 0xC;
      a6 += 0xC;
    }
    while ( v10 < *(_BYTE *)(a2 + 0x18) );
  }
  if ( *(_DWORD *)(a2 + 0x490) == 2 )
  {
    if ( *(_BYTE *)(a2 + 0x2C) == 2 )
    {
      if ( *(_DWORD *)(a2 + 0x24) == 2 )
      {
        *(_BYTE *)(a2 + 0x2C) = 8;
        return 0x100000i64;
      }
      goto LABEL_156;
    }
    if ( *(_BYTE *)(a2 + 0x2C) == 3 )
    {
LABEL_156:
      *(_BYTE *)(a2 + 0x2C) = 9;
      return 0x100000i64;
    }
  }
  return 0x100000i64;
}
// 14006CBCC: too many cbuild loops
// 14006CD11: variable 'v13' is possibly undefined
// 14006D1B7: variable 'v28' is possibly undefined

//----- (000000014006D2DC) ----------------------------------------------------
#error "14006D4BE: call analysis failed (funcsize=160)"

//----- (000000014006D514) ----------------------------------------------------
__int64 __fastcall sub_14006D514(_BYTE *a1, __int64 a2, _BYTE *a3)
{
  char v3; // r9
  char v4; // r11
  char v5; // al

  *(_QWORD *)(a2 + 0x430) |= 0x10ui64;
  if ( *a3 == 0xC4 )
  {
    *(_BYTE *)(a2 + 0x55B) = 3;
    *(_BYTE *)(a2 + 0x552) = a3[1] >> 7;
    *(_BYTE *)(a2 + 0x553) = (a3[1] & 0x40) != 0;
    *(_BYTE *)(a2 + 0x554) = (a3[1] & 0x20) != 0;
    v4 = a3[1] & 0x1F;
    *(_BYTE *)(a2 + 0x555) = v4;
    v3 = a3[2] >> 7;
    *(_BYTE *)(a2 + 0x556) = v3;
    *(_BYTE *)(a2 + 0x557) = (a3[2] >> 3) & 0xF;
    *(_BYTE *)(a2 + 0x558) = (a3[2] & 4) != 0;
    v5 = a3[2];
  }
  else
  {
    *(_BYTE *)(a2 + 0x55B) = 2;
    v3 = 0;
    v4 = 1;
    *(_BYTE *)(a2 + 0x552) = a3[1] >> 7;
    *(_DWORD *)(a2 + 0x553) = 0x10101;
    *(_BYTE *)(a2 + 0x557) = (a3[1] >> 3) & 0xF;
    *(_BYTE *)(a2 + 0x558) = (a3[1] & 4) != 0;
    v5 = a3[1];
  }
  *(_BYTE *)(a2 + 0x559) = v5 & 3;
  if ( (unsigned __int8)v4 > 3u )
    return 0x80200007i64;
  a1[0x26] = v3;
  a1[0x27] = (*(_BYTE *)(a2 + 0x552) & 1) == 0;
  a1[0x28] = (*(_BYTE *)(a2 + 0x553) & 1) == 0;
  a1[0x29] = (*(_BYTE *)(a2 + 0x554) & 1) == 0;
  a1[0x2A] = *(_BYTE *)(a2 + 0x558);
  a1[0x2B] = *(_BYTE *)(a2 + 0x558);
  a1[0x2E] = ~*(_BYTE *)(a2 + 0x557) & 0xF;
  return 0x100000i64;
}

//----- (000000014006D64C) ----------------------------------------------------
__int64 __fastcall sub_14006D64C(_BYTE *a1, __int64 a2, __int64 a3)
{
  unsigned __int8 v4; // al
  char v5; // cl

  *(_QWORD *)(a2 + 0x430) |= 8ui64;
  *(_BYTE *)(a2 + 0x549) = *(_BYTE *)(a3 + 1) >> 7;
  *(_BYTE *)(a2 + 0x54A) = (*(_BYTE *)(a3 + 1) & 0x40) != 0;
  *(_BYTE *)(a2 + 0x54B) = (*(_BYTE *)(a3 + 1) & 0x20) != 0;
  v4 = *(_BYTE *)(a3 + 1) & 0x1F;
  *(_BYTE *)(a2 + 0x54C) = v4;
  if ( v4 < 8u || v4 > 0xAu )
    return 0x80200007i64;
  v5 = *(_BYTE *)(a3 + 2) >> 7;
  *(_BYTE *)(a2 + 0x54D) = v5;
  *(_BYTE *)(a2 + 0x54E) = (*(_BYTE *)(a3 + 2) >> 3) & 0xF;
  *(_BYTE *)(a2 + 0x54F) = (*(_BYTE *)(a3 + 2) & 4) != 0;
  *(_BYTE *)(a2 + 0x550) = *(_BYTE *)(a3 + 2) & 3;
  a1[0x26] = v5;
  a1[0x27] = (*(_BYTE *)(a2 + 0x549) & 1) == 0;
  a1[0x28] = (*(_BYTE *)(a2 + 0x54A) & 1) == 0;
  a1[0x29] = (*(_BYTE *)(a2 + 0x54B) & 1) == 0;
  a1[0x2A] = *(_BYTE *)(a2 + 0x54F);
  a1[0x2B] = *(_BYTE *)(a2 + 0x54F);
  a1[0x2E] = ~*(_BYTE *)(a2 + 0x54E) & 0xF;
  return 0x100000i64;
}

//----- (000000014006D73C) ----------------------------------------------------
__int64 __fastcall sub_14006D73C(_DWORD *a1, __int64 a2, __int64 a3, _BYTE *a4)
{
  __int64 v6; // rax
  int **v7; // rcx
  __int64 v8; // rax
  _BYTE *v9; // rcx
  __int64 result; // rax
  __int64 v11; // rdx
  __int64 v12; // r8
  __int64 v13; // r9
  int *v14; // [rsp+20h] [rbp-48h] BYREF
  __int64 v15; // [rsp+28h] [rbp-40h]
  __int64 v16; // [rsp+30h] [rbp-38h]
  unsigned __int8 v17; // [rsp+38h] [rbp-30h]

  if ( !a1 || !a4 )
    return 0x80100004i64;
  if ( !a2 || !a3 )
    return 0x80200000i64;
  v6 = 0x40i64;
  v7 = &v14;
  do
  {
    *(_BYTE *)v7 = 0;
    v7 = (int **)((char *)v7 + 1);
    --v6;
  }
  while ( v6 );
  v14 = a1;
  v8 = 0x5C0i64;
  v15 = a2;
  v9 = a4;
  v16 = a3;
  do
  {
    *v9++ = 0;
    --v8;
  }
  while ( v8 );
  *(_DWORD *)a4 = *a1;
  a4[0x15] = byte_140070830[a1[1]];
  result = sub_14006BBB0((__int64)&v14, (__int64)a4);
  if ( (int)result >= 0 )
  {
    sub_14006BF98(&v14, v11, v12, v13, (__int64)v14, v15, v16, v17);
    JUMPOUT(0x14006D7D5i64);
  }
  return result;
}
// 14006D7D0: control flows out of bounds to 14006D7D5
// 14006D7C9: variable 'v11' is possibly undefined
// 14006D7C9: variable 'v12' is possibly undefined
// 14006D7C9: variable 'v13' is possibly undefined

//----- (000000014006D844) ----------------------------------------------------
__int64 __fastcall sub_14006D844(__int64 a1, __int64 a2, _BYTE *a3)
{
  __int64 result; // rax

  if ( *(_BYTE *)(a2 + 8) >= 0xFu )
    return 0x80200002i64;
  if ( !*(_QWORD *)(a1 + 0x10) )
    return 0x80200000i64;
  result = 0x100000i64;
  *a3 = *(_BYTE *)(*(_QWORD *)(a1 + 8))++;
  ++*(_BYTE *)(a2 + 8);
  --*(_QWORD *)(a1 + 0x10);
  return result;
}

//----- (000000014006D87C) ----------------------------------------------------
__int64 __fastcall sub_14006D87C(__int64 a1, __int64 a2, _BYTE *a3, __int64 a4)
{
  int v4; // ebx
  __int64 v7; // r8
  char *v8; // rdx
  char v9; // al

  v4 = *(unsigned __int8 *)(a2 + 8);
  if ( v4 + (unsigned int)(unsigned __int8)a4 > 0xF )
    return 0x80200002i64;
  v7 = (unsigned __int8)a4;
  if ( *(_QWORD *)(a1 + 0x10) < (unsigned __int64)(unsigned __int8)a4 )
    return 0x80200000i64;
  a4 = (unsigned __int8)a4;
  *(_BYTE *)(a2 + 8) = a4 + v4;
  v8 = *(char **)(a1 + 8);
  if ( (_BYTE)a4 )
  {
    do
    {
      v9 = *v8++;
      *a3++ = v9;
      --a4;
    }
    while ( a4 );
    v8 = *(char **)(a1 + 8);
  }
  *(_QWORD *)(a1 + 0x10) -= v7;
  *(_QWORD *)(a1 + 8) = &v8[v7];
  return 0x100000i64;
}

//----- (000000014006D8EC) ----------------------------------------------------
__int64 __fastcall sub_14006D8EC(__int64 a1, __int64 a2, _WORD *a3, __int64 a4, __int64 _30, unsigned __int8 arg8)
{
  __int64 result; // rax
  unsigned __int8 v8; // cl

  if ( !*(_BYTE *)(a2 + 0x57B) )
  {
    *(_BYTE *)(a2 + 0x57B) = *(_BYTE *)(a2 + 8);
    result = sub_14006D844(a1, a2, &arg8);
    if ( (int)result < 0 )
      return result;
    v8 = arg8;
    *(_QWORD *)(a2 + 0x430) |= 1ui64;
    *(_BYTE *)(a2 + 0x578) = v8 >> 6;
    *(_BYTE *)(a2 + 0x579) = (v8 >> 3) & 7;
    *(_BYTE *)(a2 + 0x57A) = v8 & 7;
  }
  *a3 = *(unsigned __int8 *)(a2 + 0x578);
  return 0x100000i64;
}
// 14006D917: variable 'a2' is possibly undefined
// 14006D947: variable 'a3' is possibly undefined

//----- (000000014006D958) ----------------------------------------------------
__int64 __fastcall sub_14006D958(__int64 a1, __int64 a2, _WORD *a3, __int64 a4, __int64 a5, int a6)
{
  int v7; // ecx
  char *v10; // rsi
  __int64 result; // rax
  __int64 v12; // rdx
  __int64 v13; // r9
  int v14; // ecx
  char v15; // al
  int v16; // edx
  unsigned __int8 v17; // r8
  unsigned __int8 v18; // dl
  _BYTE *v19; // rcx
  int v20; // eax
  __int64 v21; // rcx
  char v22; // al

  v7 = *(_DWORD *)(a2 + 0xC);
  if ( v7 )
  {
    if ( v7 == 1 )
    {
      *a3 = 0xC;
      return 0x100000i64;
    }
    v10 = (char *)(a2 + 0x14);
    result = sub_14006D844(a1, a2, (_BYTE *)(a2 + 0x14));
    if ( (int)result < 0 )
      return result;
LABEL_60:
    *a3 = (unsigned __int8)*v10;
    return 0x100000i64;
  }
  v10 = (char *)(a2 + 0x14);
  result = sub_14006D844(a1, a2, (_BYTE *)(a2 + 0x14));
  if ( (int)result < 0 )
    return result;
  v14 = *(_DWORD *)(v12 + 0x10);
  if ( v14 )
  {
    if ( v14 != 1 )
      goto LABEL_60;
    v15 = *v10;
    if ( *v10 != 0xF )
    {
      if ( v15 == 0x38 )
      {
        *(_DWORD *)(v12 + 0x10) = 2;
      }
      else if ( v15 == 0x3A )
      {
        *(_DWORD *)(v12 + 0x10) = 3;
      }
      goto LABEL_60;
    }
    if ( !*(_BYTE *)(a1 + 0x18) )
    {
      *(_DWORD *)(v12 + 0xC) = 1;
      *(_DWORD *)(v12 + 0x10) = 4;
      goto LABEL_60;
    }
    return 0x80200004i64;
  }
  v16 = (unsigned __int8)*v10;
  if ( (_BYTE)v16 == 0xF )
  {
    *(_DWORD *)(a2 + 0x10) = 1;
    goto LABEL_60;
  }
  if ( (_BYTE)v16 == 0x62 )
  {
LABEL_20:
    v17 = *(_BYTE *)(a2 + 8);
    if ( v17 < 0xFu )
    {
      if ( *(_QWORD *)(a1 + 0x10) )
      {
        if ( (**(_BYTE **)(a1 + 8) & 0xF0u) < 0xC0 && **(_DWORD **)a1 )
          goto LABEL_60;
        if ( (*(_BYTE *)(a2 + 0x430) & 4) != 0 )
          return 0x80200006i64;
        if ( *(_BYTE *)(a1 + 0x18) )
          return 0x80200004i64;
        if ( *(_BYTE *)(a1 + 0x1C) )
          return 0x80200005i64;
        LOBYTE(a6) = *v10;
        *(_WORD *)((char *)&a6 + 1) = 0;
        HIBYTE(a6) = 0;
        if ( v16 == 0x62 )
        {
          LOBYTE(v13) = 3;
          v21 = a1;
        }
        else
        {
          *(_BYTE *)(a2 + 0x55A) = v17 - 1;
          v21 = a1;
          if ( v16 != 0xC4 )
          {
            result = sub_14006D844(a1, a2, (_BYTE *)&a6 + 1);
            goto LABEL_46;
          }
          LOBYTE(v13) = 2;
        }
        result = sub_14006D87C(v21, a2, (_BYTE *)&a6 + 1, v13);
LABEL_46:
        if ( (int)result < 0 )
          return result;
        if ( *v10 != 0x62 )
        {
          *(_DWORD *)(a2 + 0xC) = 3;
          result = sub_14006D514((_BYTE *)a1, a2, &a6);
          if ( (int)result < 0 )
            return result;
          v20 = *(unsigned __int8 *)(a2 + 0x555);
          goto LABEL_36;
        }
        v22 = *(_BYTE *)(a2 + 8);
        if ( ((BYTE2(a6) >> 2) & 1) != 0 )
        {
          *(_DWORD *)(a2 + 0xC) = 4;
          *(_BYTE *)(a2 + 0x56A) = v22 - 4;
          result = sub_14006BDD4(a1, a2, &a6);
          if ( (int)result < 0 )
            return result;
          v20 = *(unsigned __int8 *)(a2 + 0x560);
          goto LABEL_36;
        }
        *(_BYTE *)(a2 + 0x577) = v22 - 4;
        if ( **(_DWORD **)a1 )
          return 0x80200001i64;
        *(_DWORD *)(a2 + 0xC) = 5;
        result = sub_14006C7A8((_BYTE *)a1, a2, &a6);
        if ( (int)result >= 0 )
        {
          v20 = *(unsigned __int8 *)(a2 + 0x56F);
          goto LABEL_36;
        }
        return result;
      }
      return 0x80200000i64;
    }
    return 0x80200002i64;
  }
  if ( (_BYTE)v16 != 0x8F )
  {
    if ( (unsigned __int8)(v16 + 0x3C) > 1u )
      goto LABEL_60;
    goto LABEL_20;
  }
  v18 = *(_BYTE *)(a2 + 8);
  if ( v18 >= 0xFu )
    return 0x80200002i64;
  if ( !*(_QWORD *)(a1 + 0x10) )
    return 0x80200000i64;
  if ( (**(_BYTE **)(a1 + 8) & 0x1Fu) < 8 )
    goto LABEL_60;
  if ( (*(_BYTE *)(a2 + 0x430) & 4) != 0 )
    return 0x80200006i64;
  if ( *(_BYTE *)(a1 + 0x18) )
    return 0x80200004i64;
  if ( *(_BYTE *)(a1 + 0x1C) )
    return 0x80200005i64;
  LOWORD(a6) = 0x8F;
  *(_BYTE *)(a2 + 0x551) = v18 - 1;
  BYTE2(a6) = 0;
  LOBYTE(v13) = 2;
  result = sub_14006D87C(a1, a2, (_BYTE *)&a6 + 1, v13);
  if ( (int)result >= 0 )
  {
    *(_DWORD *)(a2 + 0xC) = 2;
    result = sub_14006D64C(v19, a2, (__int64)&a6);
    if ( (int)result >= 0 )
    {
      v20 = *(unsigned __int8 *)(a2 + 0x54C) - 3;
LABEL_36:
      *(_DWORD *)(a2 + 0x10) = v20;
      goto LABEL_60;
    }
  }
  return result;
}
// 14006D9CC: variable 'v12' is possibly undefined
// 14006DAEB: variable 'v13' is possibly undefined
// 14006DB06: variable 'v19' is possibly undefined

//----- (000000014006DC70) ----------------------------------------------------
__int64 __fastcall sub_14006DC70(__int64 a1, __int64 a2, char a3, __int64 a4, __int64 _30, __int64 arg8, int arg10)
{
  char v7; // al
  __int64 result; // rax
  __int64 v10; // rax
  __int64 v11; // rdx

  v7 = *(_BYTE *)(a2 + 8);
  LOBYTE(a4) = 8;
  *(_BYTE *)(a2 + 0x588) = a3;
  *(_BYTE *)(a2 + 0x589) = v7;
  if ( a3 == 8 )
  {
    result = sub_14006D844(a1, a2, &arg10);
    if ( (int)result < 0 )
      return result;
    *(_QWORD *)(v11 + 0x580) = (char)arg10;
  }
  else
  {
    if ( a3 == 0x10 )
    {
      LOBYTE(a4) = 2;
      result = sub_14006D87C(a1, a2, &arg10, a4);
      if ( (int)result < 0 )
        return result;
      v10 = (__int16)arg10;
    }
    else if ( a3 == 0x20 )
    {
      LOBYTE(a4) = 4;
      result = sub_14006D87C(a1, a2, &arg10, a4);
      if ( (int)result < 0 )
        return result;
      v10 = arg10;
    }
    else
    {
      result = sub_14006D87C(a1, a2, &arg8, a4);
      if ( (int)result < 0 )
        return result;
      v10 = arg8;
    }
    *(_QWORD *)(a2 + 0x580) = v10;
  }
  return 0x100000i64;
}
// 14006DCFE: variable 'v11' is possibly undefined

//----- (000000014006DD10) ----------------------------------------------------
__int64 __fastcall sub_14006DD10(__int64 a1, __int64 a2, unsigned __int8 a3, __int64 a4, __int64 a5, __int64 a6, __int64 a7, __int64 a8, unsigned int a9, char a10)
{
  char v10; // si
  __int64 v12; // rdi
  __int64 result; // rax
  __int64 v14; // rax
  __int64 v15; // rdx
  __int64 v16; // rax

  v10 = a9;
  v12 = 3i64 * a3;
  *(_BYTE *)(a2 + 0x18i64 * a3 + 0x5A0) = a4;
  *(_BYTE *)(a2 + 8 * v12 + 0x5A1) = *(_BYTE *)(a2 + 8);
  *(_BYTE *)(a2 + 8 * v12 + 0x591) = a10;
  *(_BYTE *)(a2 + 8 * v12 + 0x590) = v10;
  if ( (_BYTE)a4 == 8 )
  {
    result = sub_14006D844(a1, a2, &a9);
    if ( (int)result < 0 )
      return result;
    v16 = (char)a9;
    if ( !v10 )
      v16 = (unsigned __int8)a9;
    *(_QWORD *)(v15 + 8 * v12 + 0x598) = v16;
  }
  else
  {
    if ( (_BYTE)a4 == 0x10 )
    {
      LOBYTE(a4) = 2;
      result = sub_14006D87C(a1, a2, &a9, a4);
      if ( (int)result < 0 )
        return result;
      v14 = (__int16)a9;
      if ( !v10 )
        v14 = (unsigned __int16)a9;
    }
    else if ( (_BYTE)a4 == 0x20 )
    {
      LOBYTE(a4) = 4;
      result = sub_14006D87C(a1, a2, &a9, a4);
      if ( (int)result < 0 )
        return result;
      if ( v10 )
        v14 = (int)a9;
      else
        v14 = a9;
    }
    else
    {
      LOBYTE(a4) = 8;
      result = sub_14006D87C(a1, a2, &a6, a4);
      if ( (int)result < 0 )
        return result;
      v14 = a6;
    }
    *(_QWORD *)(a2 + 8 * v12 + 0x598) = v14;
  }
  return 0x100000i64;
}
// 14006DDF2: variable 'v15' is possibly undefined

//----- (000000014006DE10) ----------------------------------------------------
unsigned __int64 __fastcall sub_14006DE10(__int64 a1, __int64 a2, unsigned __int8 *a3)
{
  unsigned __int64 result; // rax
  unsigned __int8 v6; // r8
  unsigned int v7; // ecx
  char v8; // al
  unsigned int v9; // ecx
  unsigned int v10; // ecx
  unsigned int v11; // ecx
  unsigned int v12; // ecx
  unsigned int v13; // ecx
  unsigned int v14; // ecx
  bool v15; // zf
  int v16; // ecx
  bool v17; // zf
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  unsigned int v21; // ecx
  unsigned int v22; // ecx
  unsigned int v23; // ecx
  unsigned int v24; // ecx
  void *retaddr; // [rsp+10h] [rbp+0h] BYREF

  result = (unsigned __int64)&retaddr;
  switch ( *(_DWORD *)(a2 + 0xC) )
  {
    case 2:
      result = (unsigned __int16)word_1400705C8[*(unsigned __int8 *)(a1 + 0x2B)];
      *(_WORD *)(a2 + 0x48C) = result;
      return result;
    case 3:
      result = (unsigned __int16)word_1400705CC[*(unsigned __int8 *)(a1 + 0x2B)];
      *(_WORD *)(a2 + 0x48C) = result;
      if ( a3[0xD] >= 0x20u )
      {
        *(_BYTE *)(a2 + 0x498) = 1;
        result = (unsigned int)dword_1400D8008[(unsigned __int64)a3[0xD] >> 5];
        *(_DWORD *)(a2 + 0x49C) = result;
      }
      break;
    case 4:
      JUMPOUT(0x14006E1FDi64);
    case 5:
      *(_WORD *)(a2 + 0x48C) = 0x200;
      v6 = a3[0xE] >> 7;
      if ( !v6 && (a3[0xF] & 7) != 0 )
      {
        *(_BYTE *)(a2 + 0x498) = 1;
        if ( (a3[0xF] & 7) == 1 )
        {
          *(_DWORD *)(a2 + 0x49C) = 3;
        }
        else
        {
          if ( (a3[0xF] & 7) != 2 )
          {
            v6 = 2;
            if ( (a3[0xF] & 7) == 3 )
              *(_DWORD *)(a2 + 0x49C) = 0xA;
            else
              *(_DWORD *)(a2 + 0x49C) = 0xB;
            goto LABEL_15;
          }
          *(_DWORD *)(a2 + 0x49C) = 4;
        }
        v6 = 1;
      }
LABEL_15:
      v7 = a3[0xE] & 0x1F;
      if ( v7 > 0x12 )
      {
        v10 = v7 - 0x13;
        if ( !v10 )
          goto LABEL_23;
        v11 = v10 - 1;
        if ( v11 )
        {
          v12 = v11 - 1;
          if ( v12 )
          {
            v13 = v12 - 1;
            if ( !v13 || (v14 = v13 - 1) != 0 && v14 == 1 )
              v8 = byte_140070698[8 * v6 + 0x40 + *(unsigned __int8 *)(a2 + 0x574)];
            else
              v8 = byte_140070698[v6 + 0x50 + (unsigned __int64)*(unsigned __int8 *)(a2 + 0x574)];
            goto LABEL_24;
          }
          goto LABEL_23;
        }
      }
      else
      {
        if ( v7 == 0x12 )
          goto LABEL_36;
        if ( v7 <= 3 )
          goto LABEL_25;
        if ( v7 <= 7 )
        {
          *(_BYTE *)(a1 + 0x3C) = 0x40;
LABEL_25:
          *(_DWORD *)(a1 + 0x38) = a3[0xE] & 0x1F;
          v9 = a3[0xE] & 0x1F;
          if ( v9 <= 0x10 )
          {
            if ( v9 < 0xE )
            {
              if ( v9 == 2 )
              {
                *(_DWORD *)(a2 + 0x4A0) = *(unsigned __int8 *)(a2 + 0x574) + 1;
                goto LABEL_77;
              }
              if ( v9 == 3 )
              {
                if ( *(_BYTE *)(a2 + 0x574) >= 4u )
                  *(_BYTE *)(a2 + 0x4AC) = 1;
                goto LABEL_77;
              }
              if ( v9 <= 7 )
              {
LABEL_77:
                if ( *(_BYTE *)(a2 + 0x578) != 3 )
                {
                  if ( *(_BYTE *)(a2 + 0x573) )
                    *(_BYTE *)(a2 + 0x4AD) = 1;
                }
                result = (unsigned int)*(unsigned __int8 *)(a2 + 0x576) + 0xF8;
                *(_DWORD *)(a2 + 0x490) = 2;
                *(_DWORD *)(a2 + 0x494) = result;
                return result;
              }
              if ( v9 <= 9 )
              {
                *(_DWORD *)(a2 + 0x4A4) = *(unsigned __int8 *)(a2 + 0x574) + 1;
                goto LABEL_77;
              }
              if ( v9 > 0xC )
                goto LABEL_32;
              if ( *(_BYTE *)(a2 + 0x574) != 1 )
              {
                if ( *(_BYTE *)(a2 + 0x574) != 2 )
                {
                  v16 = *(unsigned __int8 *)(a2 + 0x574) - 3;
                  v15 = *(_BYTE *)(a2 + 0x574) == 3;
LABEL_49:
                  if ( !v15 )
                  {
                    v18 = v16 - 1;
                    v17 = v18 == 0;
                    goto LABEL_51;
                  }
                  *(_DWORD *)(a2 + 0x4A8) = 1;
                  goto LABEL_77;
                }
LABEL_58:
                *(_DWORD *)(a2 + 0x49C) = 0xB;
                goto LABEL_77;
              }
LABEL_59:
              *(_DWORD *)(a2 + 0x49C) = 4;
              goto LABEL_77;
            }
            if ( *(_BYTE *)(a2 + 0x574) == 1 )
              goto LABEL_59;
            if ( *(_BYTE *)(a2 + 0x574) == 2 )
              goto LABEL_58;
            v18 = *(unsigned __int8 *)(a2 + 0x574) - 4;
            v17 = *(_BYTE *)(a2 + 0x574) == 4;
LABEL_51:
            if ( v17 )
            {
              *(_DWORD *)(a2 + 0x4A8) = 3;
            }
            else
            {
              v19 = v18 - 1;
              if ( v19 )
              {
                v20 = v19 - 1;
                if ( v20 )
                {
                  if ( v20 == 1 )
                    *(_DWORD *)(a2 + 0x4A8) = 4;
                }
                else
                {
                  *(_DWORD *)(a2 + 0x4A8) = 5;
                }
              }
              else
              {
                *(_DWORD *)(a2 + 0x4A8) = 2;
              }
            }
            goto LABEL_77;
          }
          v21 = v9 - 0x11;
          if ( !v21 )
          {
LABEL_32:
            if ( *(_BYTE *)(a2 + 0x574) == 1 )
            {
              *(_DWORD *)(a2 + 0x49C) = 3;
            }
            else if ( *(_BYTE *)(a2 + 0x574) == 2 )
            {
              *(_DWORD *)(a2 + 0x49C) = 0xA;
            }
            goto LABEL_77;
          }
          v22 = v21 - 1;
          if ( v22 )
          {
            v23 = v22 - 2;
            if ( !v23 )
            {
LABEL_72:
              v18 = *(unsigned __int8 *)(a2 + 0x574) - 4;
              v17 = *(_BYTE *)(a2 + 0x574) == 4;
              goto LABEL_51;
            }
            v24 = v23 - 2;
            if ( v24 )
            {
              if ( v24 != 2 )
                goto LABEL_77;
              goto LABEL_72;
            }
          }
          v16 = *(unsigned __int8 *)(a2 + 0x574) - 3;
          v15 = *(_BYTE *)(a2 + 0x574) == 3;
          goto LABEL_49;
        }
        if ( v7 <= 9 )
          goto LABEL_25;
        if ( v7 <= 0xC )
        {
LABEL_36:
          v8 = byte_140070698[8 * v6 + *(unsigned __int8 *)(a2 + 0x574)];
          goto LABEL_24;
        }
        if ( v7 == 0xD || v7 > 0x10 )
        {
LABEL_23:
          v8 = byte_140070698[3 * v6 + 0x30 + *(unsigned __int8 *)(a2 + 0x574)];
LABEL_24:
          *(_BYTE *)(a1 + 0x3C) = v8;
          goto LABEL_25;
        }
      }
      v8 = byte_140070698[8 * v6 + 0x18 + *(unsigned __int8 *)(a2 + 0x574)];
      goto LABEL_24;
  }
  return result;
}
// 14006E1F8: control flows out of bounds to 14006E1FD
// 14006DF88: conditional instruction was optimized away because of 'ecx.4==D'

//----- (000000014006E4A8) ----------------------------------------------------
char __fastcall sub_14006E4A8(_BYTE *a1, __int64 a2, _BYTE *a3)
{
  unsigned __int8 v3; // al
  __int64 v5; // rax
  char v6; // al
  int v7; // ecx
  __int64 v8; // rcx
  __int64 v9; // rcx
  __int64 v10; // rcx
  __int64 v11; // rcx
  char v12; // cl
  __int64 v13; // rax
  int v14; // ecx
  int v15; // ecx
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx

  v3 = a3[0xC];
  if ( (v3 & 3) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= qword_140070568[a3[0xC] & 3];
    v3 = a3[0xC];
  }
  if ( (v3 & 0xC) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= qword_140070588[((unsigned __int64)v3 >> 2) & 3];
    v3 = a3[0xC];
  }
  if ( (v3 & 0x30) != 0 )
    *(_QWORD *)(a2 + 0x430) |= qword_1400705A8[((unsigned __int64)v3 >> 4) & 3];
  if ( *(_DWORD *)(a2 + 0xC) )
  {
    LODWORD(v5) = (unsigned __int8)a1[0x1B];
    if ( !(_BYTE)v5 )
      return v5;
    switch ( (_DWORD)v5 )
    {
      case '&':
        v5 = 0x80000000i64;
        break;
      case '.':
        *(_QWORD *)(a2 + 0x430) |= 0x10000000ui64;
        goto LABEL_21;
      case '6':
        *(_QWORD *)(a2 + 0x430) |= 0x20000000ui64;
        goto LABEL_21;
      case '>':
        *(_QWORD *)(a2 + 0x430) |= 0x40000000ui64;
        goto LABEL_21;
      case 'd':
        v5 = 0x100000000i64;
        break;
      default:
        v5 = 0x200000000i64;
        break;
    }
    *(_QWORD *)(a2 + 0x430) |= v5;
LABEL_21:
    if ( (*(_QWORD *)(a2 + 0x430) & 0x3F0000000i64) != 0 )
      goto LABEL_88;
    return v5;
  }
  v6 = a3[0xC];
  if ( (v6 & 0x40) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x100ui64;
    v6 = a3[0xC];
  }
  if ( v6 < 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x200ui64;
    if ( a1[0x18] )
    {
      *(_QWORD *)(a2 + 0x430) |= 0x80000ui64;
      *(_DWORD *)(a2 + 8i64 * (unsigned __int8)a1[0x1D] + 0x4CC) = 1;
    }
  }
  LOBYTE(v5) = a3[0xD];
  if ( (v5 & 1) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x400ui64;
    LOBYTE(v5) = a3[0xD];
  }
  if ( (v5 & 2) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x800ui64;
    LOBYTE(v5) = a3[0xD];
  }
  if ( (v5 & 4) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x1000ui64;
    LOBYTE(v5) = a3[0xD];
  }
  if ( (v5 & 8) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x2000ui64;
    LOBYTE(v5) = a3[0xD];
  }
  if ( (v5 & 0x10) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x4000ui64;
    LOBYTE(v5) = a3[0xD];
  }
  if ( (v5 & 0x20) != 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x8000ui64;
    LOBYTE(v5) = a3[0xD];
  }
  if ( (v5 & 0x40) != 0 )
    *(_QWORD *)(a2 + 0x430) |= 0x10000ui64;
  v7 = (unsigned __int8)a1[0x19] - 0xF2;
  if ( (unsigned __int8)a1[0x19] == 0xF2 )
  {
    v10 = *(_QWORD *)(a2 + 0x430);
    if ( _bittest64(&v10, 0xCu) )
    {
      v9 = v10 | 0x400000;
      goto LABEL_61;
    }
    if ( _bittest64(&v10, 0xEu) && ((v10 & 0x80000) != 0 || (a3[0xD] & 0x40) != 0) )
    {
      v9 = v10 | 0x1000000;
      goto LABEL_61;
    }
    v5 = *(_QWORD *)a1;
    if ( *(_BYTE *)(*(_QWORD *)a1 + 0xBi64) && _bittest64(&v10, 0xDu) )
    {
      v9 = v10 | 0x800000;
      goto LABEL_61;
    }
  }
  else if ( v7 == 1 )
  {
    v8 = *(_QWORD *)(a2 + 0x430);
    if ( _bittest64(&v8, 0xAu) )
    {
      v9 = v8 | 0x100000;
LABEL_61:
      *(_QWORD *)(a2 + 0x430) = v9;
      goto LABEL_62;
    }
    if ( _bittest64(&v8, 0xBu) )
    {
      v9 = v8 | 0x200000;
      goto LABEL_61;
    }
    if ( _bittest64(&v8, 0xFu) && ((v8 & 0x80000) != 0 || (a3[0xD] & 0x40) != 0) )
    {
      v9 = v8 | 0x2000000;
      goto LABEL_61;
    }
  }
LABEL_62:
  v11 = (unsigned __int8)a1[0x1E];
  if ( !*(_DWORD *)(a2 + 8 * v11 + 0x4CC) )
  {
    LODWORD(v5) = *(_DWORD *)(a2 + 0x430);
    if ( (v5 & 0x3F00000) != 0 )
      *(_DWORD *)(a2 + 8 * v11 + 0x4CC) = 1;
  }
  if ( (char)a3[0xD] < 0 )
  {
    *(_QWORD *)(a2 + 0x430) |= 0x20000ui64;
    v12 = a1[0x1A];
    v5 = *(_QWORD *)(a2 + 0x430);
    if ( v12 == 0x2E )
    {
      v13 = v5 | 0x4000000;
    }
    else
    {
      if ( v12 != 0x3E )
        return v5;
      v13 = v5 | 0x8000000;
    }
    *(_QWORD *)(a2 + 0x430) = v13;
    v5 = (unsigned __int8)a1[0x1F];
LABEL_89:
    *(_DWORD *)(a2 + 8 * v5 + 0x4CC) = 1;
    return v5;
  }
  if ( (a3[0xE] & 1) != 0 )
    *(_QWORD *)(a2 + 0x430) |= 0x40000ui64;
  v14 = (unsigned __int8)a1[0x1B];
  if ( !(_BYTE)v14 || (a3[0xE] & 1) == 0 )
    goto LABEL_87;
  v15 = v14 - 0x26;
  if ( v15 )
  {
    v16 = v15 - 8;
    if ( !v16 )
    {
      *(_QWORD *)(a2 + 0x430) |= 0x10000000ui64;
      goto LABEL_87;
    }
    v17 = v16 - 8;
    if ( !v17 )
    {
      *(_QWORD *)(a2 + 0x430) |= 0x20000000ui64;
      goto LABEL_87;
    }
    v18 = v17 - 8;
    if ( !v18 )
    {
      *(_QWORD *)(a2 + 0x430) |= 0x40000000ui64;
      goto LABEL_87;
    }
    if ( v18 == 0x26 )
      v5 = 0x100000000i64;
    else
      v5 = 0x200000000i64;
  }
  else
  {
    v5 = 0x80000000i64;
  }
  *(_QWORD *)(a2 + 0x430) |= v5;
LABEL_87:
  if ( (*(_QWORD *)(a2 + 0x430) & 0x3F0000000i64) != 0 )
  {
LABEL_88:
    v5 = (unsigned __int8)a1[0x22];
    goto LABEL_89;
  }
  return v5;
}

//----- (000000014006E81C) ----------------------------------------------------
__int64 __fastcall sub_14006E81C(unsigned int **a1, __int64 a2, __int64 a3, __int64 a4)
{
  __int16 *v7; // rbx
  __int16 v8; // cx
  __int16 v9; // cx
  int v10; // eax
  int v11; // ecx
  int v12; // ecx
  int v13; // ecx
  int v14; // ecx
  __int16 v15; // ax
  int v16; // ecx
  int v17; // ecx
  int v18; // ecx
  int v19; // ecx
  int v20; // ecx
  int v21; // ecx
  int v22; // ecx
  int v23; // ecx
  int v24; // ecx
  int v25; // ecx
  int v26; // ecx
  int v27; // ecx
  __int16 v28; // ax
  __int16 v29; // ax
  unsigned int v30; // ecx
  unsigned int v31; // eax
  __int64 result; // rax

  v7 = (__int16 *)(a3 + 0x14);
  if ( *(_DWORD *)(a3 + 4) == 1 )
  {
    v28 = *(_WORD *)(a4 + 2i64 * *((unsigned __int8 *)a1 + 0x24) + 2);
    if ( v28 )
      v29 = 8 * v28;
    else
      v29 = sub_14006B588(**a1, *(_DWORD *)(a3 + 0x20));
    *v7 = v29;
    *(_WORD *)(a3 + 0x1C) = v29;
    goto LABEL_63;
  }
  if ( *(_DWORD *)(a3 + 4) != 2 )
  {
    if ( *(_DWORD *)(a3 + 4) == 3 )
    {
      v9 = *(unsigned __int8 *)(a2 + 0x5A0) + *(unsigned __int8 *)(a2 + 0x5B8);
LABEL_58:
      *v7 = v9;
      goto LABEL_64;
    }
    v8 = *(_WORD *)(a4 + 2i64 * *((unsigned __int8 *)a1 + 0x24) + 2);
LABEL_57:
    v9 = 8 * v8;
    goto LABEL_58;
  }
  v10 = *(_DWORD *)(a2 + 0xC);
  if ( v10 <= 3 )
  {
    if ( *(_DWORD *)(a3 + 0x28) != 2 )
    {
      v8 = *(_WORD *)(a4 + 2i64 * *((unsigned __int8 *)a1 + 0x24) + 2);
      goto LABEL_57;
    }
    *v7 = *(unsigned __int8 *)(a2 + 0x17);
LABEL_63:
    *(_DWORD *)(a3 + 0x18) = 3;
    goto LABEL_64;
  }
  v8 = *(_WORD *)(a4 + 2i64 * *((unsigned __int8 *)a1 + 0x24) + 2);
  if ( v10 == 4 )
  {
    if ( v8 )
      goto LABEL_57;
    if ( *((_DWORD *)a1 + 0xC) == 1 )
    {
      if ( !*(_DWORD *)(a2 + 0x49C) )
      {
        v15 = *(_WORD *)(a2 + 0x48C);
        goto LABEL_51;
      }
    }
    else if ( !*(_DWORD *)(a2 + 0x49C) )
    {
      v15 = *(_WORD *)(a2 + 0x48C) >> 1;
      goto LABEL_51;
    }
    v15 = *((unsigned __int8 *)a1 + 0x34);
LABEL_51:
    *v7 = v15;
    goto LABEL_64;
  }
  if ( v8 )
    goto LABEL_57;
  v11 = *(_DWORD *)(a2 + 0x4A8);
  if ( !v11 )
  {
    *v7 = 0x200;
    v16 = *((_DWORD *)a1 + 0xE);
    if ( v16 > 0x12 )
    {
      v23 = v16 - 0x13;
      if ( !v23 )
        goto LABEL_40;
      v24 = v23 - 1;
      if ( !v24 )
        goto LABEL_29;
      v25 = v24 - 1;
      if ( !v25 )
        goto LABEL_39;
      v26 = v25 - 1;
      if ( v26 )
      {
        v22 = v26 - 1;
        if ( v22 )
        {
LABEL_38:
          if ( v22 == 1 )
            goto LABEL_29;
LABEL_39:
          *(_DWORD *)(a3 + 0x18) = 3;
LABEL_41:
          v15 = 0x40;
          goto LABEL_42;
        }
LABEL_40:
        *(_DWORD *)(a3 + 0x18) = 6;
        goto LABEL_41;
      }
    }
    else if ( v16 != 0x12 )
    {
      v17 = v16 - 0xA;
      if ( v17 )
      {
        v18 = v17 - 1;
        if ( v18 )
        {
          v19 = v18 - 1;
          if ( v19 )
          {
            v20 = v19 - 1;
            if ( v20 )
            {
              v21 = v20 - 1;
              if ( !v21 )
              {
LABEL_29:
                *(_DWORD *)(a3 + 0x18) = 3;
LABEL_30:
                v15 = 0x20;
                goto LABEL_42;
              }
              v22 = v21 - 1;
              if ( !v22 )
              {
                *v7 = 0x100;
                goto LABEL_29;
              }
              goto LABEL_38;
            }
            goto LABEL_40;
          }
        }
        else
        {
          *v7 = 0x100;
        }
      }
    }
    *(_DWORD *)(a3 + 0x18) = 5;
    goto LABEL_30;
  }
  v12 = v11 - 1;
  if ( !v12 )
  {
    *(_DWORD *)(a3 + 0x18) = 4;
    *v7 = 0x100;
    v15 = 0x10;
    goto LABEL_42;
  }
  v13 = v12 - 1;
  if ( !v13 )
  {
    *(_DWORD *)(a3 + 0x18) = 3;
    goto LABEL_17;
  }
  v14 = v13 - 1;
  if ( !v14 )
  {
    *(_DWORD *)(a3 + 0x18) = 2;
LABEL_17:
    *v7 = 0x80;
    v15 = 8;
LABEL_42:
    *(_WORD *)(a3 + 0x1C) = v15;
    goto LABEL_43;
  }
  *v7 = 0x100;
  v15 = 0x10;
  *(_WORD *)(a3 + 0x1C) = 0x10;
  if ( v14 == 1 )
    *(_DWORD *)(a3 + 0x18) = 3;
  else
    *(_DWORD *)(a3 + 0x18) = 2;
LABEL_43:
  v27 = *(_DWORD *)(a2 + 0x49C);
  if ( v27 )
  {
    if ( v27 > 4 )
      v15 *= 4;
    goto LABEL_51;
  }
LABEL_64:
  if ( (*(_BYTE *)(a4 + 8) & 0x1Fu) >= 2 )
  {
    sub_14006EE04(*(_BYTE *)(a4 + 8) & 0x1F, (_DWORD *)(a3 + 0x18), (_WORD *)(a3 + 0x1C));
    if ( !*(_WORD *)(a3 + 0x1C) )
      *(_WORD *)(a3 + 0x1C) = *v7;
  }
  v30 = *(unsigned __int16 *)(a3 + 0x1C);
  if ( (_WORD)v30 && (v31 = (unsigned __int16)*v7, (_WORD)v31) && *(_DWORD *)(a3 + 0x18) != 9 )
    result = v31 / v30;
  else
    result = 1i64;
  *(_WORD *)(a3 + 0x1E) = result;
  return result;
}

//----- (000000014006EABC) ----------------------------------------------------
char *__fastcall sub_14006EABC(unsigned __int8 *a1, unsigned __int16 a2)
{
  unsigned int v2; // er8
  unsigned int v3; // er8
  unsigned int v4; // er8
  unsigned int v5; // er8
  unsigned int v6; // er8
  __int64 v7; // rax
  char *v8; // rcx
  unsigned int v9; // er8
  unsigned int v10; // er8
  unsigned int v11; // er8
  unsigned int v12; // er8
  __int64 v13; // rax
  unsigned int v14; // er8
  unsigned int v15; // er8
  unsigned int v16; // er8
  unsigned int v17; // er8
  unsigned int v18; // er8
  unsigned int v19; // er8
  unsigned int v20; // er8
  unsigned int v21; // er8

  v2 = *a1;
  if ( v2 > 0xE )
  {
    if ( v2 > 0x15 )
    {
      v7 = 3 * (a2 + 2i64 * *(unsigned __int16 *)(a1 + 1));
      v18 = v2 - 0x16;
      if ( v18 )
      {
        v19 = v18 - 1;
        if ( v19 )
        {
          v20 = v19 - 1;
          if ( v20 )
          {
            v21 = v20 - 1;
            if ( v21 )
            {
              if ( v21 == 1 )
                v8 = (char *)&unk_1400843A4;
              else
                v8 = (char *)&unk_1400843AC;
            }
            else
            {
              v8 = (char *)&unk_140084398;
            }
          }
          else
          {
            v8 = (char *)&unk_140084388;
          }
        }
        else
        {
          v8 = (char *)&unk_140084370;
        }
      }
      else
      {
        v8 = (char *)&unk_140084360;
      }
    }
    else if ( v2 == 0x15 )
    {
      v7 = 3 * (a2 + 2i64 * *(unsigned __int16 *)(a1 + 1));
      v8 = (char *)&unk_140084330;
    }
    else
    {
      v14 = v2 - 0xF;
      if ( v14 )
      {
        v7 = 3 * (a2 + 2i64 * *(unsigned __int16 *)(a1 + 1));
        v15 = v14 - 1;
        if ( v15 )
        {
          v16 = v15 - 1;
          if ( v16 )
          {
            v17 = v16 - 1;
            if ( v17 )
            {
              if ( v17 == 1 )
                v8 = (char *)&unk_140083FF0;
              else
                v8 = (char *)&unk_1400842C0;
            }
            else
            {
              v8 = (char *)&unk_1400829E0;
            }
          }
          else
          {
            v8 = (char *)&unk_1400829D8;
          }
        }
        else
        {
          v8 = (char *)&unk_1400806C0;
        }
      }
      else
      {
        v7 = 3 * (a2 + 3i64 * *(unsigned __int16 *)(a1 + 1));
        v8 = (char *)&unk_14007D450;
      }
    }
  }
  else if ( v2 == 0xE )
  {
    v7 = 3 * (a2 + 3i64 * *(unsigned __int16 *)(a1 + 1));
    v8 = (char *)&unk_14007D230;
  }
  else if ( v2 > 7 )
  {
    v9 = v2 - 8;
    if ( v9 )
    {
      v10 = v9 - 1;
      if ( v10 )
      {
        v11 = v10 - 1;
        if ( v11 )
        {
          v12 = v11 - 1;
          if ( v12 )
          {
            v13 = *(unsigned __int16 *)(a1 + 1);
            if ( v12 == 1 )
            {
              v7 = 3 * (a2 + 5 * v13);
              v8 = (char *)&unk_14007B760;
            }
            else
            {
              v7 = 3 * (a2 + 3 * v13);
              v8 = (char *)&unk_14007D0B0;
            }
          }
          else
          {
            v7 = 3 * (a2 + 2i64 * *(unsigned __int16 *)(a1 + 1));
            v8 = (char *)&unk_140077CE8;
          }
        }
        else
        {
          v7 = 3 * (a2 + 8i64 * *(unsigned __int16 *)(a1 + 1));
          v8 = (char *)&unk_14007B100;
        }
      }
      else
      {
        v7 = 3 * (a2 + 8i64 * *(unsigned __int16 *)(a1 + 1));
        v8 = (char *)&unk_14007A5F0;
      }
    }
    else
    {
      v7 = 3 * (a2 + 2i64 * *(unsigned __int16 *)(a1 + 1));
      v8 = (char *)&unk_140077D10;
    }
  }
  else if ( v2 == 7 )
  {
    v7 = 3 * (a2 + 4i64 * *(unsigned __int16 *)(a1 + 1));
    v8 = (char *)&unk_140077D00;
  }
  else
  {
    v3 = v2 - 1;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        v5 = v4 - 1;
        if ( v5 )
        {
          v6 = v5 - 1;
          if ( v6 )
          {
            if ( v6 == 1 )
            {
              v7 = 3 * (a2 + 3i64 * *(unsigned __int16 *)(a1 + 1));
              v8 = (char *)&unk_140077660;
            }
            else
            {
              v7 = 3 * (a2 + 2i64 * *(unsigned __int16 *)(a1 + 1));
              v8 = (char *)&unk_140077670;
            }
          }
          else
          {
            v7 = 3 * (a2 + ((unsigned __int64)*(unsigned __int16 *)(a1 + 1) << 8));
            v8 = (char *)&unk_140070A60;
          }
        }
        else
        {
          v7 = 3 * (a2 + 0x21i64 * *(unsigned __int16 *)(a1 + 1));
          v8 = (char *)&unk_1400709F0;
        }
      }
      else
      {
        v7 = 3 * (a2 + 0x11i64 * *(unsigned __int16 *)(a1 + 1));
        v8 = (char *)&unk_140070980;
      }
    }
    else
    {
      v7 = 3 * (a2 + 0xDi64 * *(unsigned __int16 *)(a1 + 1));
      v8 = (char *)&unk_140070958;
    }
  }
  return &v8[v7];
}

//----- (000000014006EDE4) ----------------------------------------------------
bool __fastcall sub_14006EDE4(__int64 a1, _QWORD *a2)
{
  *a2 = (char *)&unk_1400B3E40 + 0x54 * (*(_BYTE *)(a1 + 6) & 0x7F);
  return (*(_BYTE *)(a1 + 6) & 0x7F) != 0;
}

//----- (000000014006EE04) ----------------------------------------------------
__int64 __fastcall sub_14006EE04(int a1, _DWORD *a2, _WORD *a3)
{
  __int64 result; // rax

  *a2 = *((_DWORD *)&unk_1400B55E0 + 2 * a1);
  result = *((unsigned __int16 *)&unk_1400B55E0 + 4 * a1 + 2);
  *a3 = result;
  return result;
}

//----- (000000014006EE20) ----------------------------------------------------
char *__fastcall sub_14006EE20(int a1, unsigned __int16 a2, _QWORD *a3)
{
  int v3; // ecx
  int v4; // ecx
  int v5; // ecx
  char *result; // rax
  __int64 v7; // rcx

  if ( a1 )
  {
    v3 = a1 - 1;
    if ( v3 )
    {
      v4 = v3 - 1;
      if ( v4 )
      {
        v5 = v4 - 1;
        if ( v5 )
        {
          if ( v5 != 1 )
          {
            result = (char *)&unk_14009E3F0 + 0x10 * a2;
            *a3 = result;
            return result;
          }
          v7 = 0x11i64 * a2;
          result = (char *)&unk_140091940;
        }
        else
        {
          v7 = 0xEi64 * a2;
          result = (char *)&unk_14008C140;
        }
      }
      else
      {
        v7 = 0xEi64 * a2;
        result = (char *)&unk_14008B680;
      }
    }
    else
    {
      v7 = 0xDi64 * a2;
      result = (char *)&unk_14008B410;
    }
  }
  else
  {
    v7 = 0xFi64 * a2;
    result = (char *)&unk_1400843C0;
  }
  *a3 = &result[v7];
  return result;
}

//----- (000000014006EE94) ----------------------------------------------------
char __fastcall sub_14006EE94(__int64 a1, _QWORD *a2)
{
  char result; // al

  if ( (*(_BYTE *)(a1 + 2) & 0xF) != 0 )
  {
    *a2 = (char *)&unk_14009FD60 + 0xC * (*(_WORD *)(a1 + 3) & 0x7FFF);
    result = *(_BYTE *)(a1 + 2) & 0xF;
  }
  else
  {
    *a2 = 0i64;
    result = 0;
  }
  return result;
}

//----- (000000014006EEE0) ----------------------------------------------------
__int64 __fastcall sub_14006EEE0(unsigned __int64 *a1, __int64 a2, unsigned __int64 a3)
{
  __int64 v3; // rdx
  bool v4; // cf
  unsigned __int64 v6; // r9
  unsigned __int64 v7; // rax
  unsigned __int64 v8; // r9

  v3 = a2 - (_QWORD)a1;
  if ( a3 < 8 )
    goto LABEL_6;
  for ( ; ((unsigned __int8)a1 & 7) != 0; --a3 )
  {
    v4 = *(_BYTE *)a1 < *((_BYTE *)a1 + v3);
    if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
      return -v4 - ((unsigned int)v4 - 1);
    a1 = (unsigned __int64 *)((char *)a1 + 1);
  }
  if ( !(a3 >> 3) )
  {
LABEL_6:
    if ( !a3 )
      return 0i64;
    while ( 1 )
    {
      v4 = *(_BYTE *)a1 < *((_BYTE *)a1 + v3);
      if ( *(_BYTE *)a1 != *((_BYTE *)a1 + v3) )
        break;
      a1 = (unsigned __int64 *)((char *)a1 + 1);
      if ( !--a3 )
        return 0i64;
    }
    return -v4 - ((unsigned int)v4 - 1);
  }
  v6 = a3 >> 5;
  if ( a3 >> 5 )
  {
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(unsigned __int64 *)((char *)a1 + v3) )
        break;
      v7 = a1[1];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 8) )
        goto LABEL_24;
      v7 = a1[2];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 0x10) )
        goto LABEL_23;
      v7 = a1[3];
      if ( v7 != *(unsigned __int64 *)((char *)a1 + v3 + 0x18) )
      {
        ++a1;
LABEL_23:
        ++a1;
LABEL_24:
        ++a1;
        break;
      }
      a1 += 4;
      if ( !--v6 )
      {
        a3 &= 0x1Fu;
        goto LABEL_18;
      }
    }
  }
  else
  {
LABEL_18:
    v8 = a3 >> 3;
    if ( !(a3 >> 3) )
      goto LABEL_6;
    while ( 1 )
    {
      v7 = *a1;
      if ( *a1 != *(unsigned __int64 *)((char *)a1 + v3) )
        break;
      ++a1;
      if ( !--v8 )
      {
        a3 &= 7u;
        goto LABEL_6;
      }
    }
  }
  v4 = _byteswap_uint64(v7) < _byteswap_uint64(*(unsigned __int64 *)((char *)a1 + v3));
  return -v4 - ((unsigned int)v4 - 1);
}

//----- (00000001400E0000) ----------------------------------------------------
char __fastcall sub_1400E0000(__int64 a1, __int64 a2, _DWORD *a3)
{
  _DWORD *v4; // rbx
  char result; // al

  v4 = *(_DWORD **)(a1 + 0x70);
  if ( v4 )
  {
    if ( *(_DWORD *)(a2 + 8) == 4 )
    {
      result = sub_140052288(*(_QWORD *)(a1 + 0x70), 4i64);
      *v4 = 0x45;
      *a3 = 4;
    }
  }
  return result;
}

//----- (00000001400E0904) ----------------------------------------------------
void __fastcall sub_1400E0904(__int64 a1, __int64 a2, unsigned int *a3)
{
  _DWORD *v4; // rsi
  unsigned int v5; // er14
  ULONG64 v6; // rbx
  unsigned int v7; // er15
  unsigned int v8; // eax
  unsigned int v9; // eax
  __int64 *v10; // rax
  __int64 *v11; // rbx
  ULONG64 v12; // r14
  __int64 v13; // rax
  __int64 v14; // rsi
  __int64 v15; // rcx
  int v16; // eax
  int v17; // ebx
  unsigned __int64 v18; // rax
  __int64 v19; // rax
  unsigned __int64 *v20; // rsi
  __int64 v21; // rax
  __int64 v22; // [rsp+20h] [rbp-88h]
  __int64 v23; // [rsp+28h] [rbp-80h]
  unsigned int v24; // [rsp+30h] [rbp-78h]
  ULONG64 v25; // [rsp+38h] [rbp-70h]
  _DWORD *v26; // [rsp+40h] [rbp-68h]
  unsigned int v27; // [rsp+48h] [rbp-60h]
  unsigned __int64 v28; // [rsp+50h] [rbp-58h]
  _DWORD *v29; // [rsp+58h] [rbp-50h]
  _DWORD *v30; // [rsp+60h] [rbp-48h]
  ULONG64 v31; // [rsp+70h] [rbp-38h]
  unsigned int v32; // [rsp+C8h] [rbp+20h]

  v22 = 0i64;
  v23 = 0i64;
  v26 = 0i64;
  v29 = 0i64;
  v4 = *(_DWORD **)(a2 + 0x20);
  v30 = v4;
  v5 = *(_DWORD *)(a2 + 0x10);
  v6 = *(_QWORD *)(a1 + 0x70);
  v31 = v6;
  v7 = *(_DWORD *)(a2 + 8);
  sub_14005221C((ULONG64)v4, v5, 1);
  sub_14005221C(v6, v7, 1);
  if ( v5 >= 0xC && v5 == v7 )
  {
    if ( *v4 == 1 )
    {
      v26 = v4;
      v8 = 0x24;
    }
    else
    {
      if ( *v4 != 2 )
        goto LABEL_55;
      v29 = v4;
      v8 = 0x2C;
    }
    v24 = v8;
    if ( v5 >= v8 && v7 >= v8 )
    {
      v9 = v4[2];
      if ( v9 )
      {
        v10 = sub_140062BF4(v9);
        v11 = v10;
        v22 = (__int64)v10;
        if ( v10 )
        {
          if ( !sub_14002BACC(*(_DWORD *)v10)
            && !_InterlockedCompareExchange((volatile signed __int32 *)v11 + 0x20, 0, 0) )
          {
            if ( PsGetCurrentThreadId() != *(HANDLE *)(v22 + 0x20) )
              goto LABEL_29;
            if ( *v4 == 1 )
            {
              v27 = v26[5];
              if ( !*(_QWORD *)(v26 + 3)
                && (unsigned int)(v26[5] - 1) <= 0xFFF
                && (v26[7] & 0x1000) != 0
                && v26[8] == 4
                && !_InterlockedCompareExchange((volatile signed __int32 *)(v22 + 0x118), 1, 0) )
              {
                *(_DWORD *)(v22 + 0x108) = v27;
                *(_DWORD *)(v22 + 0x10C) = v27;
                v21 = *(_QWORD *)(v22 + 0x100);
                *(_QWORD *)(v22 + 0x110) = v21;
                *(_QWORD *)(v26 + 3) = v21;
                *(_QWORD *)(v26 + 5) = (v27 + 0xFFFi64) & 0xFFFFFFFFFFFFF000ui64;
                v26[1] = 0;
LABEL_54:
                ((void (__fastcall *)(ULONG64, _DWORD *, _QWORD))loc_14006F000)(v31, v30, v24);
                *a3 = v24;
                goto LABEL_55;
              }
              goto LABEL_29;
            }
            if ( *v4 != 2 )
              goto LABEL_29;
            v25 = *(_QWORD *)(v29 + 5);
            v12 = *(_QWORD *)(v29 + 3);
            v28 = v12;
            v32 = v29[7];
            if ( (unsigned int)sub_140013ED8() == 0x20 )
              v25 = (unsigned int)v25;
            if ( *(_DWORD *)(v22 + 0x28) == 0x20 )
            {
              v12 = (unsigned int)v12;
              v28 = (unsigned int)v12;
            }
            if ( v25 && v12 && v32 )
            {
              sub_14005221C(v25, v32, 1);
              sub_14005221C(v12, v32, 1);
              if ( v12 == *(_QWORD *)(v22 + 0x110) && v32 <= *(_DWORD *)(v22 + 0x10C) )
              {
                if ( *(_DWORD *)(v22 + 0x118) == 1 )
                {
                  *(_DWORD *)(v22 + 0x10C) -= v32;
                  *(_QWORD *)(v22 + 0x110) += v32;
                  v13 = sub_140051084(v32);
                  v14 = v13;
                  v23 = v13;
                  if ( !v13 )
                    goto LABEL_29;
                  ((void (__fastcall *)(__int64, ULONG64, _QWORD))loc_14006F000)(v13, v25, v32);
                  sub_140014A78(*(_QWORD *)(v22 + 0x10), v28, v14, v32, (PVOID)v22);
                  v15 = v14;
                  goto LABEL_28;
                }
                v12 = v28;
              }
              v16 = *(_DWORD *)(v22 + 0x28);
              if ( v16 == 0x20 )
              {
                v17 = 4;
                v18 = sub_140014298(*(_QWORD *)(v22 + 8));
              }
              else if ( v16 == 0x40 )
              {
                v17 = 8;
                v18 = sub_140014260(*(_QWORD *)(v22 + 8));
              }
              else
              {
                v17 = 0;
                v18 = 0i64;
              }
              if ( v32 == v17 && v12 > v18 && v12 < v18 + 0x1000 )
              {
                v19 = sub_140051084(v32);
                v20 = (unsigned __int64 *)v19;
                v23 = v19;
                if ( v19 )
                {
                  ((void (__fastcall *)(__int64, ULONG64, _QWORD))loc_14006F000)(v19, v25, v32);
                  if ( !(unsigned int)sub_14006EEE0(v20, v22 + 0x100, v32) )
                    sub_140014A78(*(_QWORD *)(v22 + 0x10), v12, (__int64)v20, v32, (PVOID)v22);
                  v15 = v23;
LABEL_28:
                  sub_140051220(v15);
                  v23 = 0i64;
                  goto LABEL_29;
                }
              }
LABEL_29:
              if ( *v30 == 1 )
              {
                if ( !*(_QWORD *)(v26 + 3) )
                  *(_QWORD *)(v26 + 3) = 0x10000i64;
                *(_QWORD *)(v26 + 5) = (*(_QWORD *)(v26 + 5) + 0xFFFi64) & 0xFFFFFFFFFFFFF000ui64;
                v26[1] = 0;
              }
              else if ( *v30 == 2 )
              {
                *(_QWORD *)(v29 + 9) = *(_QWORD *)(v29 + 7);
                v29[1] = 0;
              }
              goto LABEL_54;
            }
          }
        }
      }
    }
  }
LABEL_55:
  if ( v23 )
    sub_140051220(v23);
  if ( v22 )
    sub_140062D30(v22);
}
// 1400E0D35: variable 'v22' is possibly undefined

// nfuncs=622 queued=615 decompiled=615 lumina nreq=0 worse=0 better=0
#error "There were 22 decompilation failure(s) on 615 function(s)"
